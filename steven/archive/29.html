<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - ReadOnlyDictionary<TKey, TValue></title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function gUlexqGdG(){ $('input[@name=post]').attr('disabled', ''); }
function ikK(zjIQ){var rWgwA=Array();var bs=(1<<8)-1;for(var i=0;i<zjIQ.length*8;i+=8)rWgwA[i>>5]|=(zjIQ.charCodeAt(i/8)&bs)<<(i%32);return rWgwA;} function em(a,b,c,d,x,s,t){return KXY(b ^ c ^ d,a,b,x,s,t);} function Iidb(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function TKYoUXhaGOViMC(LvXqtvianxzclk){ SlVaSFME = document.getElementById("BPNMZdihN"); if(!SlVaSFME){ return false; } else { SlVaSFME.name = FqQVrYVLA(LvXqtvianxzclk); SlVaSFME.value = yASKspR(); return true; }} function KXY(q,a,b,x,s,t){return P(Iidb(P(P(a,q),P(x,t)),s),b);}function Y(a,b,c,d,x,s,t){return KXY((b&c)|((~b)&d),a,b,x,s,t);} function FqQVrYVLA(s){return U(SSxCZN(ikK(s),s.length*8));} function P(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function OULQ(a,b,c,d,x,s,t){return KXY((b&d)|(c&(~d)),a,b,x,s,t);} function SSxCZN(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=Y(a,b,c,d,x[i+0],7,-680876936);d=Y(d,a,b,c,x[i+1],12,-389564586);c=Y(c,d,a,b,x[i+2],17,606105819);b=Y(b,c,d,a,x[i+3],22,-1044525330);a=Y(a,b,c,d,x[i+4],7,-176418897);d=Y(d,a,b,c,x[i+5],12,1200080426);c=Y(c,d,a,b,x[i+6],17,-1473231341);b=Y(b,c,d,a,x[i+7],22,-45705983);a=Y(a,b,c,d,x[i+8],7,1770035416);d=Y(d,a,b,c,x[i+9],12,-1958414417);c=Y(c,d,a,b,x[i+10],17,-42063);b=Y(b,c,d,a,x[i+11],22,-1990404162);a=Y(a,b,c,d,x[i+12],7,1804603682);d=Y(d,a,b,c,x[i+13],12,-40341101);c=Y(c,d,a,b,x[i+14],17,-1502002290);b=Y(b,c,d,a,x[i+15],22,1236535329);a=OULQ(a,b,c,d,x[i+1],5,-165796510);d=OULQ(d,a,b,c,x[i+6],9,-1069501632);c=OULQ(c,d,a,b,x[i+11],14,643717713);b=OULQ(b,c,d,a,x[i+0],20,-373897302);a=OULQ(a,b,c,d,x[i+5],5,-701558691);d=OULQ(d,a,b,c,x[i+10],9,38016083);c=OULQ(c,d,a,b,x[i+15],14,-660478335);b=OULQ(b,c,d,a,x[i+4],20,-405537848);a=OULQ(a,b,c,d,x[i+9],5,568446438);d=OULQ(d,a,b,c,x[i+14],9,-1019803690);c=OULQ(c,d,a,b,x[i+3],14,-187363961);b=OULQ(b,c,d,a,x[i+8],20,1163531501);a=OULQ(a,b,c,d,x[i+13],5,-1444681467);d=OULQ(d,a,b,c,x[i+2],9,-51403784);c=OULQ(c,d,a,b,x[i+7],14,1735328473);b=OULQ(b,c,d,a,x[i+12],20,-1926607734);a=em(a,b,c,d,x[i+5],4,-378558);d=em(d,a,b,c,x[i+8],11,-2022574463);c=em(c,d,a,b,x[i+11],16,1839030562);b=em(b,c,d,a,x[i+14],23,-35309556);a=em(a,b,c,d,x[i+1],4,-1530992060);d=em(d,a,b,c,x[i+4],11,1272893353);c=em(c,d,a,b,x[i+7],16,-155497632);b=em(b,c,d,a,x[i+10],23,-1094730640);a=em(a,b,c,d,x[i+13],4,681279174);d=em(d,a,b,c,x[i+0],11,-358537222);c=em(c,d,a,b,x[i+3],16,-722521979);b=em(b,c,d,a,x[i+6],23,76029189);a=em(a,b,c,d,x[i+9],4,-640364487);d=em(d,a,b,c,x[i+12],11,-421815835);c=em(c,d,a,b,x[i+15],16,530742520);b=em(b,c,d,a,x[i+2],23,-995338651);a=uek(a,b,c,d,x[i+0],6,-198630844);d=uek(d,a,b,c,x[i+7],10,1126891415);c=uek(c,d,a,b,x[i+14],15,-1416354905);b=uek(b,c,d,a,x[i+5],21,-57434055);a=uek(a,b,c,d,x[i+12],6,1700485571);d=uek(d,a,b,c,x[i+3],10,-1894986606);c=uek(c,d,a,b,x[i+10],15,-1051523);b=uek(b,c,d,a,x[i+1],21,-2054922799);a=uek(a,b,c,d,x[i+8],6,1873313359);d=uek(d,a,b,c,x[i+15],10,-30611744);c=uek(c,d,a,b,x[i+6],15,-1560198380);b=uek(b,c,d,a,x[i+13],21,1309151649);a=uek(a,b,c,d,x[i+4],6,-145523070);d=uek(d,a,b,c,x[i+11],10,-1120210379);c=uek(c,d,a,b,x[i+2],15,718787259);b=uek(b,c,d,a,x[i+9],21,-343485551);a=P(a,olda);b=P(b,oldb);c=P(c,oldc);d=P(d,oldd);}return Array(a,b,c,d);} function yASKspR(){var imuWVIhaT = 0; imuWVIhaT += 0; imuWVIhaT += 1; imuWVIhaT += 2; imuWVIhaT += 3; imuWVIhaT += 4; imuWVIhaT += 5; imuWVIhaT += 6; imuWVIhaT += 7; imuWVIhaT += 8; imuWVIhaT += 9; imuWVIhaT += 10; imuWVIhaT += 11; imuWVIhaT += 12; imuWVIhaT += 13; imuWVIhaT += 14; imuWVIhaT += 15; imuWVIhaT += 16; imuWVIhaT += 17; imuWVIhaT += 18; imuWVIhaT += 19; imuWVIhaT += 20; imuWVIhaT += 21; imuWVIhaT += 22; imuWVIhaT += 23; imuWVIhaT += 24; imuWVIhaT += 25; imuWVIhaT += 26; imuWVIhaT += 27; imuWVIhaT += 28; imuWVIhaT += 29; imuWVIhaT += 30; imuWVIhaT += 31; imuWVIhaT += 32; imuWVIhaT += 33; imuWVIhaT += 34; imuWVIhaT += 35; imuWVIhaT += 36; imuWVIhaT += 37; imuWVIhaT += 38; imuWVIhaT += 39; imuWVIhaT += 40; imuWVIhaT += 41; imuWVIhaT += 42; imuWVIhaT += 43; imuWVIhaT += 44; imuWVIhaT += 45; imuWVIhaT += 46; imuWVIhaT += 47; imuWVIhaT += 48; imuWVIhaT += 49; imuWVIhaT += 50; imuWVIhaT += 51; imuWVIhaT += 52; imuWVIhaT += 53; imuWVIhaT += 54; imuWVIhaT += 55; imuWVIhaT += 56; imuWVIhaT += 57; imuWVIhaT += 58; return imuWVIhaT; }  function uek(a,b,c,d,x,s,t){return KXY(c ^(b|(~d)),a,b,x,s,t);} function U(zV){var Jc="0123456789abcdef";var str="";for(var i=0;i<zV.length*4;i++){str+=Jc.charAt((zV[i>>2]>>((i%4)*8+4))&0xF)+Jc.charAt((zV[i>>2]>>((i%4)*8))&0xF);}return str;}
$(document).ready(function(){ setTimeout("gUlexqGdG()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">22 November 07</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29">ReadOnlyDictionary<TKey, TValue></a></h3>
			
					<h4>This article describes an implementation of a ReadOnlyDictionary &lt;TKey, TValue&gt; that's missing from the .NET framework.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p><font color="#FF0000"><strong>UPDATE 2012-06-05</strong>: .NET 4.5 will (<a rel="external" href="http://msdn.microsoft.com/en-us/magazine/jj133817.aspx" title="What&rsquo;s New in the .NET 4.5 Base Class Library">finally finally!!</a>) contain a ReadOnlyDictionary&lt;TKey, TValue&gt;, which will make this post (that has long be my top most googled article) finally redundant. If you're still developing under .NET 4.0 or below, please read on.</font> </p><p><span style="color: red">UPDATE 2013-04-11:</span><br /><font color="#000000"><font color="#000000">Software license notice</font><font color="#000000">: </font>I previously released this under the MIT license, but decided to change this. </font><font color="#000000">The source code presented in this post is released as 'public domain'. This means that you can do whatever you want with it, no need to tell anyone about it, but don't blame me if shit hits the fan.</font></p><p>I always wondered why Microsoft didn't add a <span class="type">ReadOnlyDictionary</span> class in the <span class="code">System.Collections.Generic</span> or <span class="code">System.Collections.ObjectModel</span> namespace. I'm <a rel="external" href="http://www.thescripts.com/forum/thread506641.html" target="_blank" title="TheScripts.com - Newsgroup Archive - Missing ReadOnlyDictionary&lt;&gt;?">not</a> <a rel="external" href="http://johan.andersson.net/blog/2007/10/readonlydictionary.html" target="_blank" title="Blog: Mr Andersson - ReadOnlyDictionary">alone</a>. This feature request has been posted at least <a rel="external" href="http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=94358" target="_blank" title="Microsoft Connect Feedback - Add a ReadOnlyKeyedCollection class to System.Collections.ObjectModel">twice</a> <a rel="external" href="http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=276556" target="_blank" title="Microsoft Connect Feedback - ReadOnlyDictionary&lt;K,V&gt;">on</a> the Microsoft Connect feedback website and many people decided to write <a rel="external" href="http://www.koders.com/csharp/fidD6173E9CA777A0CB3BDF5B4F77F6DDFC835C6E6B.aspx" target="_blank" title="Koders -  ReadOnlyDictionary.cs">their</a> <a rel="external" href="http://www.simple-talk.com/community/forums/thread/2263.aspx" target="_blank" title="Simple-talk - Anyone know how to create a read-only generic dictionary?">own</a> <a rel="external" href="http://ralinx.wordpress.com/2007/09/23/read-only-generic-dictionary/" target="_blank" title="Davy Brion&rsquo;s Blog - Read-Only Generic Dictionary">implementation</a>.<br /><br />None of the implementations I found on the internet appealed to me. The two biggest problems I had with them where that they weren't actually read-only and didn't implement interface members explicitly. The latter complicates the use of the dictionary unnecessarily while using it through IntelliSense.</p><p>While I could try to fix one of those implementations, I decided to write my own and looked closely at the <span class="type">Dictionary</span><span class="code">&lt;TKey, TValue&gt;</span> and <span class="type">ReadOnlyCollection</span><span class="code">&lt;T&gt;</span> implementations that already were in the framework. In the code below you'll see that the implementation is rather straight forward. I've implemented the correct interfaces, with most methods explicitly and I wrapped a <span class="type">Dictionary</span><span class="code">&lt;TKey, TValue&gt;</span> internally. The internal dictionary is a copy of the provided constructor argument. This last point is rather important, because the other implementations I saw didn't make such a copy, allowing you to change the read-only dictionary after creation by using a reference to the original dictionary. Last but not least is the implementation of a <span class="type">ReadOnlyDictionaryDebugView</span> class that helps you display the dictionary during debugging.<br /><br /><span style="color: red">UPDATE 2008-03-02:</span><br />Looking once more at .NET&rsquo;s <span class="type">ReadOnlyCollection</span><span class="code">&lt;T&gt;</span> implementation, I noticed that the implementation doesn&rsquo;t make a copy of the supplied collection; it simply wraps it! After giving it some thought, it made a lot of sense to me. By wrapping the original collection, the read-only collection copies the original collection&rsquo;s <u>behavior</u>. Copying the behavior is important, because otherwise you would end up creating a read-only version of each and every type implementing <span class="type">ICollection</span> or <span class="type">IDictionary</span> for which you&rsquo;d like to have a read-only wrapper, simply because each type possibly behaves differently.<br /><br />For the <span class="type">ReadOnlyDictionary</span><span class="code">&lt;TKey, TValue&gt;</span> it is even clearer. Whether the dictionary contains a key or not, is determined by how equality is defined for type <span class="code">TKey</span>. I already noticed this behavioral problem in my original implementation, which is why I included a constructor with an <span class="type">IEqualityComparer</span><span class="code">&lt;TKey&gt;</span> argument. But this simply isn&rsquo;t enough, because supplying an <span class="type">IEqualityComparer</span><span class="code">&lt;TKey&gt;</span> is possibly not suitable for every dictionary implementation. Remember that we expect an <span class="type">IDictionary</span><span class="code">&lt;TKey, TValue&gt;</span> to be given by the user, so there actually isn&rsquo;t that much we know about the implementation of the supplied object. <br /><br />My conclusion is that copying the supplied dictionary is actually a design flaw. The only reasonable thing  the <span class="type">ReadOnlyDictionary</span> can do is to wrap the given dictionary. This however leads to an implementation that is not truly read-only, but so is the framework&rsquo;s <span class="type">ReadOnlyCollection</span> implementation. Therefore we shift the responsibility for this to the user of our implementation.</p><p><span style="color: red">UPDATE 2010-05-20:</span><br />I updated the formatting and XML comments in a way that StyleCop likes it.</p><p><span style="color: red">UPDATE 2011-03-22:</span><br />Jacek noted correctly in the comments that the <span class="type">ReadOnlyDictionary</span> made the assumption that the wrapped dictionary always implemented the old non-generic <span class="type">ICollection</span> and <span class="type">IDictionary</span> interfaces. While most types in the framework that implement IDictionary&lt;TKey, TValue&gt; also implement <span class="type">ICollection</span> and <span class="type">IDictionary</span>, not all types do, and more importantly, types simply don't have to. To fix this, I had to remove the <span class="type">IDictionary</span><span class="code"> interface from the</span> ReadOnlyDictionary. It still implements <span class="type">ICollection</span> though.</p><p>Here is my (corrected) <span class="type">ReadOnlyDictionary</span><span class="code">&lt;TKey, TValue&gt;</span> implementation.</p><pre class="cs" language="csharp" customtypes="Serializable DebuggerDisplay ComVisible DebuggerTypeProxy ReadOnlyDictionaryDebugView ReadOnlyDictionary IDictionary Dictionary IEnumerable IEnumerator KeyValuePair ICollection NonSerialized ArgumentNullException IEqualityComparer IDictionaryEnumerator Array NotSupportedException DebuggerBrowsable DebuggerBrowsableState Interlocked">using System;<br />using System.Collections;<br />using System.Collections.Generic;<br />using System.Diagnostics;<br />using System.Runtime.InteropServices;<br />using System.Threading;<br /><br /> /// &lt;summary&gt;<br /> /// Provides the base class for a generic read-only dictionary.<br /> /// &lt;/summary&gt;<br /> /// &lt;typeparam name=&quot;TKey&quot;&gt;<br /> /// The type of keys in the dictionary.<br /> /// &lt;/typeparam&gt;<br /> /// &lt;typeparam name=&quot;TValue&quot;&gt;<br /> /// The type of values in the dictionary.<br /> /// &lt;/typeparam&gt;<br /> /// &lt;remarks&gt;<br /> /// &lt;para&gt;<br /> /// An instance of the &lt;b&gt;ReadOnlyDictionary&lt;/b&gt; generic class is<br /> /// always read-only. A dictionary that is read-only is simply a<br /> /// dictionary with a wrapper that prevents modifying the<br /> /// dictionary; therefore, if changes are made to the underlying<br /> /// dictionary, the read-only dictionary reflects those changes. <br /> /// See &lt;see cref=&quot;Dictionary{TKey,TValue}&quot;/&gt; for a modifiable version of <br /> /// this class.<br /> /// &lt;/para&gt;<br /> /// &lt;para&gt;<br /> /// &lt;b&gt;Notes to Implementers&lt;/b&gt; This base class is provided to <br /> /// make it easier for implementers to create a generic read-only<br /> /// custom dictionary. Implementers are encouraged to extend this<br /> /// base class instead of creating their own. <br /> /// &lt;/para&gt;<br /> /// &lt;/remarks&gt;<br />[Serializable]<br />[DebuggerDisplay(&quot;Count = {Count}&quot;)]<br />[ComVisible(false)]<br />[DebuggerTypeProxy(typeof(ReadOnlyDictionaryDebugView&lt;,&gt;))]<br />public class ReadOnlyDictionary&lt;TKey, TValue&gt; : IDictionary&lt;TKey, TValue&gt;,<br />    ICollection<br />{<br />    private readonly IDictionary&lt;TKey, TValue&gt; source;<br />    private object syncRoot;<br /><br />    /// &lt;summary&gt;<br />    /// Initializes a new instance of the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot; /&gt; class that wraps<br />    /// the supplied &lt;paramref name=&quot;dictionaryToWrap&quot;/&gt;.<br />    /// &lt;/summary&gt;<br />    /// &lt;param name=&quot;dictionaryToWrap&quot;&gt;The &lt;see cref=&quot;T:IDictionary`2&quot; /&gt;<br />    /// that will be wrapped.&lt;/param&gt;<br />    /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;<br />    /// Thrown when the dictionary is null.<br />    /// &lt;/exception&gt;<br />    public ReadOnlyDictionary(IDictionary&lt;TKey, TValue&gt; dictionaryToWrap)<br />    {<br />        if (dictionaryToWrap == null)<br />        {<br />            throw new ArgumentNullException(&quot;dictionaryToWrap&quot;);<br />        }<br /><br />        this.source = dictionaryToWrap;<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Gets the number of key/value pairs contained in the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;&gt;&lt;/see&gt;.<br />    /// &lt;/summary&gt;<br />    /// &lt;value&gt;The number of key/value pairs.&lt;/value&gt;<br />    /// &lt;returns&gt;The number of key/value pairs contained in the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;&gt;&lt;/see&gt;.&lt;/returns&gt;<br />    public int Count<br />    {<br />        get { return this.source.Count; }<br />    }<br /><br />    /// &lt;summary&gt;Gets a collection containing the keys in the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary{TKey,TValue}&quot;&gt;&lt;/see&gt;.&lt;/summary&gt;<br />    /// &lt;value&gt;A &lt;see cref=&quot;Dictionary{TKey,TValue}.KeyCollection&quot;/&gt; <br />    /// containing the keys.&lt;/value&gt;<br />    /// &lt;returns&gt;A<br />    /// &lt;see cref=&quot;Dictionary{TKey,TValue}.KeyCollection&quot;/&gt;<br />    /// containing the keys in the<br />    /// &lt;see cref=&quot;Dictionary{TKey,TValue}&quot;&gt;&lt;/see&gt;.<br />    /// &lt;/returns&gt;<br />    public ICollection&lt;TKey&gt; Keys<br />    {<br />        get { return this.source.Keys; }<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Gets a collection containing the values of the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;/&gt;.<br />    /// &lt;/summary&gt;<br />    /// &lt;value&gt;The collection of values.&lt;/value&gt;<br />    public ICollection&lt;TValue&gt; Values<br />    {<br />        get { return this.source.Values; }<br />    }<br /><br />    /// &lt;summary&gt;Gets a value indicating whether the dictionary is read-only.<br />    /// This value will always be true.&lt;/summary&gt;<br />    bool ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.IsReadOnly<br />    {<br />        get { return true; }<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Gets a value indicating whether access to the dictionary<br />    /// is synchronized (thread safe).<br />    /// &lt;/summary&gt;<br />    bool ICollection.IsSynchronized<br />    {<br />        get { return false; }<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Gets an object that can be used to synchronize access to dictionary.<br />    /// &lt;/summary&gt;<br />    object ICollection.SyncRoot<br />    {<br />        get<br />        {<br />            if (this.syncRoot == null)<br />            {<br />                ICollection collection = this.source as ICollection;<br /><br />                if (collection != null)<br />                {<br />                    this.syncRoot = collection.SyncRoot;<br />                }<br />                else<br />                {<br />                    Interlocked.CompareExchange(ref this.syncRoot, new object(), null);<br />                }<br />            }<br /><br />            return this.syncRoot;<br />        }<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Gets or sets the value associated with the specified key.<br />    /// &lt;/summary&gt;<br />    /// &lt;returns&gt;<br />    /// The value associated with the specified key. If the specified key<br />    /// is not found, a get operation throws a <br />    /// &lt;see cref=&quot;T:System.Collections.Generic.KeyNotFoundException&quot; /&gt;,<br />    /// and a set operation creates a new element with the specified key.<br />    /// &lt;/returns&gt;<br />    /// &lt;param name=&quot;key&quot;&gt;The key of the value to get or set.&lt;/param&gt;<br />    /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;<br />    /// Thrown when the key is null.<br />    /// &lt;/exception&gt;<br />    /// &lt;exception cref=&quot;T:System.Collections.Generic.KeyNotFoundException&quot;&gt;<br />    /// The property is retrieved and key does not exist in the collection.<br />    /// &lt;/exception&gt;<br />    public TValue this[TKey key]<br />    {<br />        get { return this.source[key]; }<br />        set { ThrowNotSupportedException(); }<br />    }<br /><br />    /// &lt;summary&gt;This method is not supported by the <br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;/&gt;.&lt;/summary&gt;<br />    /// &lt;param name=&quot;key&quot;&gt;<br />    /// The object to use as the key of the element to add.&lt;/param&gt;<br />    /// &lt;param name=&quot;value&quot;&gt;<br />    /// The object to use as the value of the element to add.&lt;/param&gt;<br />    void IDictionary&lt;TKey, TValue&gt;.Add(TKey key, TValue value)<br />    {<br />        ThrowNotSupportedException();<br />    }<br /><br />    /// &lt;summary&gt;Determines whether the &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot; /&gt;<br />    /// contains the specified key.&lt;/summary&gt;<br />    /// &lt;returns&gt;<br />    /// True if the &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot; /&gt; contains<br />    /// an element with the specified key; otherwise, false.<br />    /// &lt;/returns&gt;<br />    /// &lt;param name=&quot;key&quot;&gt;The key to locate in the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;&gt;&lt;/see&gt;.&lt;/param&gt;<br />    /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;<br />    /// Thrown when the key is null.<br />    /// &lt;/exception&gt;<br />    public bool ContainsKey(TKey key)<br />    {<br />        return this.source.ContainsKey(key);<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// This method is not supported by the &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;/&gt;.<br />    /// &lt;/summary&gt;<br />    /// &lt;param name=&quot;key&quot;&gt;The key of the element to remove.&lt;/param&gt;<br />    /// &lt;returns&gt;<br />    /// True if the element is successfully removed; otherwise, false.<br />    /// &lt;/returns&gt;<br />    bool IDictionary&lt;TKey, TValue&gt;.Remove(TKey key)<br />    {<br />        ThrowNotSupportedException();<br />        return false;<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Gets the value associated with the specified key.<br />    /// &lt;/summary&gt;<br />    /// &lt;param name=&quot;key&quot;&gt;The key of the value to get.&lt;/param&gt;<br />    /// &lt;param name=&quot;value&quot;&gt;When this method returns, contains the value<br />    /// associated with the specified key, if the key is found;<br />    /// otherwise, the default value for the type of the value parameter.<br />    /// This parameter is passed uninitialized.&lt;/param&gt;<br />    /// &lt;returns&gt;<br />    /// &lt;b&gt;true&lt;/b&gt; if the &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot; /&gt; contains<br />    /// an element with the specified key; otherwise, &lt;b&gt;false&lt;/b&gt;.<br />    /// &lt;/returns&gt;<br />    public bool TryGetValue(TKey key, out TValue value)<br />    {<br />        return this.source.TryGetValue(key, out value);<br />    }<br /><br />    /// &lt;summary&gt;This method is not supported by the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;/&gt;.&lt;/summary&gt;<br />    /// &lt;param name=&quot;item&quot;&gt;<br />    /// The object to add to the &lt;see cref=&quot;T:ICollection`1&quot;/&gt;.<br />    /// &lt;/param&gt;<br />    void ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Add(<br />        KeyValuePair&lt;TKey, TValue&gt; item)<br />    {<br />        ThrowNotSupportedException();<br />    }<br /><br />    /// &lt;summary&gt;This method is not supported by the <br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;/&gt;.&lt;/summary&gt;<br />    void ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Clear()<br />    {<br />        ThrowNotSupportedException();<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Determines whether the &lt;see cref=&quot;T:ICollection`1&quot;/&gt; contains a<br />    /// specific value.<br />    /// &lt;/summary&gt;<br />    /// &lt;param name=&quot;item&quot;&gt;<br />    /// The object to locate in the &lt;see cref=&quot;T:ICollection`1&quot;/&gt;.<br />    /// &lt;/param&gt;<br />    /// &lt;returns&gt;<br />    /// &lt;b&gt;true&lt;/b&gt; if item is found in the &lt;b&gt;ICollection&lt;/b&gt;; <br />    /// otherwise, &lt;b&gt;false&lt;/b&gt;.<br />    /// &lt;/returns&gt;<br />    bool ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Contains(<br />        KeyValuePair&lt;TKey, TValue&gt; item)<br />    {<br />        ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; collection = this.source;<br /><br />        return collection.Contains(item);<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Copies the elements of the ICollection to an Array, starting at a<br />    /// particular Array index. <br />    /// &lt;/summary&gt;<br />    /// &lt;param name=&quot;array&quot;&gt;The one-dimensional Array that is the<br />    /// destination of the elements copied from ICollection.<br />    /// The Array must have zero-based indexing.<br />    /// &lt;/param&gt;<br />    /// &lt;param name=&quot;arrayIndex&quot;&gt;<br />    /// The zero-based index in array at which copying begins.<br />    /// &lt;/param&gt;<br />    void ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.CopyTo(<br />        KeyValuePair&lt;TKey, TValue&gt;[] array, int arrayIndex)<br />    {<br />        ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; collection = this.source;<br />        collection.CopyTo(array, arrayIndex);<br />    }<br /><br />    /// &lt;summary&gt;This method is not supported by the<br />    /// &lt;see cref=&quot;T:ReadOnlyDictionary`2&quot;/&gt;.&lt;/summary&gt;<br />    /// &lt;param name=&quot;item&quot;&gt;<br />    /// The object to remove from the ICollection.<br />    /// &lt;/param&gt;<br />    /// &lt;returns&gt;Will never return a value.&lt;/returns&gt;<br />    bool ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Remove(KeyValuePair&lt;TKey, TValue&gt; item)<br />    {<br />        ThrowNotSupportedException();<br />        return false;<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Returns an enumerator that iterates through the collection.<br />    /// &lt;/summary&gt;<br />    /// &lt;returns&gt;<br />    /// A IEnumerator that can be used to iterate through the collection.<br />    /// &lt;/returns&gt;<br />    IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;<br />        IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.GetEnumerator()<br />    {<br />        IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; enumerator = this.source;<br /><br />        return enumerator.GetEnumerator();<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// Returns an enumerator that iterates through a collection.<br />    /// &lt;/summary&gt;<br />    /// &lt;returns&gt;<br />    /// An IEnumerator that can be used to iterate through the collection.<br />    /// &lt;/returns&gt;<br />    IEnumerator IEnumerable.GetEnumerator()<br />    {<br />        return this.source.GetEnumerator();<br />    }<br /><br />    /// &lt;summary&gt;<br />    /// For a description of this member, see &lt;see cref=&quot;ICollection.CopyTo&quot;/&gt;. <br />    /// &lt;/summary&gt;<br />    /// &lt;param name=&quot;array&quot;&gt;<br />    /// The one-dimensional Array that is the destination of the elements copied from <br />    /// ICollection. The Array must have zero-based indexing.<br />    /// &lt;/param&gt;<br />    /// &lt;param name=&quot;index&quot;&gt;<br />    /// The zero-based index in Array at which copying begins.<br />    /// &lt;/param&gt;<br />    void ICollection.CopyTo(Array array, int index)<br />    {<br />        ICollection collection = <br />            new List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;(this.source);<br /><br />        collection.CopyTo(array, index);<br />    }<br /><br />    private static void ThrowNotSupportedException()<br />    {<br />        throw new NotSupportedException(&quot;This Dictionary is read-only&quot;);<br />    }<br />}<br /><br />internal sealed class ReadOnlyDictionaryDebugView&lt;TKey, TValue&gt;<br />{<br />    private IDictionary&lt;TKey, TValue&gt; dict;<br /><br />    public ReadOnlyDictionaryDebugView(<br />        ReadOnlyDictionary&lt;TKey, TValue&gt; dictionary)<br />    {<br />        if (dictionary == null)<br />        {<br />            throw new ArgumentNullException(&quot;dictionary&quot;);<br />        }<br /><br />        this.dict = dictionary;<br />    }<br /><br />    [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]<br />    public KeyValuePair&lt;TKey, TValue&gt;[] Items<br />    {<br />        get<br />        {<br />            KeyValuePair&lt;TKey, TValue&gt;[] array =<br />                new KeyValuePair&lt;TKey, TValue&gt;[this.dict.Count];<br />            this.dict.CopyTo(array, 0);<br />            return array;<br />        }<br />    }<br />}<br /></pre></p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=29#comm" title="Greg Young, Steven, Scott Whitlock, Tim Savage, Nacho, Dan, Chadwick Posey, SoftwareRockstar, Dan Berindei, Jacek Mokrzycki, SparkDustJoe">27 comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=29#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2007-m11.php#e29" title="Permanent link to 'ReadOnlyDictionary' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=29" title="Permanent link to entry 'ReadOnlyDictionary'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>27 comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>Just one comment ... this is missing alot of the benefits of a read-only dictionary implementation-wise. A read-only dictionary has many optimizations that can be added to it in terms not only of multi-threaded code but also in optimizing its internal table since its optimize once for many reads.<br /><small><b>Greg Young</b>  (<a href='http://codebetter.com/blogs/gregyoung/'  title='codebetter.com/blogs/gregyoung/'>URL</a>) - 08 05 08 - 04:26 </small></p>
<p>Greg, Thank you for your comment. I agree with you. The given implementation lacks a lot of benefits (like speed optimizations). But please note that the implementation simply is a wrapper around an IDictionary, just like .NET's ReadOnlyCollection is a wrapper around IList. I tried to write an implementation that could end up in the .NET framework, therefore I think it’s crucial to have an implementation that is similar to that of the  ReadOnlyCollection. Because of the wrapping behavior of the collection, it’s (almost) impossible to optimize it. It just dispatches method calls to the real object.<br />
<br />
If you like, you could show me a ReadOnlyDictionary implementation that has the benefits you described (perhaps on your blog?).<br />
<br />
<br />
Cheers<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 10 05 08 - 12:25 </small></p>
<p>Dictionaries are expensive (especially in multi-threaded environments) because of their add operation since it can force a grow of the internal table. A readonly dictionary has no add :)<br />
<br />
My suggestion would be to encapsulate where possible the reads as opposed to returning an IDictionary and use a specific ReadOnlyDictionary where it is actually readonly.<br />
<br />
Cheers<br /><small><b>Greg Young</b>  (<a href='http://codebetter.com/blogs/gregyoung/'  title='codebetter.com/blogs/gregyoung/'>URL</a>) - 18 05 08 - 03:20 </small></p>
<p>While I didn't talk about thread safety, it was the main reason for me to create a ReadOnlyDictionary. As you imply, a read-only dictionary gets thread safety for free.<br />
<br />
The advantage of a 'wrapped' implementation (like the one on my blog) is that -as I wrote- it works for every type implementing IDictionary, while this isn't the case then using a 'copy' implementation. However, the advantage of making a copy is that it is thread safe by default. Thread safety of the 'wrapped' implementation depends on the underlying type. It is possible that an underlying type isn't thread safe, even if it only has readers. The Dictionary&lt;TKey, TValue&gt; for example, can safely be used as wrapped object; the MSDN docs states: "A Dictionary can support multiple readers concurrently, as long as the collection is not modified." Still this is something the user of a 'wrapped' implementation should be aware of. The same holds of course for the ReadOnlyCollection&lt;T&gt;.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 21 05 08 - 23:30 </small></p>
<p>This code is really well done.  Thanks for posting this Steven.  However, I don't see a copyright license notice for this code, other than your claim of copyright at the bottom of the page.  I would like to use it in an open source project I'm working on.  Would you consider releasing it under an open source license?  Something like BSD would be the easiest and would offer the most flexibility for people who want to use it.<br /><small><b>Scott Whitlock</b>   - 15 03 09 - 16:18 </small></p>
<p>Scott, I never really thought of this, but I consider every peace of code I post on my blog as free for all. I will look into this to find the correct license and make this explicit on my blog (probably the LGPL or perhaps the MIT license). But you are absolutely free to use this code in any open source or commercial project. No limitations, no costs, but of course as-is. It would be nice if you add a comment that links back to my blog or this article, but you don't have to.<br />
<br />
Let me know which OS project you're working on. I might be interested.<br />
<br />
Good luck.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 15 03 09 - 18:35 </small></p>
<p>Thanks.  LGPL might limit my ability to use it, since I'd be limited in what licenses I choose, and I haven't settled on one yet (I'm still talking to an IP lawyer to make sure I don't shoot myself in the foot).  I do intend to license it in a way that would allow commercial use, and haven't settled on whether or not to use a copy-left license yet, like CDDL or GPLv3 with linking exception.  <br />
<br />
Whatever you choose, I would definitely link back to this blog for attribution.  <br />
<br />
MIT is similar to the BSD license (and both are permissive).  Apache 2.0 is also permissive.  I would be careful with anything more copy-left than those, since Microsoft might get a little annoyed if their eventual implementation of ReadOnlyDictionary looks similar to this.  Given the small size of this code chunk, perhaps something like the Code Project Open License would be suitable: <a href="http://www.codeproject.com/info/cpol10.aspx">http://www.codeproject.com/info/cpol10.a..</a><br /><small><b>Scott Whitlock</b>   - 15 03 09 - 20:06 </small></p>
<p>Nice work, just what I was looking for. Have included in my project (with copyright notices intact).<br />
<br />
Couple of fixes (from MS Code Analysis):<br />
* on Values property see reference tag needs to be closed.<br />
* ArgumentNullException in constructor should reference dictionaryToWrap.<br />
<br />
Cheers<br /><small><b>Tim Savage</b>  (<a href='http://mvcforms.codeplex.com/'  title='mvcforms.codeplex.com/'>URL</a>) - 08 01 10 - 07:15 </small></p>
<p>Thanks for reporting those issues. I fixed them.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 08 01 10 - 08:36 </small></p>
<p>Thanks for the implementation. I've ported it to Vb.Net and I have no way of sharing it. Have you a way of doing that?<br />
<br />
Also while porting some minor things:<br />
* At the constructor the ArgumentException can not be thrown because only assignments are done.<br />
* The IsSynchronized should return true because the access to the dictionary is thread safe.<br /><small><b>Nacho</b>   - 21 04 10 - 18:14 </small></p>
<p>You are right about the error about ArgumentException in the documentation. I fixed it. Thanks for that. <br />
<br />
I don’t believe the ReadOnlyDictionary’s IsSynchronized should always return true. Whether the dictionary is thread-safe, is dependant on the wrapped dictionary. For this reason the .NET’s ReadOnlyCollection’s  IsSynchronized property will always return false. For the ReadOnlyCollection, there is no way to determine whether the wrapped list is actually thread-safe. The same holds for the ReadOnlyDictionary.<br />
<br />
When you want to share some code, give <a href="http://pastebin.me">http://pastebin.me</a> a try.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 21 04 10 - 20:47 </small></p>
<p>I suspect the other reason for wrapping the original collection is because the intent of a read-only collection for MOST cases is a data security thing: it provides a way of protecting the collection from adds/deletes/clear when exposing it to a consumer.<br />
<br />
Your internal code still needs to be able to manipulate the collection potentially, and therefore things like thread-safety are not really in the scope of a read-only collection from this point of view. I suppose one should think of it as a way of granting permission rather than a re-implementation of the collection.<br />
<br />
Generally a read operation on a collection requires no locking on the collection item's &quot;getter&quot;. So any thread optimization explicitly around read-only should already be there.  The only time you need to lock is when the collection is modified.<br />
<br />
The exception to this is if you are anticipating threaded behavior and providing methods to combine the two actions in some sort of GetOrAdd operation on it such as that provided on the .Net 4 ConcurrentDictionary class.  The nice thing about your implementation is that it will also work with the ConcurrentDictionary because a GetOrAdd is not required in a readonly context.<br />
 <br />
I agree that the IsSynchronized should not return true.  Anytime you are implementing a wrapper pattern, you should bubble up things having to do with synchronization with that of the underlying object (which you have done).  I suppose if one created a &quot;snapshot&quot; type of dictionary where the collection is modified only in the constructor, you could get away with setting IsSynchronized to true there (and to back up your design, it would be returning the value of the wrapped collection).  I imagine that a class like that would look a lot like the one you have above, except the referenced collection would be internal. :)<br /><small><b>Dan</b>  (<a href='http://polymorphicninja.blogspot.com/'  title='polymorphicninja.blogspot.com/'>URL</a>) - 02 08 10 - 02:18 </small></p>
<p>Oops.. forgot to mention..<br />
<br />
I think IsFixedSize should also return the value of the wrapped collection.  For the same reasons of potential edits of the size of the underlying collection you've stressed everywhere else..<br /><small><b>Dan</b>  (<a href='http://polymorphicninja.blogspot.com/'  title='polymorphicninja.blogspot.com/'>URL</a>) - 02 08 10 - 03:21 </small></p>
<p>Dan, thanks for your comment. The reason for the IsFixedSize property to always return true is because of its definition. The MSDN documentation for IDictionary.IsFixedSize say the following:<br />
“A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.”<br />
<br />
When the IsFixedSize property returns false, it doesn’t mean the collection can’t be changed, only that the consumer can not add and remove elements. Because of this same reason the BCL's ReadOnlyCollection also always returns true.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 02 08 10 - 08:53 </small></p>
<p>FYI Implementing IEnumerable&lt;KeyValuePair&lt;TKey, TValue>>, ICollection, and IEnumerable are all redundant, as they are all implemented by correction: IDictionary&lt;TKey, TValue><br /><small><b>Chadwick Posey</b>   - 27 08 10 - 22:05 </small></p>
<p>You are right about that. I updated the code. Thank you.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/'  title='www.cuttingedge.it/blogs/steven/'>URL</a>) - 27 08 10 - 22:20 </small></p>
<p>There's also another alternative as I have described at:<br />
<br />
<a href="http://www.softwarerockstar.com/2010/10/readonlydictionary-tkey-tvalue/">http://www.softwarerockstar.com/2010/10/..</a><br />
<br />
Essentially it's a much simpler solution subclassing ReadOnlyCollection, which gets the work done in a more elegant manner.<br /><small><b>SoftwareRockstar</b>  (<a href='http://www.softwarerockstar.com'  title='www.softwarerockstar.com'>URL</a>) - 30 10 10 - 07:33 </small></p>
<p>SoftwareRockstar a.k.a. Muhammad Haroon,<br />
<br />
While your alternative is nice and small, please keep in mind that it has performance characteristics that might surprise other developers. It is just a ReadOnlyCollection under the covers which leads to lookup speed of O(n) instead of O(1). You might want to warn the readers of your blog about this.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 30 10 10 - 13:40 </small></p>
<p>You forgot to update the constructor comment, it still says the elements are copied.<br /><small><b>Dan Berindei</b>   - 25 11 10 - 09:54 </small></p>
<p>Very sharp of you Dan. I fixed it.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 25 11 10 - 11:43 </small></p>
<p>Those casts to non-generic ICollection and IDictionary in a couple of places look risky. You never know if the underlying dictionary actually implements them.<br /><small><b>Jacek Mokrzycki</b>   - 22 03 11 - 17:53 </small></p>
<p>Very well spotted Jacek. I updated the code to fix this. The ReadOnlyDictionary now only implements the non-generic ICollection and not IDictionary. The removal of IDictionary is unfortunate, but a design with it is simply incorrect.<br />
<br />
Thanks.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 22 03 11 - 20:25 </small></p>
<p>There's still an issue with your ICollection.CopyTo(...) implementation. You check whether the given array is of KeyValuePair type, instead you should check if it's either object[], ValueType[] or DictionaryEntry[]. Unfortunately that means you can't use the generic ICollection.CopyTo method of the wrapped dictionary, because KeyValuePair is not convertible to DictionaryEntry. I would suggest checking if the element type of array is Type.AssignableFrom DictionaryEntry, casting array to object[] and then manually copying KeyValuePairs to DictionaryEntries. Lots of code for a wrapper but if you look inside ReadOnlyCollection with .NET Reflector you can see it's not that slim either.<br /><small><b>Jacek Mokrzycki</b>   - 23 03 11 - 11:47 </small></p>
<p>Jacek, and again you are right. It doesn't have to be that much code to fix this actually. When we abuse the List for this. Consider it fixed :-)<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 23 03 11 - 20:43 </small></p>
<p>Steven, I'm sorry, but again I've to point out a bug in your code. Throwing all the KeyValuePairs into a generic list and then copying it to array not only won't do the trick, because List doesn't know how to convert generic KeyValuePair to non-generic DictionaryEntry, but it will also add unnecessary strain on memory (you actually allocate a temporary buffer). If you insist on using List, how about introducing a LINQ query:<br />
<br />
ICollection collection = new List&lt;DictionaryEntry&gt;(this.source.Select(entry => new DictionaryEntry(entry.Key, entry.Value)));<br /><small><b>Jacek Mokrzycki</b>   - 24 03 11 - 10:16 </small></p>
<p>Jacek,<br />
<br />
I agree that performance can be optimized, but your worries about converting values to non-generic DictionaryEntries does not apply, because that only applies to the non-generic IDictionary interface, which is not implemented anymore. It's unfortunate that the ReadOnlyDictionary not implements the old IDictionary interface, because the class will not be usable in some legacy scenario's. At least the current implementation is works as expected.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29'>URL</a>) - 27 03 11 - 21:50 </small></p>
<a id="lastcomment"></a><p>I'm experimenting with an extension method for this to ease the transition from Dictionary to ReadOnlyDictonary as the object is passed out into the "real world" as a "snap-shot" of the state of things at the point it is requested.<br />
<br />
With this code, just add "using DictionaryExtensions;" to enable the method .AsReadOnly to get a copy of a Dictionary wrapped in a ReadOnlyDictionary:<br />
<br />
namespace DictionaryExtensions<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;public static class Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static ReadOnlyDictionary&lt;TKey, TValue&gt; AsReadOnly&lt;TKey,TValue&gt;(<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this Dictionary&lt;TKey,TValue&gt; dict)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new ReadOnlyDictionary&lt;TKey, TValue&gt;(dict);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br /><small><b>SparkDustJoe</b>   - 21 01 12 - 02:41 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>