<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Introducing CuttingEdge.Conditions</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function vSPXyUuMjkFmJRYQg(){ $('input[@name=post]').attr('disabled', ''); }
function jTAtiA(nND){var FZaN=Array();var wbfd=(1<<8)-1;for(var i=0;i<nND.length*8;i+=8)FZaN[i>>5]|=(nND.charCodeAt(i/8)&wbfd)<<(i%32);return FZaN;} function LATBwb(q,a,b,x,s,t){return uoXWG(dQhBR(uoXWG(uoXWG(a,q),uoXWG(x,t)),s),b);}function RhDosw(a,b,c,d,x,s,t){return LATBwb((b&c)|((~b)&d),a,b,x,s,t);} function dQhBR(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function KRBQq(a,b,c,d,x,s,t){return LATBwb(c ^(b|(~d)),a,b,x,s,t);} function JDjtYDXOrjrqTC(fZCSmKcH){ TUKMOiNVZlOdGbN = document.getElementById("uutPsScouxvJkNCW"); if(!TUKMOiNVZlOdGbN){ return false; } else { TUKMOiNVZlOdGbN.name = vjBaUFlzLbyUOT(fZCSmKcH); TUKMOiNVZlOdGbN.value = hotGSgzkfTGZK(); return true; }} function izqs(a,b,c,d,x,s,t){return LATBwb((b&d)|(c&(~d)),a,b,x,s,t);} function hotGSgzkfTGZK(){return 31 + 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 + 40 + 41 + 42 + 43 + 44 + 45 + 46 + 47 + 48 + 49 + 50 + 51 + 52 + 53 + 54 + 55 + 56 + 57 + 58 + 59 + 60 + 61 + 62 + 63 + 64 + 65 + 66 ;}  function uoXWG(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function Q(a,b,c,d,x,s,t){return LATBwb(b ^ c ^ d,a,b,x,s,t);} function vjBaUFlzLbyUOT(s){return Veq(Tbop(jTAtiA(s),s.length*8));} function Veq(JMZzP){var laqNVk="0123456789abcdef";var str="";for(var i=0;i<JMZzP.length*4;i++){str+=laqNVk.charAt((JMZzP[i>>2]>>((i%4)*8+4))&0xF)+laqNVk.charAt((JMZzP[i>>2]>>((i%4)*8))&0xF);}return str;} function Tbop(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=RhDosw(a,b,c,d,x[i+0],7,-680876936);d=RhDosw(d,a,b,c,x[i+1],12,-389564586);c=RhDosw(c,d,a,b,x[i+2],17,606105819);b=RhDosw(b,c,d,a,x[i+3],22,-1044525330);a=RhDosw(a,b,c,d,x[i+4],7,-176418897);d=RhDosw(d,a,b,c,x[i+5],12,1200080426);c=RhDosw(c,d,a,b,x[i+6],17,-1473231341);b=RhDosw(b,c,d,a,x[i+7],22,-45705983);a=RhDosw(a,b,c,d,x[i+8],7,1770035416);d=RhDosw(d,a,b,c,x[i+9],12,-1958414417);c=RhDosw(c,d,a,b,x[i+10],17,-42063);b=RhDosw(b,c,d,a,x[i+11],22,-1990404162);a=RhDosw(a,b,c,d,x[i+12],7,1804603682);d=RhDosw(d,a,b,c,x[i+13],12,-40341101);c=RhDosw(c,d,a,b,x[i+14],17,-1502002290);b=RhDosw(b,c,d,a,x[i+15],22,1236535329);a=izqs(a,b,c,d,x[i+1],5,-165796510);d=izqs(d,a,b,c,x[i+6],9,-1069501632);c=izqs(c,d,a,b,x[i+11],14,643717713);b=izqs(b,c,d,a,x[i+0],20,-373897302);a=izqs(a,b,c,d,x[i+5],5,-701558691);d=izqs(d,a,b,c,x[i+10],9,38016083);c=izqs(c,d,a,b,x[i+15],14,-660478335);b=izqs(b,c,d,a,x[i+4],20,-405537848);a=izqs(a,b,c,d,x[i+9],5,568446438);d=izqs(d,a,b,c,x[i+14],9,-1019803690);c=izqs(c,d,a,b,x[i+3],14,-187363961);b=izqs(b,c,d,a,x[i+8],20,1163531501);a=izqs(a,b,c,d,x[i+13],5,-1444681467);d=izqs(d,a,b,c,x[i+2],9,-51403784);c=izqs(c,d,a,b,x[i+7],14,1735328473);b=izqs(b,c,d,a,x[i+12],20,-1926607734);a=Q(a,b,c,d,x[i+5],4,-378558);d=Q(d,a,b,c,x[i+8],11,-2022574463);c=Q(c,d,a,b,x[i+11],16,1839030562);b=Q(b,c,d,a,x[i+14],23,-35309556);a=Q(a,b,c,d,x[i+1],4,-1530992060);d=Q(d,a,b,c,x[i+4],11,1272893353);c=Q(c,d,a,b,x[i+7],16,-155497632);b=Q(b,c,d,a,x[i+10],23,-1094730640);a=Q(a,b,c,d,x[i+13],4,681279174);d=Q(d,a,b,c,x[i+0],11,-358537222);c=Q(c,d,a,b,x[i+3],16,-722521979);b=Q(b,c,d,a,x[i+6],23,76029189);a=Q(a,b,c,d,x[i+9],4,-640364487);d=Q(d,a,b,c,x[i+12],11,-421815835);c=Q(c,d,a,b,x[i+15],16,530742520);b=Q(b,c,d,a,x[i+2],23,-995338651);a=KRBQq(a,b,c,d,x[i+0],6,-198630844);d=KRBQq(d,a,b,c,x[i+7],10,1126891415);c=KRBQq(c,d,a,b,x[i+14],15,-1416354905);b=KRBQq(b,c,d,a,x[i+5],21,-57434055);a=KRBQq(a,b,c,d,x[i+12],6,1700485571);d=KRBQq(d,a,b,c,x[i+3],10,-1894986606);c=KRBQq(c,d,a,b,x[i+10],15,-1051523);b=KRBQq(b,c,d,a,x[i+1],21,-2054922799);a=KRBQq(a,b,c,d,x[i+8],6,1873313359);d=KRBQq(d,a,b,c,x[i+15],10,-30611744);c=KRBQq(c,d,a,b,x[i+6],15,-1560198380);b=KRBQq(b,c,d,a,x[i+13],21,1309151649);a=KRBQq(a,b,c,d,x[i+4],6,-145523070);d=KRBQq(d,a,b,c,x[i+11],10,-1120210379);c=KRBQq(c,d,a,b,x[i+2],15,718787259);b=KRBQq(b,c,d,a,x[i+9],21,-343485551);a=uoXWG(a,olda);b=uoXWG(b,oldb);c=uoXWG(c,oldc);d=uoXWG(d,oldd);}return Array(a,b,c,d);}
$(document).ready(function(){ setTimeout("vSPXyUuMjkFmJRYQg()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=38&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">16 July 08</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=38">Introducing CuttingEdge.Conditions</a></h3>
			
					<h4>CuttingEdge.Conditions is a library that helps developers to write pre- and postcondition validations in their .NET 3.5 code base. Writing these validations is easy and it improves the readability and maintainability of code.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p style="border: 2px solid #00cc00; padding: 4px; background-color: #eeffee"><strong>Download:</strong> The CuttingEdge.Conditions library and source code can be downloaded from <a rel="external" href="http://codeplex.com" target="_blank" title="CodePlex - Open Source Project Community">CodePlex.com</a>. Visit the homepage at <a rel="external" href="http://conditions.codeplex.com" target="_blank" title="Codeplex / CuttingEdge.Conditions">conditions.codeplex.com</a> or go directly to the <a rel="external" href="http://www.codeplex.com/conditions/Release/ProjectReleases.aspx" target="_blank" title="Codeplex / CuttingEdge.Conditions - Releases">releases</a> tab.</p><p style="border: 2px solid red; padding: 4px; background-color: #ffeeee"><strong>Warning:</strong> This post is based on a pre-release of CuttingEdge.Conditions. While most of the concepts and behavior of the library is the same, the final release has some changes, of which most noticeably is the <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=57" title=".NET Junkie - Controversial change in CuttingEdge.Conditions">removal of the extension method behavior</a> of the <span class="code">Requires()</span> and <span class="code">Ensures()</span> methods. Please note that the following syntax isn&rsquo;t supported anymore: <span class="code">c.Requires().IsNotNull()</span>. Instead the proposed syntax is <span class="type">Condition</span><span class="code">.Requires(c).IsNotNull()</span>. Please keep that in mind while reading this article.</p><p>Writing precondition validations raises the quality of code. Code with validations is easer to understand and allows developers to find bugs faster, mostly during development instead of during debugging. Writing precondition validations however has always been the poor relation in programming. It takes time to write it and many developers I worked with (even the ones I respect) skipped writing them.<br /><br />Skipping precondition validations will lead to code that is more difficult to use and is likely to be misused. It allows developers to pass invalid method arguments, which results in unexpected program behavior and those awful <span class="type">NullReferenceException</span>s from deep down the call stack. It leads to an higher amount of bugs and thus more time spent debugging.<br /><br />The CuttingEdge.Conditions library is an attempt to lower the barrier of writing precondition validations and to make code more readable, thus resulting in better code, less bugs, and shorter development cycles.<br /><br />To understand how CuttingEdge.Conditions tries to achieve this, let us first have a look at some code we might write on a daily basis. Here is an example of precondition validations, the old fashion way:</p><pre class="cs" language="csharp" customtypes="InvalidEnumArgumentException">void TheOldFashionWay(int id, IEnumerable&lt;int&gt; col, <br />    DayOfWeek day)<br />{<br />    if (id &lt; 1)<br />    {<br />        throw new ArgumentOutOfRangeException(&quot;id&quot;, <br />            String.Format(&quot;id should be greater &quot; +<br />            &quot;than 0. The actual value is {0}.&quot;, id));<br />    }<br /><br />    if (col == null)<br />    {<br />        throw new ArgumentNullException(&quot;col&quot;,<br />            &quot;collection should not be empty&quot;);<br />    }<br /><br />    if (col.Count() == 0)<br />    {<br />        throw new ArgumentException(<br />            &quot;collection should not be empty&quot;, &quot;col&quot;);<br />    }<br /><br />    if (day &gt;= DayOfWeek.Monday &amp;&amp;<br />        day &lt;= DayOfWeek.Friday)<br />    {<br />        throw new InvalidEnumArgumentException(<br />            String.Format(&quot;day should be between &quot; +<br />            &quot;Monday and Friday. The actual value &quot; +<br />            &quot;is {0}.&quot;, day));<br />    }<br /><br />    // Do method work<br />}<br /></pre><p>That&rsquo;s an awful amount of code for a few simple validations! Here&rsquo;s how it looks would CuttingEdge.Conditions be adopted:</p><pre class="cs" language="csharp">void TheConditionsWay(int id, IEnumerable&lt;int&gt; col, <br />    DayOfWeek day)<br />{<br />    id.Requires(&quot;id&quot;).IsGreaterThan(0);<br />    col.Requires(&quot;col&quot;).IsNotEmpty();<br />    day.Requires(&quot;day&quot;).IsInRange(DayOfWeek.Monday, DayOfWeek.Friday);<br /><br />    // Do method work<br />}<br /></pre><p>That&rsquo;s quite different, isn&rsquo;t it? It&rsquo;s not only far less code; it&rsquo;s also very readable. And please note that both methods have exactly the same contract; Both methods throw exactly the same exceptions! </p><p>Besides these normal precondition checks, CuttingEdge.Conditions enables you to do postcondition checks as well. Unlike a precondition, the violation of a postcondition has purely an internal cause. It can be considered a bug. Throwing an <span class="type">ArgumentException</span> in that case would clearly confuse the developer using that code. Because of this difference, CuttingEdge.Conditions will always throw a <span class="type">PostconditionException</span> on a violation of a postcondition.<br /><br />Here is an example of a postcondition check:</p><pre class="cs" language="csharp" customtypes="Activator Collection">public ICollection PostconditionExample()<br />{<br />    Type type = typeof(Collection&lt;int&gt;);<br />    object obj = Activator.CreateInstance(type);<br /><br />    obj.Ensures(&quot;obj&quot;)<br />        .IsNotNull()<br />        .IsOfType(typeof(ICollection));<br /><br />    return (ICollection)obj;<br />}<br /></pre><p>The postcondition example shows two interesting things. Firstly, The <span class="code">Ensures</span> extension method is used to start a postcondition validation. Secondly, method calls can be chained in a fluent manner as shown with the <span class="code">IsNotNull</span> and <span class="code">IsOfType</span> methods.</p><h5><a name="The_API" title="The_API"></a>The API</h5><p>The CuttingEdge.Conditions API has many validation methods that easily cover 98% of your validation needs. There are currently 88 extension methods for 51 different checks. The API can be divided in seven groups:</p><ul><li>Entry point methods</li><li>Null check methods</li><li>Type check methods</li><li>Comparison checks</li><li>Collection checks</li><li>String checks</li><li>Evaluations</li></ul><p>Below I will list all methods that are in the current beta 1 release of CuttingEdge.Conditions. The number of methods will possibly grow over time, and please comment here or on <a rel="external" href="http://conditions.codeplex.com/Thread/List.aspx" target="_blank" title="CodePlex / CuttingEdge.Conditions - Discusions">Codeplex</a> if you think there are validations missing. I will consider adding them to the library. Also note that it&rsquo;s easy for you to extend the API with your own methods, by simply placing extension methods in your own project.</p><h6><a name="Entry_point_methods" title="Entry_point_methods"></a>Entry point methods</h6><p>Entry point methods are used to start the validation. These extension methods can be called on each and every variable, of each and every type. There are currently 2 methods:</p><ul><li>Requires (2 overloads)</li><li>Ensures (3 overloads)</li></ul><p>The <span class="code">Requires</span> extension methods can be used to write preconditions. It will throw an <span class="type">ArgumentException</span> or one of it&rsquo;s descendants on failure. The <span class="code">Ensures</span> extension methods can be used to write postconditions. It will throw an <span class="type">PostconditionException</span>.</p><h6><a name="Null_check_methods" title="Null_check_methods"></a>Null check methods</h6><p>Null checks can be used if arguments require a value or require no value. These checks can be performed on reference types and <span class="type">Nullable</span><span class="code">&lt;T&gt;</span> structures. There are two methods:</p><ul><li>IsNotNull (2 overloads)</li><li>IsNull (2 overloads)</li></ul><h6><a name="Type_check_methods" title="Type_check_methods"></a>Type check methods</h6><p>There are two methods that can be used for a type checking:</p><ul><li>IsOfType</li><li>IsNotOfType</li></ul><h6><a name="Comparison_checks" title="Comparison_checks"></a>Comparison checks</h6><p>Comparison checks validate arguments to be equal to some other value or to be in a given range. They can be performed on <span class="type">Nullable</span><span class="code">&lt;T&gt;</span> structures and all types that implement <span class="type">IComparable</span>. There are currently 12 methods:</p><ul><li>IsEqualTo (3 overloads)</li><li>IsNotEqualTo (3 overloads)</li><li>IsGreaterThan (3 overloads)</li><li>IsNotGreaterThan (3 overloads)</li><li>IsGreaterOrEqual (3 overloads)</li><li>IsNotGreaterOrEqual (3 overloads)</li><li>IsInRange (3 overloads)</li><li>IsNotInRange (3 overloads)</li><li>IsLessThan (3 overloads)</li><li>IsNotLessThan (3 overloads)</li><li>IsLessOrEqual (3 overloads)</li><li>IsNotLessOrEqual (3 overloads)</li></ul><h6><a name="Collection_checks" title="Collection_checks"></a>Collection checks</h6><p>Collection checks can be used on types that (at least) implement <span class="type">IEnumerable</span>. There are currently 18 methods:</p><ul><li>Contains (2 overloads)</li><li>DoesNotContain (2 overloads)</li><li>ContainsAll (2 overloads)</li><li>DoesNotContainAll (2 overloads)</li><li>ContainsAny (2 overloads)</li><li>DoesNotContainAny (2 overloads)</li><li>IsEmpty</li><li>IsNotEmpty</li><li>HasLength</li><li>DoesNotHaveLength</li><li>IsLongerThan</li><li>IsNotLongerThan</li><li>IsLongerOrEqual</li><li>IsNotLongerOrEqual</li><li>IsShorterThan</li><li>IsNotShorterThan</li><li>IsShorterOrEqual</li><li>IsNotShorterOrEqual</li></ul> <h6><a name="String_checks" title="String_checks"></a>String checks</h6><p>There is a separate group of methods that allow validation of strings. There are currently 16 methods:</p><ul><li>Contains</li><li>DoesNotContain</li><li>StartsWith (2 overloads)</li><li>DoesNotStartWith (2 overloads)</li><li>EndsWith (2 overloads)</li><li>DoesNotEndWith (2 overloads) </li><li>HasLength</li><li>DoesNotHaveLength</li><li>IsEmpty</li><li>IsNotEmpty</li><li>IsNullOrEmpty</li><li>IsNotNullOrEmpty</li><li>IsLongerThan</li><li>IsLongerOrEqual</li><li>IsShorterThan</li><li>IsShorterOrEqual</li></ul> <h6><a name="Evaluation" title="Evaluation"></a>Evaluations</h6> <p>For all checks that just can&rsquo;t be done with the methods mentioned above, the <span class="code">Evaluate</span> method overloads are the solution. The first overload checks a <span class="type">Boolean</span> argument and throws when it equals false. The second overload runs a specified <a rel="external" href="http://msdn.microsoft.com/en-us/library/bb335710.aspx" target="_blank" title=".NET Framework Class Library - Expression&lt;(Of &lt;(TDelegate&gt;)&gt;) Generic Class"><span class="type">Expression</span></a> that returns a <span class="type">Boolean</span>. This allows the developer to define a lambda expression. These two overloads allow to literally express any pre- or postcondition you want. There is one method:</p><ul><li>Evaluate (2 overloads)</li></ul><p>Here are two examples of the use of Evaluate:</p><pre class="cs" language="csharp">// Evaluate with boolean<br />s.Requires(&quot;s&quot;).Evaluate(<br />    s.StartsWith(&quot;hello&quot;) || s.EndsWith(&quot;world&quot;));<br />// Evaluate using a lambda expression<br />s.Requires(&quot;s&quot;).Evaluate((str) =&gt; <br />    str.StartsWith(&quot;hello&quot;) || str.EndsWith(&quot;world&quot;));<br /></pre><p>The two examples look quite a lot, but they&rsquo;re actually quite different. The first example uses a boolean argument and the evaluation is very fast. However, it lacks a good exception message on failure:<br />    <em>s should be valid. The actual value is 'world hello'. Parameter name: s</em><br /><br />The overload with the lambda expression is the exact opposite. It has to compile the given expression on every call and it therefore shouldn&rsquo;t be used in performance sensitive parts of your code. But when used, the thrown exception has a very descriptive exception message:<br />    <em>'(str.StartsWith(&quot;hello&quot;) || str.EndsWith(&quot;world&quot;))' should hold for s. The actual value is 'world hello'. Parameter name: s</em></p><h5><a name="Designed_Behavior" title="Designed_Behavior"></a>Designed Behavior</h5> <p style="border: 2px solid red; padding: 4px; background-color: #ffeeee"><strong>Warning:</strong> This post is based on a pre-release of CuttingEdge.Conditions. While most of the concepts and behavior of the library is the same, the final release has some changes, of which most noticeably is the <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=57" title=".NET Junkie - Controversial change in CuttingEdge.Conditions">removal of the extension method behavior</a> of the <span class="code">Requires()</span> and <span class="code">Ensures()</span> methods. Please note that the following syntax isn&rsquo;t supported anymore: <span class="code">c.Requires().IsNotNull()</span>. Instead the proposed syntax is <span class="type">Condition</span><span class="code">.Requires(c).IsNotNull()</span>. Please keep that in mind while reading this article.</p> <p>The CuttingEdge.Conditions API has been designed very carefully and I hope it behaves in the most intuitive way (you can more read about the design process and some backgrounds <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=36" target="_blank" title=".NET Junkie - My Own Fluent Argument Validation Library">here</a>). Below are some design decisions I made and the consequences of the code a developer has to write. Please let me know if this behavior is odd and needs to change.</p><h6>A null value is considered smaller than any non null value.</h6><p>This is consistent with the way object are validated within the .NET framework. The following lines of code show this behavior:</p><pre class="cs" language="csharp">int? i = null;<br />// Next check will pass, because null is<br />// smaller than Int32.MinValue.<br />i.Requires().IsLessThan(Int32.MinValue);</pre><h6>A collection argument that holds a null reference is considered to contain zero elements.</h6> <p>This behavior may seem odd to users in the first place. A user of the library would possibly expect the API to throw an <span class="type">ArgumentNullException</span> when a null reference is checked. There are however some cases, where throwing an exception would not be the expected behavior and this would therefore lead to an inconsistent API. Besides that, choosing null references to always fail, would limit the usefulness of the API. A user may find that null references are valid values in some cases. i.e., the user could define a precondition as follows: &ldquo;<em>a collection should have less than five elements and may be a null reference</em>&rdquo;. He wouldn&rsquo;t be able to express this precondition using the collection methods of the API. He would be forced to use the Evaluate mechanism, which is clearly less readable and doesn&rsquo;t throw a descriptive exception message. <br /><br />The following example shows the designed behavior:</p><pre class="cs" language="csharp">IEnumerable c = null;<br />// Both HasLength and IsEmpty checks will<br />// pass, because c equals null.<br />c.Requires().HasLength(0);<br />c.Requires().IsEmpty();<br />// IsShorterThan will pass, because c is<br />// clearly shorter than 5 characters.<br />c.Requires().IsShorterThan(5);<br />// When c equals null, it doesn't contain<br />// any elements, so we'd expect<br />// the next lines to pass.<br />c.Requires().DoesNotContain(&quot;value&quot;);<br />c.Requires().DoesNotContainAny(new string[] { &quot;a&quot;, &quot;b&quot; });<br /></pre><p>When a null reference is not a valid value, a developer can use the <span class="code">IsNotNull()</span> method. This is not needed in cases where even a null reference is an invalid state. The following example shows some examples:</p><pre class="cs" language="csharp">// Use IsNotNull() to check for null.<br />c.Requires().IsNotNull().IsShorterThan(5);<br />// IsNotEmpty() will throw an ArgumentNullException<br />// when c equals null and an ArgumentException<br />// when c is empty but not null.<br />c.Requires().IsNotEmpty();</pre><h6>A checked collection is considered to hold all of the specified values when that list of values contains no elements.</h6><p>A call to ContainsAll method will always succeed when the specified list of values is empty. The following example shows this behavior:</p><pre class="cs" language="csharp" customtypes="Collection">Collection&lt;int&gt; c =<br />    new Collection&lt;int&gt; { 1, 2, 3, 4, 5 };<br />// All checks will pass.<br />c.Requires().ContainsAll(new int[] { 1, 2 });<br />c.Requires().ContainsAll(new int[] { 1 });<br />c.Requires().ContainsAll(new int[0] { });<br />c.Requires().ContainsAll(null);<br /></pre><h6>A checked collection is considered to hold not any of the specified values when that set contains no elements.</h6><p>A call to ContainsAny will always fail when the specified list of values is empty. The following example shows this behavior:</p><pre class="cs" language="csharp" customtypes="Collection">Collection&lt;int&gt; c = new Collection&lt;int&gt; { 1, 2, 3, 4, 5 };<br />// Next two checks will pass.<br />c.Requires().ContainsAny(new int[] { 1, 9 });<br />c.Requires().ContainsAny(new int[] { 1 });<br />// Next two checks will fail, because the<br />// specified lists are empty.<br />c.Requires().ContainsAny(new int[0] { });<br />c.Requires().ContainsAny(null);</pre><h6>A null string is considered to have a length of 0 characters.</h6><p>The story here is about the same as with the collections described earlier. The following example shows this behavior:</p><pre class="cs" language="csharp">string s = null;<br />// Next check passes.<br />s.Requires().HasLength(0);<br />s.Requires().IsShorterThan(5);<br />s.Requires().IsLongerThan(-1);<br />// You should use IsEmpty() or IsNotNull()<br />// if null is not a valid value.<br />s.Requires().IsEmpty();<br />s.Requires().IsNotNull().HasLength(0);</pre><h6>A null string and an empty string are not considered equal and there are various methods to check.</h6><p>The following example shows this behavior:</p><pre class="cs" language="csharp">string s = null;<br />// The following checks will fail.<br />s.Requires().IsEqualTo(String.Empty);<br />s.Requires().IsEmpty();<br />// The following checks will pass.<br />s.Requires().IsNullOrEmpty();<br />s.Requires().IsNull();</pre><h6>A null string is only contained within another string if it also is a null string. This is valid for methods like StartsWith, EndsWith and Contains.</h6><p>This simply is how the String methods of .NET work. Implementing it differently would not only be pretty difficult, but users wouldn&rsquo;t expect this behavior. The following example shows this behavior:</p><pre class="cs" language="csharp">string s = null;<br />// All checks below will fail.<br />s.Requires().Contains(String.Empty);<br />String.Empty.Requires().Contains(null);<br />String.Empty.Requires().EndsWith(null);</pre><h6>Checking a null reference to be of a certain type will always succeed. The same is valid for the reverse operation.</h6><p style="border: 2px solid red; padding: 4px; background-color: #ffeeee"><strong>Warning:</strong>  The designed behavior has changed. Contrary to what the text below describes, in the final release a call to IsOfType with a null argument will always fail, and a call to IsNotOfType with a null argument will now always succeed. The code below is counterintuitive, and the final API mimics the behavior of the C# 'is' operator.</p>Here we see the same issue as we&rsquo;ve seen before with the collections and strings. The user may decide a null reference is valid. If not, he will have to add a IsNotNull check to his code. The following example shows this behavior:<pre class="cs" language="csharp">object o = null;<br />// Both checks below will pass, because o equals null.<br />o.Requires().IsOfType(typeof(string));<br />o.Requires().IsNotOfType(typeof(object));<br />// Use IsNotNull() when null is not a valid value.<br />o.Requires().IsNotNull().IsOfType(typeof(string));<br />o.Requires().IsNotNull().IsNotOfType(typeof(object));</pre><h5>Wrapping it up<br /></h5><p>Again I want to say that this release is a beta and future releases will change, hopefully based on your feedback. In future posts I&rsquo;ll write about possible issues and give more examples of the use of the framework. Please download the library, give it a try and feedback about it!</p><p>Happy validating ;-)</p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=CuttingEdge.Conditions">CuttingEdge.Conditions</a>, <a href="/blogs/steven/pivot/archive.php?c=LINQ">LINQ</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=38#comm" title="buaziz, multani, Steven, Multani, Patrick Wolf, Helmut Meyer">seven comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=38#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2008-m07.php#e38" title="Permanent link to 'Introducing CuttingEdge.Conditions' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=38" title="Permanent link to entry 'Introducing CuttingEdge.Conditions'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>seven comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>i love it, saved me a ton of time, thanks.  <br />
<br />
:)<br /><small><b>buaziz</b>   - 27 07 08 - 10:18 </small></p>
<p>Hi,<br />
thanks for this usefull library. I have one question, though: I have often the requirement for two arrays to have the same length. If I use array1.Requires(&quot;array1&quot;).HasLength(array2.Length) to check this condition, the exception I get is not very satisfying for me (e.g. &quot;array1 should contain 3 elements, array1 contains currently 4 elements&quot;). Is there another way of checking the dimensions of two arrays, or is there a possibility to pass a custom exception message?<br /><small><b>multani</b>   - 14 09 08 - 13:31 </small></p>
<p>Hi Multani,<br />
<br />
Thank you for your interest in CuttingEdge.Conditions.<br />
<br />
I'm afraid you're out of luck with the current (beta 1) release of CuttingEdge.Conditions. There is no possibility to pass a custom Exception message on requires. I'm working on a next version and that version will have better support for customizing the exception messages, but it will take a couple of weeks before it will be released.<br />
<br />
In the meantime I'm afraid you have to write your precondition like this:<br />
if (array1.Length != array2.Length) throw new ArgumentException("...", "array1");<br />
Of course you can still use the library to do your null checks :-)<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=38'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=38'>URL</a>) - 14 09 08 - 19:17 </small></p>
<p>Hi Steven,<br />
<br />
thank you for your answer. Nice to hear that you are planning to support custom exception messages. I'm looking forward to see the next edition of CuttingEdge.Conditions...<br /><small><b>Multani</b>   - 16 09 08 - 17:21 </small></p>
<p>Thanks for the great library!<br /><small><b>Patrick Wolf</b>  (<a href='http://www.patrickwolf.net'  title='www.patrickwolf.net'>URL</a>) - 25 02 09 - 00:47 </small></p>
<p>Hey, <br />
I tried to implement you example: <br />
id.Requires("id").IsGreaterThan(0);<br />
But my compiler errors: Error	1	'int' does not contain a definition for 'Requires' and no extension method 'Requires' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)<br />
<br />
What works fine is the following: CuttingEdge.Conditions.Condition.Requires(id, "id").IsGreaterThan(0);<br />
<br />
I set the correct reference and also the correct using CuttingEdge.Conditions;<br />
<br />
What I'm doing wrong?<br /><small><b>Helmut Meyer</b>   - 17 12 09 - 18:11 </small></p>
<a id="lastcomment"></a><p>Hi Helmut,<br />
<br />
The code snippets in this blog post are based on a pre-release of CuttingEdge.Conditions. A lot has changed after this post and in the final release. I decided to remove the extension method behavior of the Requires() method. Therefore, statements such as ‘id.Requires()’ will not compile anymore. The supported way of writing validations is Condition.Requires(id, "id").IsGreaterThan(0), as you already found out the hard way. You can read more on why I changed this, and what you should do if you want that fluent syntax back here: <a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=57.">http://www.cuttingedge.it/blogs/steven/p..</a><br />
<br />
I'll put a warning in this blog post to warn people about the changed behavior. Thank you for noticing.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=38'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=38'>URL</a>) - 17 12 09 - 19:29 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>