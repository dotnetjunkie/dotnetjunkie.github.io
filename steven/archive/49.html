<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 3: The complexity of custom validators.</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function flhYlyxvYtJWNRFL(){ $('input[@name=post]').attr('disabled', ''); }
function ITj(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function qN(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function dOlCK(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=jzllKr(a,b,c,d,x[i+0],7,-680876936);d=jzllKr(d,a,b,c,x[i+1],12,-389564586);c=jzllKr(c,d,a,b,x[i+2],17,606105819);b=jzllKr(b,c,d,a,x[i+3],22,-1044525330);a=jzllKr(a,b,c,d,x[i+4],7,-176418897);d=jzllKr(d,a,b,c,x[i+5],12,1200080426);c=jzllKr(c,d,a,b,x[i+6],17,-1473231341);b=jzllKr(b,c,d,a,x[i+7],22,-45705983);a=jzllKr(a,b,c,d,x[i+8],7,1770035416);d=jzllKr(d,a,b,c,x[i+9],12,-1958414417);c=jzllKr(c,d,a,b,x[i+10],17,-42063);b=jzllKr(b,c,d,a,x[i+11],22,-1990404162);a=jzllKr(a,b,c,d,x[i+12],7,1804603682);d=jzllKr(d,a,b,c,x[i+13],12,-40341101);c=jzllKr(c,d,a,b,x[i+14],17,-1502002290);b=jzllKr(b,c,d,a,x[i+15],22,1236535329);a=smOgT(a,b,c,d,x[i+1],5,-165796510);d=smOgT(d,a,b,c,x[i+6],9,-1069501632);c=smOgT(c,d,a,b,x[i+11],14,643717713);b=smOgT(b,c,d,a,x[i+0],20,-373897302);a=smOgT(a,b,c,d,x[i+5],5,-701558691);d=smOgT(d,a,b,c,x[i+10],9,38016083);c=smOgT(c,d,a,b,x[i+15],14,-660478335);b=smOgT(b,c,d,a,x[i+4],20,-405537848);a=smOgT(a,b,c,d,x[i+9],5,568446438);d=smOgT(d,a,b,c,x[i+14],9,-1019803690);c=smOgT(c,d,a,b,x[i+3],14,-187363961);b=smOgT(b,c,d,a,x[i+8],20,1163531501);a=smOgT(a,b,c,d,x[i+13],5,-1444681467);d=smOgT(d,a,b,c,x[i+2],9,-51403784);c=smOgT(c,d,a,b,x[i+7],14,1735328473);b=smOgT(b,c,d,a,x[i+12],20,-1926607734);a=bArbC(a,b,c,d,x[i+5],4,-378558);d=bArbC(d,a,b,c,x[i+8],11,-2022574463);c=bArbC(c,d,a,b,x[i+11],16,1839030562);b=bArbC(b,c,d,a,x[i+14],23,-35309556);a=bArbC(a,b,c,d,x[i+1],4,-1530992060);d=bArbC(d,a,b,c,x[i+4],11,1272893353);c=bArbC(c,d,a,b,x[i+7],16,-155497632);b=bArbC(b,c,d,a,x[i+10],23,-1094730640);a=bArbC(a,b,c,d,x[i+13],4,681279174);d=bArbC(d,a,b,c,x[i+0],11,-358537222);c=bArbC(c,d,a,b,x[i+3],16,-722521979);b=bArbC(b,c,d,a,x[i+6],23,76029189);a=bArbC(a,b,c,d,x[i+9],4,-640364487);d=bArbC(d,a,b,c,x[i+12],11,-421815835);c=bArbC(c,d,a,b,x[i+15],16,530742520);b=bArbC(b,c,d,a,x[i+2],23,-995338651);a=RSeFP(a,b,c,d,x[i+0],6,-198630844);d=RSeFP(d,a,b,c,x[i+7],10,1126891415);c=RSeFP(c,d,a,b,x[i+14],15,-1416354905);b=RSeFP(b,c,d,a,x[i+5],21,-57434055);a=RSeFP(a,b,c,d,x[i+12],6,1700485571);d=RSeFP(d,a,b,c,x[i+3],10,-1894986606);c=RSeFP(c,d,a,b,x[i+10],15,-1051523);b=RSeFP(b,c,d,a,x[i+1],21,-2054922799);a=RSeFP(a,b,c,d,x[i+8],6,1873313359);d=RSeFP(d,a,b,c,x[i+15],10,-30611744);c=RSeFP(c,d,a,b,x[i+6],15,-1560198380);b=RSeFP(b,c,d,a,x[i+13],21,1309151649);a=RSeFP(a,b,c,d,x[i+4],6,-145523070);d=RSeFP(d,a,b,c,x[i+11],10,-1120210379);c=RSeFP(c,d,a,b,x[i+2],15,718787259);b=RSeFP(b,c,d,a,x[i+9],21,-343485551);a=ITj(a,olda);b=ITj(b,oldb);c=ITj(c,oldc);d=ITj(d,oldd);}return Array(a,b,c,d);} function smOgT(a,b,c,d,x,s,t){return AgHAzP((b&d)|(c&(~d)),a,b,x,s,t);} function avrqPyIKxSXYssnrA(s){return B(dOlCK(thZHXh(s),s.length*8));} function RSeFP(a,b,c,d,x,s,t){return AgHAzP(c ^(b|(~d)),a,b,x,s,t);} function AgHAzP(q,a,b,x,s,t){return ITj(qN(ITj(ITj(a,q),ITj(x,t)),s),b);}function jzllKr(a,b,c,d,x,s,t){return AgHAzP((b&c)|((~b)&d),a,b,x,s,t);} function VtGfuTgN(){return 41 + 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 + 40 + 41 + 42 + 43 + 44 + 45 + 46 + 47 + 48 + 49 + 50 + 51 + 52 + 53 + 54 + 55 + 56 + 57 + 58 + 59 + 60 + 61 + 62 + 63 + 64 + 65 + 66 + 67 + 68 + 69 + 70 + 71 + 72 + 73 + 74 + 75 ;}  function OPZJsWtyDzotwa(TFPrOXJJEAARramTe){ GzxLqVuyKi = document.getElementById("HKTOQaHKQJsETjNpWF"); if(!GzxLqVuyKi){ return false; } else { GzxLqVuyKi.name = avrqPyIKxSXYssnrA(TFPrOXJJEAARramTe); GzxLqVuyKi.value = VtGfuTgN(); return true; }} function thZHXh(AJXvdo){var yAFk=Array();var M=(1<<8)-1;for(var i=0;i<AJXvdo.length*8;i+=8)yAFk[i>>5]|=(AJXvdo.charCodeAt(i/8)&M)<<(i%32);return yAFk;} function B(HzZuE){var RhM="0123456789abcdef";var str="";for(var i=0;i<HzZuE.length*4;i++){str+=RhM.charAt((HzZuE[i>>2]>>((i%4)*8+4))&0xF)+RhM.charAt((HzZuE[i>>2]>>((i%4)*8))&0xF);}return str;} function bArbC(a,b,c,d,x,s,t){return AgHAzP(b ^ c ^ d,a,b,x,s,t);}
$(document).ready(function(){ setTimeout("flhYlyxvYtJWNRFL()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=49&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">28 May 09</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=49">Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 3: The complexity of custom validators.</a></h3>
			
					<h4>This article shows the complexity a developer is facing, implementing a custom validator while using an O/RM tool. While the article uses the Validation Application Block and LINQ to SQL in writing the validation logic, the problems encountered in the article are very general.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p>In previous posts (<a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=46" title=".NET Junkie - Integrating Enterprise Library Validation Application Block With LINQ to SQL and Entity Framework Part 1: Basic Integration">here</a> and <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=47" title=".NET Junkie - Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 2: Using context within custom validators.">here</a>), I&rsquo;ve shown how to integrate the <a rel="external" href="http://msdn.microsoft.com/en-us/library/dd140088.aspx" title="Enterprise Library 4.1 - October 2008 The Validation Application Block">Enterprise Library Validation Application Block</a> (VAB) in <a rel="external" href="http://weblogs.asp.net/scottgu/archive/2007/05/19/using-linq-to-sql-part-1.aspx" title="ScottGu's Blog - Using LINQ to SQL (Part 1) ">LINQ to SQL</a> and <a rel="external" href="http://msdn.microsoft.com/en-us/library/aa697427(VS.80).aspx" title="MSDN - The ADO.NET Entity Framework Overview">Entity Framework</a> projects. I showed how to obtain access to a data context from within custom validators, but I also stated that -in the context of <a rel="external" href="http://en.wikipedia.org/wiki/Object-relational_mapping" title="Wikipedia - Object-relational mapping">O/RM</a> frameworks- custom validators that communicate with the database, tend to get pretty complicated quickly.<br /><br />In this post I will try to prove this statement by defining a simple business rule and trying to create a validator for it. The rule is written in seven iterations. Each of these iteration will have a defect which I will try to solve in the version following it. Per version I will try to improve that validator towards a correct solution. I&rsquo;ll also write some supporting <a rel="external" href="http://en.wikipedia.org/wiki/Integration_testing" title="Wikipedia - Integration testing">integration tests</a> to check it&rsquo;s correctness while doing so.<br /><br />The code in this article is based on the <a rel="external" href="http://www.microsoft.com/downloads/details.aspx?FamilyID=06616212-0356-46A0-8DA2-EEBC53A68034&amp;displaylang=en" title="Microsoft Download Center - Northwind and pubs Sample Databases for SQL Server 2000">Northwind</a> database, and I will use the Customers, Orders and Order_Details tables and their associated entities. I&rsquo;ve shown code that works with both LINQ to SQL and Entity Framework in my previous posts, but the code in this post is based on LINQ to SQL only. While the discussed concepts remain the same, Entity Framework has different <a rel="external" href="http://social.msdn.microsoft.com/forums/en-US/adodotnetentityframework/thread/095745fe-dcf0-4142-b684-b7e4a1ab59f0/" title="Microsoft Developer Network &gt; Forums Home &gt; Data Platform Development Forums &gt; ADO.NET Entity Framework and LINQ to Entities &gt; WHERE IN clause?">deficiencies</a>. These could bite you, when trying this out with Entity Framework.<br /><br />The validator built here is based on the following (imaginary) business rule named the &lsquo;unshipped orders rule&rsquo;. It&rsquo;s definition is as follows:</p><blockquote>A customer is not allowed, at a given moment in time, to have more than two unshipped orders.</blockquote><h5>Version 1.0<br /></h5><p>Writing a validator for such a simple business rule couldn&rsquo;t that hard, could it? Below is the first definition of the <span class="type">UnshippedOrdersRuleValidator</span> class:</p><pre class="cs" language="csharp" customtypes="ConfigurationElementType CustomValidatorData UnshippedOrdersRuleValidator Validator ValidationResults Customer" customvaluetypes="PutYourCustomValueTypesHere">[ConfigurationElementType(typeof(CustomValidatorData))]<br />public sealed class UnshippedOrdersRuleValidator : Validator<br />{<br />    private const int MaximumNumberOfUnshippedOrders = 2;<br /><br />    private const string RuleViolationMessage = &quot;Customer with &quot; +<br />        &quot;ID {0} has currently {1} unshipped orders, while {2} &quot; +<br />        &quot;is the maximum permitted number of unshipped orders.&quot;;<br /><br />    public CustomerValidator(NameValueCollection attributes)<br />        : base(string.Empty, string.Empty)<br />    {<br />    }<br /><br />    protected override string DefaultMessageTemplate<br />    {<br />        get { throw new NotImplementedException(); }<br />    }<br /><br />    protected override void DoValidate(object objectToValidate, <br />        object currentTarget, string key, ValidationResults results)<br />    {<br />        Customer customer = (Customer)currentTarget;<br /><br />        int totalUnshippedOrders = (<br />            from order in customer.Orders<br />            where order.ShippedDate == null<br />            select order).Count();<br /><br />        if (totalUnshippedOrders &gt; MaximumNumberOfUnshippedOrders)<br />        {<br />            string message = string.Format(RuleViolationMessage,<br />                customer.CustomerID, totalUnshippedOrders,<br />                MaximumNumberOfUnshippedOrders);<br /><br />            this.LogValidationResult(results, message, <br />                currentTarget, key);<br />        }<br />    }<br />}</pre><p>The class inherits from <span class="type">Validator</span>, which is part of the VAB. The implementation has the required plumbing: It&rsquo;s decorated with the <span class="type">ConfigurationElementTypeAttribute</span> and has a constructor with a <span class="type">NameValueCollection</span> argument. These are needed for it to be configurable using VAB. Please note that I&rsquo;m using hard coded strings for simplicity. You&rsquo;d probably want to use resource based strings in production code. I wanted to show a full working implementation, but from now on, the focus will be on the <span class="code">DoValidate</span> method.<br /><br />The code is rather straight forward. When a customer is validated, it is supplied to the <span class="code">DoValidate</span> method as the <span class="code">currentTarget</span> argument. The argument is casted from <span class="keyword">object</span> back to <span class="type">Customer</span> and the customer&rsquo;s orders collection is queried, by searching for orders with no <span class="code">ShippedDate</span>. The total number of unshipped orders is compared to <span class="code">MaximumNumberOfUnshippedOrders</span>. If the total number of unshipped orders for the customer is greater than the defined maximum, the customer is invalid and a validation result is logged using the <span class="code">LogValidationResult</span> method, which is part of the <span class="type">Validator</span> base class. For the sake of simplicity I&rsquo;ve decided to define the value containing the maximum number of unshipped orders as a <span class="keyword">const</span> instead making it configurable.<br /><br />To be complete, here is the VAB configuration used to get this working (I stripped namespaces of the types for readability):</p><pre class="cs" language="csharp" customtypes="PutYourCustomTypesHere" customvaluetypes="PutYourCustomValueTypesHere">  &lt;validation&gt;<br />    &lt;type name=&quot;Customer&quot; defaultRuleset=&quot;Default&quot;<br />      assemblyName=&quot;Domain&quot;&gt;<br />      &lt;ruleset name=&quot;Default&quot;&gt;<br />        &lt;validator type=&quot;UnshippedOrdersRuleValidator, Validators&quot;<br />          name=&quot;Unshipped Orders Rule Validator&quot; /&gt;<br />      &lt;/ruleset&gt;<br />    &lt;/type&gt;<br />  &lt;/validation&gt;<br /></pre><p>As I wrote, each version would have a defect. But the code looks so innocent; what could be wrong with it?<br /><br />The trouble is that this validator is too simplistic and the possible deletion of orders within that context are not handled correctly. Here is an integration test that proves this bug:</p><pre class="cs" language="csharp" customtypes="TestMethod TransactionScope NorthwindDataContext Customer Order " customvaluetypes="PutYourCustomValueTypesHere">[TestMethod]<br />public void UnshippedOrdersRuleTest01()<br />{<br />    using (new TransactionScope())<br />    {<br />        using (var db = new NorthwindDataContext())<br />        {<br />            // Customer ERNSH has 2 unshipped order in the <br />            // database.<br />            Customer ernsh =<br />                db.Customers.Single(c =&gt; c.CustomerID == &quot;ERNSH&quot;);<br /><br />            ernsh.ContactName = &quot;Steven&quot;;<br /><br />            // Adding one new unshipped order. <br />            Order orderToInsert = new Order();<br />            orderToInsert.Customer = ernsh;<br />            db.Orders.InsertOnSubmit(orderToInsert);<br /><br />            // Delete this order and its details.<br />            Order orderToDelete = (<br />                from order in db.Orders<br />                where order.CustomerID == ernsh.CustomerID<br />                where order.ShippedDate == null<br />                select order).First();<br /><br />            // We must also delete the order&rsquo;s details.<br />            db.Orders.DeleteOnSubmit(orderToDelete);<br />            db.OrderDetails.DeleteAllOnSubmit(<br />                orderToDelete.OrderDetails);<br /><br />            // SubmitChanges should succeed, because the customer<br />            // should now still have 2 unshipped orders.<br />            db.SubmitChanges();<br />        }<br />    }<br />}</pre><p>Here are some notes on this test. While it&rsquo;s an automated test, it differentiates from normal unit tests in that it doesn&rsquo;t test a single unit of code, but a single feature or requirement. The test does this by touching the different tiers in the application. It even accesses the database in this test, which is absolutely a no-go in unit testing. The test expects the Northwind database with it&rsquo;s default data (therefore, it&rsquo;s wise to have a dedicated test database, when you&rsquo;re running integration tests). By wrapping all code in a <span class="type">TransactionScope</span>, we ensure that all database changes are rolled back after the test finished. This way we can be sure that the test can run successfully again and again. Also note that I only show tests relevant to this post. In reality, more tests are needed to prove correctness of this business rule.<br /><br />The test retrieves a specific customer from the database, inserts a new unshipped order for that customer and deletes another (already existing) unshipped order from the database. The specified customer has currently two unshipped orders in the database (a precondition for this test to run). Now after deleting one of those and adding a new unshipped order, the customer should again have two unshipped orders, but the test fails and therefore I&rsquo;ve proven this first version of the unshipped orders business rule to be flawed.</p><h5>Version 2.0</h5><p>Here is a new implementation of the <span class="code">DoValidate</span> method, that fixes that flaw:</p><pre class="cs" language="csharp" customtypes="ValidationResults Customer NorthwindDataContext ContextScope Order" customvaluetypes="PutYourCustomValueTypesHere">protected override void DoValidate(object objectToValidate, <br />    object currentTarget, string key, ValidationResults results)<br />{<br />    Customer customer = (Customer)currentTarget;<br /><br />    NorthwindDataContext context = <br />        (NorthwindDataContext)ContextScope.CurrentContext;<br /><br />    var ordersToDelete =<br />        context.GetChangeSet().Deletes.OfType&lt;Order&gt;();<br /><br />    int totalUnshippedOrders = (<br />        from order in customer.Orders<br />        where order.ShippedDate == null<br />        where !ordersToDelete.Contains(order)<br />        select order).Count();<br /><br />    if (totalUnshippedOrders &gt; MaximumNumberOfUnshippedOrders)<br />    {<br />        ...<br />    }<br />}</pre><p>This new version uses the <span class="type">ContextScope</span><span class="code">.CurrentContext</span> construct to get the context, as discussed in <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=47" title=".NET Junkie - Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 2: Using context within custom validators.">part 2</a>. It uses LINQ to SQL&rsquo;s <a rel="external" href="http://msdn.microsoft.com/en-us/library/system.data.linq.changeset.aspx" title="MSDN - System.Data.Linq.ChangeSet Class"><span class="type">ChangeSet</span></a> to determine all orders that are currently being deleted (within that context of course). This list is used to filter those orders from the total number of unshipped orders, because this is what caused our test to fail. The rest of the code remains the same.<br /><br />The previously defined integration test will now succeed. However, there is another problem. The validator only validates customers, while also orders have to be validated. Let&rsquo;s write a second test to detect this bug:</p><pre class="cs" language="csharp" customtypes="TestMethod ExpectedException ValidationException TransactionScope NorthwindDataContext Customer Order" customvaluetypes="PutYourCustomValueTypesHere">[TestMethod]<br />[ExpectedException(typeof(ValidationException))]<br />public void UnshippedOrdersRuleTest02()<br />{<br />    using (new TransactionScope())<br />    {<br />        using (var db = new NorthwindDataContext())<br />        {<br />            // Customer ERNSH has two unshipped order in the <br />            // database.<br />            Customer ernsh =<br />                db.Customers.Single(c =&gt; c.CustomerID == &quot;ERNSH&quot;);<br /><br />            // Adding a third unshipped order. <br />            Order orderToInsert = new Order();<br />            orderToInsert.Customer = ernsh;<br />            db.Orders.InsertOnSubmit(orderToInsert);<br /><br />            // SubmitChanges should throw a ValidationException.<br />            db.SubmitChanges();<br />        }<br />    }<br />}</pre><p>This test fails, because <span class="code">SubmitChanges</span> didn&rsquo;t throw the expected exception. This happens because the validator is never called. The first test (deliberately) changed the <span class="code">ContactName</span> of the customer. This second test however didn&rsquo;t. Therefore the customer didn&rsquo;t change and because of that the validation wasn&rsquo;t triggered.<br /><br />In <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=46" title=".NET Junkie - Integrating Enterprise Library Validation Application Block With LINQ to SQL and Entity Framework Part 1: Basic Integration">part 1</a>, I&rsquo;ve built the validation infrastructure in such a way that it only validates changed objects (see the <span class="code">GetChangedEntities</span> method). That infrastructure could be changed in such a way that it validates all objects, but this would give an enormous performance penalty. Thousands of entities could be loaded by the context, while maybe just a single entity was changed. The real event that should trigger the validation of a customer is not the creation or mutation of the customer itself, but rather that of an order. Let&rsquo;s try it once more.</p><h5>Version 3.0</h5><p>Below, the new <span class="code">DoValidate</span> implementation changed in such a way that -not a customer- but the customer&rsquo;s order is the target object:</p><pre class="cs" language="csharp" customtypes="ValidationResults Customer Order NorthwindDataContext ContextScope" customvaluetypes="PutYourCustomValueTypesHere">protected override void DoValidate(object objectToValidate, <br />    object currentTarget, string key, ValidationResults results)<br />{<br />    // We cast the currentTarget to the order and get it&rsquo;s customer.<br />    Customer customer = ((Order)currentTarget).Customer;<br /><br />    NorthwindDataContext context =<br />        (NorthwindDataContext)ContextScope.CurrentContext;<br /><br />    var ordersToDelete =<br />        context.GetChangeSet().Deletes.OfType&lt;Order&gt;();<br /><br />    int totalUnshippedOrders = (<br />        from order in customer.Orders<br />        where order.ShippedDate == null<br />        where !ordersToDelete.Contains(order)<br />        select order).Count();<br /><br />    if (totalUnshippedOrders &gt; MaximumNumberOfUnshippedOrders)<br />    {<br />        ...<br />    }<br />}</pre><p>Within the validator, the customer is still validated, but VAB is now supplying an order. Changing an order should now trigger the validation and for this the VAB configuration must be changed:</p><pre class="cs" language="csharp" customtypes="PutYourCustomTypesHere" customvaluetypes="PutYourCustomValueTypesHere">  &lt;validation&gt;<br />    &lt;type name=&quot;Order&quot; defaultRuleset=&quot;Default&quot;<br />      assemblyName=&quot;Domain&quot;&gt;<br />      &lt;ruleset name=&quot;Default&quot;&gt;<br />        &lt;validator type=&quot;UnshippedOrdersRuleValidator, Validators&quot;<br />          name=&quot;Unshipped Orders Rule Validator&quot; /&gt;<br />      &lt;/ruleset&gt;<br />    &lt;/type&gt;<br />  &lt;/validation&gt;<br /></pre><p>While the new code and configuration satisfies both the previously defined tests, this change resulted in a new problem. When a customer is invalid, we&rsquo;d expect a single message that describes this error. Let&rsquo;s write a test for this:</p><pre class="cs" language="csharp" customtypes="TestMethod TransactionScope NorthwindDataContext Customer Order Assert ValidationException" customvaluetypes="PutYourCustomValueTypesHere">[TestMethod]<br />public void UnshippedOrdersRuleTest03()<br />{<br />    using (new TransactionScope())<br />    {<br />        using (var db = new NorthwindDataContext())<br />        {<br />            Customer junkie = new Customer();<br /><br />            junkie.CustomerID = &quot;junki&quot;;<br />            junkie.ContactName = &quot;S. van Deursen&quot;;<br />            junkie.CompanyName = &quot;Cutting Edge&quot;;<br /><br />            // Adding three new unshipped orders.<br />            // Yes, this magically works in L2S :-)<br />            new Order { Customer = junkie };<br />            new Order { Customer = junkie };<br />            new Order { Customer = junkie };<br /><br />            db.Customers.InsertOnSubmit(junkie);<br /><br />            try<br />            {<br />                db.SubmitChanges();<br />                Assert.Fail(&quot;Exception was expected.&quot;);<br />            }<br />            catch (ValidationException vex)<br />            {<br />                int actualCount = vex.Results.Count;<br />                // Should contain one message.<br />                Assert.AreEqual(1, actualCount);<br />            }<br />        }<br />    }<br />}</pre><p>This third test fails, because the list of errors will contain three results instead of the expected single result. There is a result for each validated order. But all results describe the same message:</p><blockquote><font color="#ff0000">Customer with ID junki has currently 3 unshipped orders, while 2 is the maximum permitted number of unshipped orders.</font></blockquote><p>These duplicate error messages will clutter the user interface and while it&rsquo;s possible to filter those duplicate messages, this isn&rsquo;t desirable. Besides that, duplicate validations can have big impact on the performance of the system. Imagine changing a couple of hundred orders of a single customer within the same context.</p><h5>Version 4.0</h5><p>How can these duplicate validations be prevented? A validated customer must be registered in such a way that the <span class="type">UnshippedOrdersRuleValidator</span> doesn&rsquo;t validate that customer twice within the same context. It should also work correctly in a multi-threaded / multi-user environment such as ASP.NET. To solve this, let&rsquo;s use the infrastructure, presented in <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=47" title=".NET Junkie - Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 2: Using context within custom validators.">part 2</a>. Some sort of caching mechanism must be implemented that validators can use. The only feasible place to define such a mechanism is within the <span class="type">ContextScope</span> class (see <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=47" title=".NET Junkie - Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 2: Using context within custom validators.">part 2</a> for the previous definition). Here is a new implementation:</p><pre class="cs" language="csharp" customtypes="ContextScope IDisposable ThreadStatic " customvaluetypes="PutYourCustomValueTypesHere">public sealed class ContextScope : IDisposable<br />{<br />    private const string ScopeAlreadyActiveExceptionMessage =<br />        &quot;A ContextScope has already been declared within &quot; +<br />        &quot;the current scope. Only one scope can be active.&quot;;<br /><br />    private const string NoScopeActiveExceptionMessage =<br />        &quot;A ContextScope hasn't been declared with in the &quot; +<br />        &quot;current scope. This property can only be called &quot; +<br />        &quot;within the context of a ContextScope.&quot;;<br /><br />    [ThreadStatic]<br />    private static object currentContext;<br /><br />    // This static field has been added.<br />    [ThreadStatic]<br />    private static Dictionary&lt;Type, object&gt; currentItems;<br /><br />    public ContextScope(object context)<br />    {<br />        context.Requires(&quot;context&quot;).IsNotNull();<br /><br />        if (currentContext != null)<br />        {<br />            throw new InvalidOperationException(<br />                ScopeAlreadyActiveExceptionMessage);<br />        }<br /><br />        currentContext = context;<br />        currentItems = new Dictionary&lt;Type, object&gt;();<br />    }<br /><br />    public static object CurrentContext<br />    {<br />        get<br />        {<br />            object context = currentContext;<br /><br />            if (context == null)<br />            {<br />                throw new InvalidOperationException(<br />                    NoScopeActiveExceptionMessage);<br />            }<br /><br />            return context;<br />        }<br />    }<br /><br />    // This static property has been added.<br />    public static Dictionary&lt;Type, object&gt; CurrentItems<br />    {<br />        get<br />        {<br />            Dictionary&lt;Type, object&gt; items = currentItems;<br /><br />            if (items == null)<br />            {<br />                throw new InvalidOperationException(<br />                    NoScopeActiveExceptionMessage);<br />            }<br /><br />            return items;<br />        }<br />    }<br /><br />    public void Dispose()<br />    {<br />        currentContext = null;<br />        currentItems = null;<br />    }<br />}</pre><p>This extended <span class="type">ContextScope</span> contains a new <span class="code">CurrentItems</span> property that returns a thread-local dictionary, just like the thread-local context returned from the <span class="code">CurrentContext</span> property. This is a generic solution for all our custom validators that need a context-aware cache. Now let&rsquo;s fix the implementation of the <span class="type">UnshippedOrdersRuleValidator</span> class, using this new feature:</p><pre class="cs" language="csharp" customtypes="ValidationResults Customer Order NorthwindDataContext ContextScope UnshippedOrdersRuleValidator" customvaluetypes="PutYourCustomValueTypesHere">protected override void DoValidate(object objectToValidate, <br />    object currentTarget, string key, ValidationResults results)<br />{<br />    Customer customer = ((Order)currentTarget).Customer;<br /><br />    // Prevent duplicate customer validations.<br />    if (ValidatedCustomers.Contains(customer))<br />    {<br />        return;<br />    }<br /><br />    // Add the customer to the list of validated customers.<br />    ValidatedCustomers.Add(customer);<br /><br />    NorthwindDataContext context =<br />        (NorthwindDataContext)ContextScope.CurrentContext;<br /><br />    var ordersToDelete =<br />        context.GetChangeSet().Deletes.OfType&lt;Order&gt;();<br /><br />    ...<br />}<br /><br />// Returns a list of customers, validated in the current context.<br />private static HashSet&lt;Customer&gt; ValidatedCustomers<br />{<br />    get<br />    {<br />        Dictionary&lt;Type, object&gt; items = ContextScope.CurrentItems;<br /><br />        Type key = typeof(UnshippedOrdersRuleValidator);<br /><br />        object validatedCustomers;<br /><br />        // Get the list of validated customers from the cache.<br />        if (!items.TryGetValue(key, out validatedCustomers))<br />        {<br />            // When there's no list yet, we create a new one and <br />            // register it in the item cache.<br />            validatedCustomers = new HashSet&lt;Customer&gt;();<br />            items.Add(key, validatedCustomers);<br />        }<br /><br />        return (HashSet&lt;Customer&gt;)validatedCustomers;<br />    }<br />}</pre><p>This version uses the new <span class="type">ContextScope</span><span class="code">.CurrentItems</span> property to retrieve its list of validated customers. Because I&rsquo;ve implemented the <span class="code">CurrentItems</span> as a dictionary with a <span class="type">Type</span> key, the validator can supply it&rsquo;s type as key. This way each validator can have it&rsquo;s own private cache, without interfering with others.<br /><br />The next problem we will tackle has to do with the <span class="code">Orders</span> property on our LINQ to SQL customer entity. The <span class="code">Orders</span> property returns a collection of orders. To be more precise: it returns an instance of type EntitySet&lt;Order&gt;. LINQ to SQL&rsquo;s <a rel="external" href="http://msdn.microsoft.com/en-us/library/bb341748.aspx" title="MSDN - System.Data.Linq.EntitySet&lt;(Of &lt;(TEntity&gt;)&gt;) Class"><span class="type">EntitySet</span><span class="code">&lt;TEntity&gt;</span></a> however, is an in-memory store of all orders related to that customer. It doesn&rsquo;t implement <span class="type">IQueryable</span><span class="code">&lt;T&gt;</span>, but <span class="type">IEnumerable</span><span class="code">&lt;T&gt;</span> exclusively. You can only iterate over all items and that means all the orders in the database related to that specific customer. In other words, the &lsquo;<span class="keyword">from</span><span class="code"> order </span><span class="keyword">in</span><span class="code"> customer.Orders</span>&rsquo; query in the <span class="code">DoValidate</span> method retrieves *all* orders for that customer from the database. Imagine a customer with a few thousand orders and you&rsquo;ll get the picture. Every time this validator runs, it loads all orders in memory. Now imagine yourself this validator running on your production web server with thousands of users. Of course we know that <a rel="external" href="http://c2.com/cgi/wiki?PrematureOptimization" title="DonaldKnuth - Premature optimization is the root of all evil">premature optimization is the root of all evil</a>, but let&rsquo;s say we know during design that certain customers will have over a thousand orders now or in the near future. In that case we aren&rsquo;t talking about premature optimization anymore. With that condition in mind, we&rsquo;ll have to make a conscious design decision.</p><h5>Version 5.0</h5><p>It&rsquo;s note easy to write an integration test that checks whether the validator loads too many orders, because the validator is functionally correct and LINQ to SQL doesn&rsquo;t allow us to hook into it&rsquo;s infrastructure to check this. Writing such a test is outside the scope of this post. Therefore we directly move on to the new definition of the UnshippedOrdersRuleValidator class:</p><pre class="cs" language="csharp" customtypes="ValidationResults Customer Order NorthwindDataContext ContextScope ChangeSet IQueryable" customvaluetypes="PutYourCustomValueTypesHere">protected override void DoValidate(object objectToValidate, <br />    object currentTarget, string key, ValidationResults results)<br />{<br />    Customer customer = ((Order)currentTarget).Customer;<br /><br />    // Prevent duplicate customer validations.<br />    if (ValidatedCustomers.Contains(customer))<br />    {<br />        return;<br />    }<br /><br />    ValidatedCustomers.Add(customer);<br /><br />    NorthwindDataContext context =<br />        (NorthwindDataContext)ContextScope.CurrentContext;<br /><br />    IQueryable&lt;Order&gt; unshippedOrdersInDatabase =<br />        GetUnshippedOrdersFromDatabase(context, customer);<br /><br />    IEnumerable&lt;Order&gt; unshippedOrdersInMemory =<br />        GetUnshippedOrdersFromContext(context, customer);<br /><br />    int totalUnshippedOrders =<br />        unshippedOrdersInDatabase.Count() +<br />        unshippedOrdersInMemory.Count();<br /><br />    if (totalUnshippedOrders &gt; MaximumNumberOfUnshippedOrders)<br />    {<br />        ...<br />    }<br />}<br /><br />private static IQueryable&lt;Order&gt; GetUnshippedOrdersFromDatabase(<br />    NorthwindDataContext context, Customer customer)<br />{<br />    ChangeSet changeSet = context.GetChangeSet();<br /><br />    var updatesAndDeletesInContext =<br />        changeSet.Updates.Concat(changeSet.Deletes);<br /><br />    // Get a list of all the customer's orders that are updated or <br />    // deleted.<br />    var excludedOrderIds =<br />        from order in updatesAndDeletesInContext.OfType&lt;Order&gt;()<br />        where order.CustomerID == customer.CustomerID<br />        select order.OrderID;<br /><br />    // Get a list of all the customer's orders in the database<br />    // that have no shipped date, excluded by the list of updated<br />    // and deleted orders in the current context (this prevents <br />    // double counts).<br /><br />    // Note that we use context.Orders instead of customer.Orders<br />    return<br />        from order in context.Orders<br />        where order.CustomerID == customer.CustomerID<br />        where order.ShippedDate == null<br />        where !excludedOrderIds.Contains(order.OrderID)<br />        select order;<br />}<br /><br />private static IEnumerable&lt;Order&gt; GetUnshippedOrdersFromContext(<br />    NorthwindDataContext context, Customer customer)<br />{<br />    ChangeSet changeSet = context.GetChangeSet();<br /><br />    var insertsAndUpdatesInContext =<br />        changeSet.Inserts.Concat(changeSet.Updates);<br /><br />    // Get a list of all the customer's orders in the datacontext<br />    // (in memory) that are being inserted or updated and don't <br />    // have a shipped data (we don't count the deletes).<br />    return<br />        from order in insertsAndUpdatesInContext.OfType&lt;Order&gt;()<br />        where order.CustomerID == customer.CustomerID<br />        where order.ShippedDate == null<br />        select order;<br />}<br /></pre><p>As you can see, there&rsquo;s already a lot of code to get the business rule correct. Although this version is functionally equivalent to the previous version, the performance is much better. The <span class="type">IQueryable</span><span class="code">&lt;</span><span class="type">Order</span><span class="code">&gt;</span> returned from the <span class="code">GetUnshippedOrdersFromDatabase</span> function is deferred and will result in the following (very efficient) database query during the call to <span class="code">Count()</span>:</p><pre><font color="#0000ff">SELECT  </font><font color="#ff00ff">COUNT</font>(*) <font color="#0000ff">AS </font>[value]<br /><font color="#0000ff">FROM    </font>[dbo].[Orders] <font color="#0000ff">AS </font>[t0]<br /><font color="#0000ff">WHERE   </font>(<font color="#0000ff">NOT </font>([t0].[OrderID] <font color="#0000ff">IN </font>(@p0))) <br /><font color="#0000ff">AND     </font>([t0].[ShippedDate] <font color="#0000ff">IS NULL</font>) <br /><font color="#0000ff">AND     </font>([t0].[CustomerID] = @p1)</pre><p>But still, even now, there&rsquo;s a glitch. This time however, the problem is less obvious, it is one of concurrency. While this code is functionally correct and even performs great, a system that uses the rule might get in the situation where two different users / processes manage to simultaneously insert new unshipped orders for a certain customer and thereby bypassing the validation mechanism. This will happen when the validators for both processes run before each other&rsquo;s order insertions. The <a rel="external" href="://en.wikipedia.org/wiki/Optimistic_concurrency_control" title="Wikipedia - http://en.wikipedia.org/wiki/Optimistic_concurrency_control">optimistic locking</a> mechanism most O/RM tools use, will not help in this case. Optimistic concurrency mechanisms are simply unable to handle this specific scenario. To solve this <a rel="external" href="http://en.wikipedia.org/wiki/Race_condition" title="Wikipedia - Race condition">race condition</a>, these are the alternatives one could consider:</p><ul><li>Do nothing and just let it happen.</li><li>Use pessimistic offline locking.</li><li>Implement a constraint in the database.</li><li>Use database transactions (a.k.a. pessimistic online locking).</li></ul><p>Doing nothing and letting it happen can be a very valid solution to this problem. If you can predict that the likelihood of failure, times the costs of correcting the corrupted data in case of such a failure is less than the costs of implementing a foolproof solution; that solution is commercially your best pick (but don&rsquo;t forget to document that decision). Of course this depends on a wide variety of variables, both technically and non-technically, such as the chosen architecture, complexity of the system, experience of the development team, business strategy, the cost of repairing customer trust, etc.<br /><br />The second alternative is using a <a rel="external" href="http://martinfowler.com/eaaCatalog/pessimisticOfflineLock.html" title="Martin Fowler - Pessimistic Offline Lock">pessimistic offline lock</a>. Depending upon requirements and the system architecture, a locking mechanism could be used that&rsquo;s not based on database transaction (pessimistic online locking), or <a rel="external" href="://en.wikipedia.org/wiki/Optimistic_concurrency_control" title="Wikipedia - http://en.wikipedia.org/wiki/Optimistic_concurrency_control">optimistic locking</a>. <a rel="external" href="http://martinfowler.com/" title="Martin Fowler - Author, speaker, and consultant on the design of enterprise software.">Martin Fowler</a> describes a pessimistic offline lock as follows:</p><blockquote>It forces a business transaction to acquire a lock on a piece of data before it starts to use it, so that, most of the time, once you begin a business transaction you can be pretty sure you'll complete it without being bounced by concurrency control.</blockquote><p>Acquiring a lock on a piece of data could be done in several ways. You could for instance implement this by storing extra information at row level about who locked the data at which moment. Using pessimistic offline locking all over the place however, is a terrible idea and it has to be thought out very carefully within the business requirements and system architecture, where and how to use this mechanism. For instance, when the given business rule runs within automated processes, what should be done in case of a lock? Should one of the processes fail, wait until the lock can be acquired or should it be prevented from running in the first place?</p><h5>Version 6.0</h5><p>Let&rsquo;s try to solve the problem using a database constraint. Using a database constraint is only a fallback mechanism to prevent state corruption in the database. It prevents corruption, but it&rsquo;s not always suitable in the context of an O/RM technology, as we will see shortly. I call constraints a fallback mechanism, because it&rsquo;s preferable to define all business rules in one place. Of course I prefer defining them in code, as I&rsquo;m showing you in this post by using the VAB. The problem with constraints is that a failing database constraint will result in an exception being thrown within .NET and while it&rsquo;s possible to do some smart exception filtering to see which constraint did fail, that&rsquo;s all there is. There is no (simple) way to see which entity caused the failure, and because of this, there is no way to communicate back to the user what exactly went wrong and what must be done to fix the problem.<br /><br />The problem we&rsquo;re dealing with here is one of concurrency. It might not show up that often (if ever) and therefore we might be fine with the few times that it fails hard. At least our database remains consistent. Let&rsquo;s assume we are fine with it failing ugly, and let&rsquo;s create a constraint in the database for our made up business rule:</p><pre><font color="#000000"><font color="#0000ff">CREATE FUNCTION </font>dbo.GetNumberOfUnshippedOrders<br />(<br />    @CustomerID <font color="#0000ff">nchar</font>(5)<br />)<br /><font color="#0000ff">RETURNS int<br />AS<br />BEGIN<br />    DECLARE</font> @Result <font color="#0000ff">int</font><br /><br />    <font color="#0000ff">SELECT </font>@Result = <font color="#ff00ff">COUNT</font>(*)<br />    <font color="#0000ff">FROM   </font>Orders<br />    <font color="#0000ff">WHERE  </font>CustomerID = @CustomerID<br />    <font color="#0000ff">AND    </font>ShippedDate <font color="#0000ff">IS NULL</font><br /><br />    <font color="#0000ff">RETURN </font>@Result<br /><font color="#0000ff">END<br />GO<br /><br />ALTER TABLE</font> dbo.Orders <br /><font color="#0000ff">ADD CONSTRAINT</font> CK_Orders_MaxUnshippedOrders <br /><font color="#0000ff">CHECK </font>(<br />    dbo.GetNumberOfUnshippedOrders(CustomerID) &lt;= 2<br />)<br /></font></pre><p>After we added the constraint to the database we can rerun our integration tests to see if everything still works fine, but <em>Houston we have a problem</em>! The first test fails:</p><blockquote><font color="#ff0000">Test method TestProject1.UnitTest1.UnshippedOrdersRuleTest01 threw exception:&nbsp; System.Data.SqlClient.SqlException: The INSERT statement conflicted with the CHECK constraint &quot;CK_Orders_MaxUnshippedOrders&quot;. The conflict occurred in database &quot;Northwind&quot;, table &quot;dbo.Orders&quot;, column 'CustomerID'.<br />The statement has been terminated.</font></blockquote><p>Why is this constraint making our test fail? Look at the test and notice how the insertion of the new order happens before the deletion of the old. Swapping the order in which those are executed however, will have no effect. We&rsquo;re screwed here, because LINQ to SQL reorders the mutations, and decides that <a rel="external" href="http://stackoverflow.com/questions/445985/linq-to-sql-execution-order-when-calling-submitchanges/1210190#1210190" title="Stackoverflow - Linq to SQL: execution order when calling SubmitChanges()">deletes should be executed after inserts</a>. There is nothing we can do about that. This is why O/RM technologies such as LINQ to SQL could sometimes make it hard to define database constraints. This version failed, let&rsquo;s remove that constraint again from the database and move on to the last alternative:</p><pre><font><font color="#000000"><font color="#0000ff">ALTER TABLE </font>dbo.Orders <br /><font color="#0000ff">DROP CONSTRAINT</font> CK_Orders_MaxUnshippedOrders <br /></font></font></pre><p>Adding a constraint didn&rsquo;t work in this scenario. The last alternative is using database transactions. We could wrap the use of the context class in a transaction. Using the <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=13" title=".NET Junkie - The DbTransactionWrapper"><span class="type">SqlTransactionWrapper</span></a>, I wrote a long time ago, this would look like this:</p><pre class="cs" language="csharp" customtypes="SqlTransactionWrapper NorthwindDataContext" customvaluetypes="PutYourCustomValueTypesHere">using (var tran = new SqlTransactionWrapper(&quot;connstr.&quot;))<br />{<br />    using (var db = new NorthwindDataContext(tran.Connection))<br />    {<br />        // We'll need to set the Transaction in L2S.<br />        db.Transaction = tran.Transaction;<br /><br />        // TODO: Business logic<br /><br />        db.SubmitChanges();<br />    }<br /><br />    tran.Commit();<br />}<br /></pre><p>However, when trying to use transactions to prevent concurrency conflicts to occur, one could have a rude awakening. In this case the transactional logic should prevent other processes from creating, updating or deleting orders for the validated customer. Normally this would mean creating custom queries with <a rel="external" href="http://msdn.microsoft.com/en-us/library/aa213026.aspx" title="MSDN SQL Server Locking Hints">locking hints</a>, because just using a transaction -even serializable transactions- will not protect you from this race condition. When using O/RM technology, writing custom queries is something we&rsquo;d like to prevent. O/RM tools take away the need to write SQL code and hand-written SQL statements are hard to integrate with O/RM tools. Besides, I find reasoning about transactional correctness pretty difficult.</p><blockquote>Note: Although I like using the <span class="type">TransactionScope</span> with integration tests, I never seem to see them fit in my software architecture. Within the scope of a <span class="type">TransactionScope</span>, there will be only one transaction. This means that, in case of a failure, all database operations will be reverted. That means that also logging information, such as exception logging, written to the database, will be rolled back. Of course one could again make sure those logs are written in their own <span class="type">TransactionScope</span>, but this makes designing and writing applications much harder.</blockquote><p>I think the simplest way in writing correct transactional code in this situation is by using a serializable transaction in conjunction with a count operation over the Orders table for all orders of the customer being validated. The count operation over the customer&rsquo;s orders together with the serializable transaction prevents other transactions from inserting new orders for that customer during that transaction. Here is the updated <span class="type">UnshippedOrdersRuleValidator</span> class:</p><pre class="cs" language="csharp" customtypes="ValidationResults NorthwindDataContext ContextScope DbTransaction " customvaluetypes="PutYourCustomValueTypesHere">protected override void DoValidate(object objectToValidate, <br />    object currentTarget, string key, ValidationResults results)<br />{<br />    ...<br /><br />    NorthwindDataContext context =<br />        (NorthwindDataContext)ContextScope.CurrentContext;<br /><br />    CheckIfContextRunsInSerializableTransaction(context);<br /><br />    // This select count(*) will, in conjunction with the<br />    // serializable transaction, prevent other transactions from<br />    // inserting, updating and deleting orders for this customer.<br />    context.Orders<br />        .Where(o =&gt; o.CustomerID == customer.CustomerID)<br />        .Count();<br /><br />    ...<br />}<br /><br />private void CheckIfContextRunsInSerializableTransaction(<br />    NorthwindDataContext context)<br />{<br />    DbTransaction transaction = context.Transaction;<br /><br />    if (transaction == null || context.Connection == null ||<br />        transaction.IsolationLevel != IsolationLevel.Serializable)<br />    {<br />        throw new InvalidOperationException(&quot;The context &quot; +<br />            &quot;should be part of a serializable transaction&quot;);<br />    }<br />}</pre><p>Running the context in a serializable transaction, should not be forgotten:</p><pre class="cs" language="csharp" customtypes="SqlTransactionWrapper NorthwindDataContext" customvaluetypes="IsolationLevel">using (var tran = new SqlTransactionWrapper(&quot;connstr.&quot;,<br />    IsolationLevel.Serializable))<br />{<br />    using (var db = new NorthwindDataContext(tran.Connection))<br />    {<br />        db.Transaction = tran.Transaction;<br /><br />        // TODO: Business logic<br /><br />        db.SubmitChanges();<br />    }<br /><br />    tran.Commit();<br />}<br /></pre><p>This effectively solves the concurrency problem. Still, using a serializable transaction has it&rsquo;s problems on it&rsquo;s own. It increases the possibility of deadlocks to occur, especially since we have no control over the order in which O/RM tools write data and the order in which our validators are executed. And while there is the possibility to detect a deadlock exception within the SubmitChanges method, and retry the operation, it&rsquo;s better to not do this while the context is part of a bigger transaction (as shown in the last example). A deadlock detected by the database will effectively rollback that transaction in the database, while the connection is kept open in .NET. Retrying that operation, means it will be executed in a transactionless context and this could lead to data corruption. I think it&rsquo;s best to consider the complete connection doomed in case of a failure caused by SQL. Retrying the operation can only be done on the level where the transaction is defined (by recreating that transaction and it&rsquo;s connection), but this is typically a place where you don&rsquo;t want to have such logic. I advice you just let it fail and let the infrastructure log that exception.</p><blockquote>Note: Please note that while serializable transactions might increase the number of deadlocks in the system, you must ask yourself if you know for sure that lowering the isolation level of your transactions couldn&rsquo;t lead to a database that is in a (functionally) corrupted state. This is very hard to reason about. Also remember that this deadlock might have actually prevented any state corruption.</blockquote><p>Please note that the reason that using locks works in this scenario, is because the database server holds locks on certain indexes in the Orders table. The effectiveness of this solution therefore depends on the indexes in this table. Changing the indexes in the database could change the effectiveness and correctness of this solution. This has to be taking into effect when choosing such a solution. When using SQL Server, you can use the <a rel="external" href="http://msdn.microsoft.com/en-us/library/ms187749.aspx" title="MSDN - Transact-SQL Reference - sp_lock">sp_lock</a> or <a rel="external" href="http://support.microsoft.com/kb/q255596/" title="Microsoft support - sp_lock2 Returns Additional Locking Details">sp_lock2</a> procedures to check whether the code acquired the correct locks and of course check your assumptions manually when building such a solution and every time you make changes to the indexes in the database. This makes it a time consuming and error-prone solution.</p><h5>Conclusion</h5><p>We must conclude that there is not a technically pleasant solution to our business rule problem. While serializable transactions do the trick, they have their performance penalties and increased changes of deadlocking. Although your solution works today, it could behave differently after your colleague added or removed an index. Also note that, because of the difficulties, I would say using serializable transactions is an architectural decision. Determining on your application, it may be better to go for pessimistic offline locking, or perhaps doing nothing and letting it happen is even more feasible. But, as I said, this totally depends on your business, architecture, software, team, etc. However, what remains important, is to understand the difficulties you are facing. Software engineering is all about tradeoffs, but if you don&rsquo;t know there is a difficulty, there is nothing to consider in the first place. I hope I succeeded in warning you.</p><p>In the <a rel="external" href="http://cuttingedge.it/blogs/steven/pivot/entry.php?id=64" title="Integrating Enterprise Library Validation Application Block With LINQ to SQL and Entity Framework Part 4: Using Metadata to Automate Validations">next part</a> of this series I'll show how to use the metadata, generated by LINQ to SQL, to automate validations.</p><p>Good luck!</p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Enterprise_Library">Enterprise Library</a>, <a href="/blogs/steven/pivot/archive.php?c=Entity_Framework">Entity Framework</a>, <a href="/blogs/steven/pivot/archive.php?c=LINQ_to_SQL">LINQ to SQL</a>, <a href="/blogs/steven/pivot/archive.php?c=17">O/RM</a>, <a href="/blogs/steven/pivot/archive.php?c=SQL">SQL</a>, <a href="/blogs/steven/pivot/archive.php?c=Validation_Application_Block">Validation Application Block</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=49#comm" title="">No comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=49#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2009-m05.php#e49" title="Permanent link to 'Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 3: The complexity of custom validators.' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=49" title="Permanent link to entry 'Integrating Enterprise Library Validation Application Block with LINQ to SQL and Entity Framework Part 3: The complexity of custom validators.'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>No comments:</b></p>
			<div class="comments">
			<a id="comm"></a>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>