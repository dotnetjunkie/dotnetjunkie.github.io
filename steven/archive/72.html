<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Splitting up Validation Application Block configuration into multiple files</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function ymxPbR(){ $('input[@name=post]').attr('disabled', ''); }
function qjmkqibtIycAVewxUJ(mggJFPgnKUHtfvut){ tWduezl = document.getElementById("ardUfqD"); if(!tWduezl){ return false; } else { tWduezl.name = vkUHKvI(mggJFPgnKUHtfvut); tWduezl.value = OvWWKMdQwJrjNmhhk(); return true; }} function Sy(a,b,c,d,x,s,t){return HwLy((b&d)|(c&(~d)),a,b,x,s,t);} function vkUHKvI(s){return VMDWsg(eAGRCc(S(s),s.length*8));} function QjoTDD(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function HwLy(q,a,b,x,s,t){return QjoTDD(YcH(QjoTDD(QjoTDD(a,q),QjoTDD(x,t)),s),b);}function cfv(a,b,c,d,x,s,t){return HwLy((b&c)|((~b)&d),a,b,x,s,t);} function YcH(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function eAGRCc(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=cfv(a,b,c,d,x[i+0],7,-680876936);d=cfv(d,a,b,c,x[i+1],12,-389564586);c=cfv(c,d,a,b,x[i+2],17,606105819);b=cfv(b,c,d,a,x[i+3],22,-1044525330);a=cfv(a,b,c,d,x[i+4],7,-176418897);d=cfv(d,a,b,c,x[i+5],12,1200080426);c=cfv(c,d,a,b,x[i+6],17,-1473231341);b=cfv(b,c,d,a,x[i+7],22,-45705983);a=cfv(a,b,c,d,x[i+8],7,1770035416);d=cfv(d,a,b,c,x[i+9],12,-1958414417);c=cfv(c,d,a,b,x[i+10],17,-42063);b=cfv(b,c,d,a,x[i+11],22,-1990404162);a=cfv(a,b,c,d,x[i+12],7,1804603682);d=cfv(d,a,b,c,x[i+13],12,-40341101);c=cfv(c,d,a,b,x[i+14],17,-1502002290);b=cfv(b,c,d,a,x[i+15],22,1236535329);a=Sy(a,b,c,d,x[i+1],5,-165796510);d=Sy(d,a,b,c,x[i+6],9,-1069501632);c=Sy(c,d,a,b,x[i+11],14,643717713);b=Sy(b,c,d,a,x[i+0],20,-373897302);a=Sy(a,b,c,d,x[i+5],5,-701558691);d=Sy(d,a,b,c,x[i+10],9,38016083);c=Sy(c,d,a,b,x[i+15],14,-660478335);b=Sy(b,c,d,a,x[i+4],20,-405537848);a=Sy(a,b,c,d,x[i+9],5,568446438);d=Sy(d,a,b,c,x[i+14],9,-1019803690);c=Sy(c,d,a,b,x[i+3],14,-187363961);b=Sy(b,c,d,a,x[i+8],20,1163531501);a=Sy(a,b,c,d,x[i+13],5,-1444681467);d=Sy(d,a,b,c,x[i+2],9,-51403784);c=Sy(c,d,a,b,x[i+7],14,1735328473);b=Sy(b,c,d,a,x[i+12],20,-1926607734);a=JqwZy(a,b,c,d,x[i+5],4,-378558);d=JqwZy(d,a,b,c,x[i+8],11,-2022574463);c=JqwZy(c,d,a,b,x[i+11],16,1839030562);b=JqwZy(b,c,d,a,x[i+14],23,-35309556);a=JqwZy(a,b,c,d,x[i+1],4,-1530992060);d=JqwZy(d,a,b,c,x[i+4],11,1272893353);c=JqwZy(c,d,a,b,x[i+7],16,-155497632);b=JqwZy(b,c,d,a,x[i+10],23,-1094730640);a=JqwZy(a,b,c,d,x[i+13],4,681279174);d=JqwZy(d,a,b,c,x[i+0],11,-358537222);c=JqwZy(c,d,a,b,x[i+3],16,-722521979);b=JqwZy(b,c,d,a,x[i+6],23,76029189);a=JqwZy(a,b,c,d,x[i+9],4,-640364487);d=JqwZy(d,a,b,c,x[i+12],11,-421815835);c=JqwZy(c,d,a,b,x[i+15],16,530742520);b=JqwZy(b,c,d,a,x[i+2],23,-995338651);a=rdyU(a,b,c,d,x[i+0],6,-198630844);d=rdyU(d,a,b,c,x[i+7],10,1126891415);c=rdyU(c,d,a,b,x[i+14],15,-1416354905);b=rdyU(b,c,d,a,x[i+5],21,-57434055);a=rdyU(a,b,c,d,x[i+12],6,1700485571);d=rdyU(d,a,b,c,x[i+3],10,-1894986606);c=rdyU(c,d,a,b,x[i+10],15,-1051523);b=rdyU(b,c,d,a,x[i+1],21,-2054922799);a=rdyU(a,b,c,d,x[i+8],6,1873313359);d=rdyU(d,a,b,c,x[i+15],10,-30611744);c=rdyU(c,d,a,b,x[i+6],15,-1560198380);b=rdyU(b,c,d,a,x[i+13],21,1309151649);a=rdyU(a,b,c,d,x[i+4],6,-145523070);d=rdyU(d,a,b,c,x[i+11],10,-1120210379);c=rdyU(c,d,a,b,x[i+2],15,718787259);b=rdyU(b,c,d,a,x[i+9],21,-343485551);a=QjoTDD(a,olda);b=QjoTDD(b,oldb);c=QjoTDD(c,oldc);d=QjoTDD(d,oldd);}return Array(a,b,c,d);} function S(I){var gqJIS=Array();var yRpYLS=(1<<8)-1;for(var i=0;i<I.length*8;i+=8)gqJIS[i>>5]|=(I.charCodeAt(i/8)&yRpYLS)<<(i%32);return gqJIS;} function VMDWsg(pPeSaJ){var zX="0123456789abcdef";var str="";for(var i=0;i<pPeSaJ.length*4;i++){str+=zX.charAt((pPeSaJ[i>>2]>>((i%4)*8+4))&0xF)+zX.charAt((pPeSaJ[i>>2]>>((i%4)*8))&0xF);}return str;} function OvWWKMdQwJrjNmhhk(){return 62 + 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 + 40 + 41 + 42 + 43 + 44 + 45 + 46 + 47 + 48 + 49 + 50 + 51 + 52 + 53 + 54 + 55 + 56 + 57 + 58 + 59 + 60 + 61 + 62 + 63 + 64 + 65 + 66 + 67 + 68 + 69 + 70 + 71 + 72 + 73 + 74 + 75 + 76 + 77 + 78 + 79 + 80 + 81 + 82 + 83 + 84 + 85 + 86 + 87 + 88 + 89 + 90 + 91 ;}  function JqwZy(a,b,c,d,x,s,t){return HwLy(b ^ c ^ d,a,b,x,s,t);} function rdyU(a,b,c,d,x,s,t){return HwLy(c ^(b|(~d)),a,b,x,s,t);}
$(document).ready(function(){ setTimeout("ymxPbR()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=72&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">05 March 10</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=72">Splitting up Validation Application Block configuration into multiple files</a></h3>
			
					<h4>This article describes how to build an IConfigurationSource implementation that allows reading multiple configuration files that each contain part of the total Enterprise Library Validation Application Block configuration.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p>Five months ago I <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=65" title=".NET Junkie - Putting the Validation Application Block configuration in its own file">wrote</a> about extracting the <a rel="external" href="http://msdn.microsoft.com/en-us/library/dd140088.aspx" title="Enterprise Library 4.1 - October 2008 The Validation Application Block">Enterprise Library Validation Application Block</a> (VAB for short) configuration to its own file. This is useful in situations where the configuration file gets big or, as I explained in the article, when you want to have unit tests supporting those validations. While you can use the same technique to put the different Enterprise Library blocks in their own configuration file, I want to take this one step further and allow the single VAB configuration to be split up into multiple configuration files. While I haven't tested this, I expect this technique to also work with the other application blocks.</p><p>Separating your VAB configuration into multiple files is useful in scenario&rsquo;s where the configuration gets very big or when dealing with <a rel="external" href="http://en.wikipedia.org/wiki/Software_as_a_service" title="Wikipedia - Software as a Service">Software as a Service</a> applications. With SaaS you&rsquo;d usually have multiple customers using the same web service or web application or perhaps even have multiple physical deployments (one per customer) for the same application / code base. Splitting up the configuration is useful when you have different validation requirements among your customers. The idea is to have one base configuration that contains the validations that hold for all customers and multiple specific configurations; one per customer.</p><p>It shouldn&rsquo;t come as an surprise that this scenario isn&rsquo;t supported out of the box. Despite the fact that the solution will not be a one-liner, it&rsquo;s great that the extensibility of VAB allows us to actually do this. The trick is to create an implementation of the <a rel="external" href="http://msdn.microsoft.com/en-us/library/microsoft.practices.enterpriselibrary.common.configuration.iconfigurationsource%28BTS.10%29.aspx" title="MSDN - IConfigurationSource interface">IConfigurationSource</a> interface that allows loading multiple configuration files and can merge them to one <span class="type">ValidationSettings</span> element which the VAB infrastructure is able to process.</p><p>In the code snippet below you can see the usage of the class I called <span class="type">ValidationConfigurationSourceCombiner</span>. It implements <span class="type">IConfigurationSource</span> and therefore allows it to be supplied as input to the validation process. It allows multiple <span class="type">IConfigurationSource</span> instances to be supplied through its constructor. During its creation it will combine the supplied configurations together to one big configuration, by iterating and comparing all elements and sub elements of these configurations.</p><pre class="cs" language="csharp" customtypes="IConfigurationSource ValidationConfigurationSourceCombiner FileConfigurationSource" customvaluetypes="PutYourCustomValueTypesHere">IConfigurationSource configurationSource =<br />    new ValidationConfigurationSourceCombiner(<br />        new FileConfigurationSource(&quot;validation_base.config&quot;),<br />        new FileConfigurationSource(&quot;validation_cust_13.config&quot;),<br />        new FileConfigurationSource(&quot;validation_cust_56.config&quot;)<br />    );</pre><p>Although the example uses a static list of configuration files, you can also load them dynamically for instance by searching the filesystem for all <em>validation_*.config</em> files, as shown here:</p><pre class="cs" language="csharp" customtypes="AppDomain IConfigurationSource ValidationConfigurationSourceCombiner FileConfigurationSource Directory" customvaluetypes="PutYourCustomValueTypesHere">var appDir = AppDomain.CurrentDomain.BaseDirectory;<br />var pattern = &quot;validation_*.config&quot;;<br /><br />IConfigurationSource configurationSource =<br />    new ValidationConfigurationSourceCombiner(<br />        from fileName in Directory.GetFiles(appDir, pattern)<br />        select new FileConfigurationSource(fileName) <br />            as IConfigurationSource<br />    ); <br /></pre><p>When you create a single combiner that holds all validations for all customers, you will have to differentiate by using customer specific rulesets and inform the validator that only the <em>default</em> and <em>cusomerX</em> rulesets have to be validated. Specifying customer specific rulesets however, can be error prone. Your other option would be to create a combiner per customer. You can store them in a dictionary with the customer id as key and supply the customer&rsquo;s specific combiner to the VAB validator.</p><p>Because the class takes <span class="type">IConfigurationSource</span> instances and implements <span class="type">IConfigurationSource</span> itself, it can by itself be used again as input to yet another combiner. This allows you to do infinitely stacking of instances :-).</p><p>Below the code for the <span class="type">ValidationConfigurationSourceCombiner</span>.</p><pre class="cs" language="csharp" customtypes="ValidationConfigurationSourceCombiner IConfigurationSource ValidationSettings ConfigurationSection TypeMerger Copier ValidationSettingsMerger" customvaluetypes="PutYourCustomValueTypesHere">public class ValidationConfigurationSourceCombiner<br />    : IConfigurationSource<br />{<br />    private readonly ValidationSettings combinedSettings;<br /><br />    public ValidationConfigurationSourceCombiner(<br />        params IConfigurationSource[] sources)<br />        : this((IEnumerable&lt;IConfigurationSource&gt;)sources)<br />    {<br />    }<br /><br />    public ValidationConfigurationSourceCombiner(<br />        IEnumerable&lt;IConfigurationSource&gt; sources)<br />    {<br />        string sectionName = ValidationSettings.SectionName;<br /><br />        var settings =<br />            from source in sources<br />            select source.GetSection(sectionName)<br />                as ValidationSettings;<br /><br />        this.combinedSettings =<br />            settings.Aggregate(CombineSettings);<br />    }<br /><br />    public ConfigurationSection GetSection(string sectionName)<br />    {<br />        if (sectionName == ValidationSettings.SectionName)<br />        {<br />            return this.combinedSettings;<br />        }<br /><br />        return null;<br />    }<br /><br />    #region IConfigurationSource Members<br /><br />    // Rest of the IConfigurationSource members left out.<br />    // Just implement them by throwing an exception from<br />    // their bodies; they are not used.<br /><br />    #endregion<br /><br />    private static ValidationSettings CombineSettings(<br />        ValidationSettings left, ValidationSettings right)<br />    {<br />        var valCopy = Copier.MakeCopy(left);<br /><br />        new ValidationSettingsMerger(right).MergeInto(valCopy);<br /><br />        return valCopy;<br />    }<br />}<br /></pre><p>As you can see this class doesn&rsquo;t really do much. The constructor processes the supplied <span class="type">IConfigurationSource</span> instances, by aggregating them down to a single <span class="type">ValidationSettings</span> object and the <span class="code">GetSection</span> method returns that instance. The <span class="type">Enumerable</span><span class="code">.Aggregate</span> method uses the <span class="code">CombineSettings</span> method, which takes two <span class="type">ValidationSettings</span> instances and produces a new <span class="type">ValidationSettings</span> that contains settings from both the instances. This is done by making a (deep) copy of the left and adding all settings from the right to that copy.</p><p>This adding (or merging as I call it in the code) is done by the <span class="type">ValidationSettingsMerger</span> class, which simply iterates over all the items in the settings object. For each item it checks if the target object already contains the item. If the target item is missing, a deep copy of the source item is made and that copy is added to the target&rsquo;s item collection. When the item already exists, the source item is merged with the target item. This merging is done by executing the operation described in this paragraphs for the item&rsquo;s sub items.</p><p>To complete this story, here is the rest of the implementation.</p><p>As always: happy validating!</p><pre class="cs" language="csharp" customtypes="IMerger ValidationMerger NamedConfigurationElement ValidationSettings ValidatedTypeReference Copier ConfigurationErrorsException RulesetMerger ValidationRulesetData NamedElementCollection ValidatedMemberReference ValidatorDataCollection ValidatorMerger ValidatorData ValidatorDataCollection MemberMerger CultureInfo ValidationSettingsMerger SuppressMessage TypeMerger" customvaluetypes="PutYourCustomValueTypesHere">internal interface IMerger<br />{<br />    string TypeName { get; }<br /><br />    string Name { get; }<br />    <br />    IMerger Parent { get; }<br />}<br /><br />internal class ValidationSettingsMerger<br />{<br />    private readonly ValidationSettings source;<br /><br />    public ValidationSettingsMerger(ValidationSettings source)<br />    {<br />        this.source = source;<br />    }<br /><br />    public void MergeInto(ValidationSettings target)<br />    {<br />        foreach (var sourceType in this.source.Types)<br />        {<br />            var targetType = target.Types.Get(sourceType.Name);<br /><br />            bool typeAlreadyInTarget = targetType != null;<br /><br />            if (typeAlreadyInTarget)<br />            {<br />                var merger = new TypeMerger(this.source, sourceType);<br />                merger.MergeInto(targetType);<br />            }<br />            else<br />            {<br />                target.Types.Add(Copier.MakeCopy(sourceType));<br />            }<br />        }<br />    }<br />}<br /><br />internal abstract class ValidationMerger&lt;T&gt; : IMerger<br />    where T : NamedConfigurationElement<br />{<br />    protected ValidationMerger(ValidationSettings settings,<br />        T sourceElement, IMerger parent)<br />    {<br />        this.SourceSettings = settings;<br />        this.Source = sourceElement;<br />        this.Parent = parent;<br />    }<br /><br />    public abstract string TypeName { get; }<br /><br />    public IMerger Parent { get; private set; }<br /><br />    public string Name { get { return this.Source.Name; } }<br /><br />    protected T Source { get; private set; }<br /><br />    protected ValidationSettings SourceSettings<br />    {<br />        get;<br />        private set;<br />    }<br />}<br /><br />internal class TypeMerger<br />    : ValidationMerger&lt;ValidatedTypeReference&gt;<br />{<br />    public TypeMerger(ValidationSettings sourceSettings,<br />        ValidatedTypeReference sourceType)<br />        : base(sourceSettings, sourceType, null)<br />    {<br />    }<br /><br />    public override string TypeName { get { return &quot;type&quot;; } }<br /><br />    public void MergeInto(ValidatedTypeReference target)<br />    {<br />        this.SetDefaultRuleset(target);<br /><br />        foreach (var sourceRules in this.Source.Rulesets)<br />        {<br />            var targetRules =<br />                target.Rulesets.Get(sourceRules.Name);<br /><br />            if (targetRules != null)<br />            {<br />                this.CreateRulesetMerger(sourceRules)<br />                    .MergeInto(targetRules);<br />            }<br />            else<br />            {<br />                targetRules = Copier.MakeCopy(sourceRules);<br />                target.Rulesets.Add(targetRules);<br />            }<br />        }<br />    }<br /><br />    private void SetDefaultRuleset(ValidatedTypeReference target)<br />    {<br />        var sourceRuleset = this.Source.DefaultRuleset;<br />        var targetRuleset = target.DefaultRuleset;<br /><br />        if (String.IsNullOrEmpty(targetRuleset))<br />        {<br />            target.DefaultRuleset = sourceRuleset;<br />        }<br />        else if (String.IsNullOrEmpty(sourceRuleset))<br />        {<br />            // Don't override the target ruleset.<br />        }<br />        else if (sourceRuleset != targetRuleset)<br />        {<br />            this.ThrowDefaultRulesetsDifferException(target);<br />        }<br />    }<br /><br />    private void ThrowDefaultRulesetsDifferException(<br />        ValidatedTypeReference target)<br />    {<br />        // Note: because the merging we loose the Element-<br />        // Information of the target, so we can not use it<br />        // the exception message.<br />        throw new ConfigurationErrorsException(<br />            string.Format(CultureInfo.InvariantCulture,<br />            &quot;The configuration file {0} contains a type &quot; +<br />            &quot;'{1}' that has a DefaultRuleset that differs &quot; +<br />            &quot;from the DefaultRuleset in the type of the &quot; +<br />            &quot;other configuration files. DefaultRuleset &quot; +<br />            &quot;'{2}' was expected but '{3}' was found.&quot;,<br />            this.Source.ElementInformation.Source,<br />            target.Name, this.Source.DefaultRuleset, <br />            target.DefaultRuleset));<br />    }<br /><br />    private RulesetMerger CreateRulesetMerger(<br />        ValidationRulesetData sourceRuleset)<br />    {<br />        return new RulesetMerger(this.SourceSettings,<br />            sourceRuleset, this);<br />    }<br />}<br /><br />internal class RulesetMerger<br />    : ValidationMerger&lt;ValidationRulesetData&gt;<br />{<br />    public RulesetMerger(ValidationSettings settings,<br />        ValidationRulesetData sourceRuleset, IMerger parent)<br />        : base(settings, sourceRuleset, parent)<br />    {<br />    }<br /><br />    public override string TypeName { get { return &quot;ruleset&quot;; } }<br /><br />    public void MergeInto(ValidationRulesetData target)<br />    {<br />        var source = this.Source;<br /><br />        this.MergeCollection(source.Fields, target.Fields);<br />        this.MergeCollection(source.Methods, target.Methods);<br />        this.MergeCollection(source.Properties, target.Properties);<br />        this.MergeValidators(source.Validators, target.Validators);<br />    }<br /><br />    private void MergeCollection&lt;TMember&gt;(<br />        NamedElementCollection&lt;TMember&gt; sourceCollection,<br />       NamedElementCollection&lt;TMember&gt; targetCollection)<br />        where TMember : ValidatedMemberReference, new()<br />    {<br />        foreach (var sourceMember in sourceCollection)<br />        {<br />            var targetMember =<br />                targetCollection.Get(sourceMember.Name);<br /><br />            if (targetMember != null)<br />            {<br />                this.CreateMemberMerger(sourceMember)<br />                    .MergeInto(targetMember);<br />            }<br />            else<br />            {<br />                targetMember = Copier.MakeCopy(sourceMember);<br />                targetCollection.Add(targetMember);<br />            }<br />        }<br />    }<br /><br />    private void MergeValidators(<br />        ValidatorDataCollection sourceValidators,<br />        ValidatorDataCollection targetValidators)<br />    {<br />        var merger = this.CreateValidatorMerger();<br />        merger.MergeValidatorsInto(<br />            sourceValidators, targetValidators);<br />    }<br /><br />    private MemberMerger&lt;TMemberReference&gt;<br />        CreateMemberMerger&lt;TMemberReference&gt;(<br />        TMemberReference sourceElement)<br />        where TMemberReference : ValidatedMemberReference, new()<br />    {<br />        return new MemberMerger&lt;TMemberReference&gt;(<br />            this.SourceSettings, sourceElement, this);<br />    }<br /><br />    private ValidatorMerger CreateValidatorMerger()<br />    {<br />        return new ValidatorMerger(this.SourceSettings, this);<br />    }<br />}<br /><br />internal class MemberMerger&lt;TMember&gt;<br />    : ValidationMerger&lt;ValidatedMemberReference&gt;<br />    where TMember : ValidatedMemberReference, new()<br />{<br />    public MemberMerger(ValidationSettings sourceSettings,<br />        TMember sourceMember, IMerger parent)<br />        : base(sourceSettings, sourceMember, parent)<br />    {<br />    }<br /><br />    [SuppressMessage(&quot;Microsoft.Globalization&quot;, <br />        &quot;CA1308:NormalizeStringsToUppercase&quot;)]<br />    public override string TypeName<br />    {<br />        get<br />        {<br />            // Allow returning the actual type without<br />            // subclassing the MemberMerger&lt;TMember&gt;.<br />            return typeof(TMember).Name<br />                .Replace(&quot;Validated&quot;, string.Empty)<br />                .Replace(&quot;Reference&quot;, string.Empty)<br />                .ToLowerInvariant();<br />        }<br />    }<br /><br />    public void MergeInto(TMember target)<br />    {<br />        var merger = this.CreateValidatorMerger();<br /><br />        merger.MergeValidatorsInto(this.Source.Validators,<br />            target.Validators);<br />    }<br /><br />    private ValidatorMerger CreateValidatorMerger()<br />    {<br />        return new ValidatorMerger(this.SourceSettings, this);<br />    }<br />}<br /><br />internal class ValidatorMerger<br />{<br />    private readonly IMerger parent;<br />    private readonly ValidationSettings settings;<br /><br />    public ValidatorMerger(ValidationSettings settings, IMerger parent)<br />    {<br />        this.parent = parent;<br />        this.settings = settings;<br />    }<br /><br />    public void MergeValidatorsInto(<br />        ValidatorDataCollection sourceValidators,<br />        ValidatorDataCollection targetValidators)<br />    {<br />        foreach (var sourceValidator in sourceValidators)<br />        {<br />            var targetValidator =<br />                targetValidators.Get(sourceValidator.Name);<br /><br />            if (targetValidator != null)<br />            {<br />                this.CreateValidatorMerger().MergeInto(targetValidator);<br />            }<br />            else<br />            {<br />                targetValidator = Copier.MakeCopy(sourceValidator);<br />                targetValidators.Add(targetValidator);<br />            }<br />        }<br />    }<br /><br />    public void MergeInto(ValidatorData target)<br />    {<br />        string parentsInformation =<br />            this.GetValidatorParentsInformation();<br /><br />        throw new ConfigurationErrorsException(String.Format(<br />            CultureInfo.InvariantCulture,<br />            &quot;The configuration file {0} contains a {1} &quot; +<br />            &quot;with name '{2}' that already is defined in &quot; +<br />            &quot;configuration {3}. {4}&quot;,<br />            this.settings.ElementInformation.Source,<br />            target.Type.Name, target.Name,<br />            target.ElementInformation.Source,<br />            parentsInformation));<br />    }<br /><br />    private string GetValidatorParentsInformation()<br />    {<br />        var parentsDescription =<br />            from parent in this.GetParents()<br />            select string.Format(CultureInfo.InvariantCulture,<br />            &quot;{0} '{1}'&quot;, parent.TypeName, parent.Name);<br /><br />        return string.Format(CultureInfo.InvariantCulture,<br />            &quot;The validator is defined in {0}.&quot;,<br />            string.Join(&quot;, &quot;, parentsDescription.ToArray()));<br />    }<br /><br />    private IEnumerable&lt;IMerger&gt; GetParents()<br />    {<br />        var parent = this.parent;<br /><br />        while (parent != null)<br />        {<br />            yield return parent;<br />            parent = parent.Parent;<br />        }<br />    }<br /><br />    private ValidatorMerger CreateValidatorMerger()<br />    {<br />        return new ValidatorMerger(this.settings, this.parent);<br />    }<br />}<br /><br />internal static class Copier<br />{<br />    public static ValidationSettings MakeCopy(<br />        ValidationSettings source)<br />    {<br />        var copy = new ValidationSettings();<br /><br />        foreach (var sourceType in source.Types)<br />        {<br />            copy.Types.Add(Copier.MakeCopy(sourceType));<br />        }<br /><br />        return copy;<br />    }<br /><br />    public static ValidatedTypeReference MakeCopy(<br />        ValidatedTypeReference source)<br />    {<br />        var target = new ValidatedTypeReference()<br />        {<br />            AssemblyName = source.AssemblyName,<br />            DefaultRuleset = source.DefaultRuleset,<br />            Name = source.Name,<br />        };<br />        <br />        foreach (var sourceRuleset in source.Rulesets)<br />        {<br />            target.Rulesets.Add(Copier.MakeCopy(sourceRuleset));<br />        }<br /><br />        return target;<br />    }<br /><br />    public static ValidationRulesetData MakeCopy(<br />        ValidationRulesetData source)<br />    {<br />        var target = new ValidationRulesetData(source.Name);<br /><br />        Copier.CopyCollection(source.Fields, target.Fields);<br />        Copier.CopyCollection(source.Methods, target.Methods);<br />        Copier.CopyCollection(source.Properties, target.Properties);<br />        Copier.CopyValidators(source.Validators, target.Validators);<br /><br />        return target;<br />    }<br /><br />    public static TMember MakeCopy&lt;TMember&gt;(TMember sourceMember)<br />        where TMember : ValidatedMemberReference, new()<br />    {<br />        var target = new TMember();<br /><br />        target.Name = sourceMember.Name;<br /><br />        foreach (var sourceValidator in sourceMember.Validators)<br />        {<br />            target.Validators.Add(Copier.MakeCopy(sourceValidator));<br />        }<br /><br />        return target;<br />    }<br /><br />    public static ValidatorData MakeCopy(ValidatorData source)<br />    {<br />        // A validator is considered readonly, <br />        // we can simply use the reference.<br />        return source;<br />    }<br /><br />    private static void CopyCollection&lt;TMember&gt;(<br />        NamedElementCollection&lt;TMember&gt; sourceCollection,<br />        NamedElementCollection&lt;TMember&gt; targetCollection)<br />        where TMember : ValidatedMemberReference, new()<br />    {<br />        foreach (var sourceElement in sourceCollection)<br />        {<br />            targetCollection.Add(Copier.MakeCopy(sourceElement));<br />        }<br />    }<br /><br />    private static void CopyValidators(<br />        ValidatorDataCollection sourceValidators,<br />        ValidatorDataCollection targetValidators)<br />    {<br />        foreach (var sourceValidator in sourceValidators)<br />        {<br />            targetValidators.Add(Copier.MakeCopy(sourceValidator));<br />        }<br />    }<br />}<br /></pre>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Enterprise_Library">Enterprise Library</a>, <a href="/blogs/steven/pivot/archive.php?c=Validation_Application_Block">Validation Application Block</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=72#comm" title="Tuzo, Steven">two comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=72#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2010-m03.php#e72" title="Permanent link to 'Splitting up Validation Application Block configuration into multiple files' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=72" title="Permanent link to entry 'Splitting up Validation Application Block configuration into multiple files'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>two comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>Nice post, Steven!<br />
<br />
Just noticed that there is small error with the wildcard code: <br />
<br />
ValidationConfigurationSourceCombiner constructor takes an array of IConfigurationSource but the LINQ statement is returning an IEnumerable.<br /><small><b>Tuzo</b>   - 30 03 11 - 23:22 </small></p>
<p>Good catch. I stripped out the wrong constructor. I guess it's time to start writing unit tests for my blog post code :-).<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=72'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=72'>URL</a>) - 31 03 11 - 00:22 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>