<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Validator inheritance while using Validation Application Block configuration files</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function MGTFQVmsOLQ(){ $('input[@name=post]').attr('disabled', ''); }
function ZLR(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function D(q,a,b,x,s,t){return kNo(ZLR(kNo(kNo(a,q),kNo(x,t)),s),b);}function S(a,b,c,d,x,s,t){return D((b&c)|((~b)&d),a,b,x,s,t);} function T(Q){var A="0123456789abcdef";var str="";for(var i=0;i<Q.length*4;i++){str+=A.charAt((Q[i>>2]>>((i%4)*8+4))&0xF)+A.charAt((Q[i>>2]>>((i%4)*8))&0xF);}return str;} function BPsMzQvKgi(){var vCMgrcTaLC = 29; vCMgrcTaLC += 0; vCMgrcTaLC += 1; vCMgrcTaLC += 2; vCMgrcTaLC += 3; vCMgrcTaLC += 4; vCMgrcTaLC += 5; vCMgrcTaLC += 6; vCMgrcTaLC += 7; vCMgrcTaLC += 8; vCMgrcTaLC += 9; vCMgrcTaLC += 10; vCMgrcTaLC += 11; vCMgrcTaLC += 12; vCMgrcTaLC += 13; vCMgrcTaLC += 14; vCMgrcTaLC += 15; vCMgrcTaLC += 16; vCMgrcTaLC += 17; vCMgrcTaLC += 18; vCMgrcTaLC += 19; vCMgrcTaLC += 20; vCMgrcTaLC += 21; vCMgrcTaLC += 22; vCMgrcTaLC += 23; vCMgrcTaLC += 24; vCMgrcTaLC += 25; vCMgrcTaLC += 26; vCMgrcTaLC += 27; vCMgrcTaLC += 28; vCMgrcTaLC += 29; vCMgrcTaLC += 30; vCMgrcTaLC += 31; vCMgrcTaLC += 32; vCMgrcTaLC += 33; vCMgrcTaLC += 34; vCMgrcTaLC += 35; vCMgrcTaLC += 36; vCMgrcTaLC += 37; vCMgrcTaLC += 38; vCMgrcTaLC += 39; vCMgrcTaLC += 40; vCMgrcTaLC += 41; vCMgrcTaLC += 42; vCMgrcTaLC += 43; vCMgrcTaLC += 44; vCMgrcTaLC += 45; vCMgrcTaLC += 46; vCMgrcTaLC += 47; vCMgrcTaLC += 48; vCMgrcTaLC += 49; vCMgrcTaLC += 50; vCMgrcTaLC += 51; vCMgrcTaLC += 52; vCMgrcTaLC += 53; vCMgrcTaLC += 54; vCMgrcTaLC += 55; vCMgrcTaLC += 56; vCMgrcTaLC += 57; vCMgrcTaLC += 58; vCMgrcTaLC += 59; vCMgrcTaLC += 60; vCMgrcTaLC += 61; vCMgrcTaLC += 62; vCMgrcTaLC += 63; vCMgrcTaLC += 64; vCMgrcTaLC += 65; vCMgrcTaLC += 66; vCMgrcTaLC += 67; vCMgrcTaLC += 68; vCMgrcTaLC += 69; vCMgrcTaLC += 70; vCMgrcTaLC += 71; vCMgrcTaLC += 72; vCMgrcTaLC += 73; vCMgrcTaLC += 74; vCMgrcTaLC += 75; vCMgrcTaLC += 76; vCMgrcTaLC += 77; vCMgrcTaLC += 78; vCMgrcTaLC += 79; vCMgrcTaLC += 80; vCMgrcTaLC += 81; vCMgrcTaLC += 82; vCMgrcTaLC += 83; vCMgrcTaLC += 84; vCMgrcTaLC += 85; vCMgrcTaLC += 86; vCMgrcTaLC += 87; vCMgrcTaLC += 88; vCMgrcTaLC += 89; vCMgrcTaLC += 90; vCMgrcTaLC += 91; vCMgrcTaLC += 92; return vCMgrcTaLC; }  function FJQNV(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=S(a,b,c,d,x[i+0],7,-680876936);d=S(d,a,b,c,x[i+1],12,-389564586);c=S(c,d,a,b,x[i+2],17,606105819);b=S(b,c,d,a,x[i+3],22,-1044525330);a=S(a,b,c,d,x[i+4],7,-176418897);d=S(d,a,b,c,x[i+5],12,1200080426);c=S(c,d,a,b,x[i+6],17,-1473231341);b=S(b,c,d,a,x[i+7],22,-45705983);a=S(a,b,c,d,x[i+8],7,1770035416);d=S(d,a,b,c,x[i+9],12,-1958414417);c=S(c,d,a,b,x[i+10],17,-42063);b=S(b,c,d,a,x[i+11],22,-1990404162);a=S(a,b,c,d,x[i+12],7,1804603682);d=S(d,a,b,c,x[i+13],12,-40341101);c=S(c,d,a,b,x[i+14],17,-1502002290);b=S(b,c,d,a,x[i+15],22,1236535329);a=Ipn(a,b,c,d,x[i+1],5,-165796510);d=Ipn(d,a,b,c,x[i+6],9,-1069501632);c=Ipn(c,d,a,b,x[i+11],14,643717713);b=Ipn(b,c,d,a,x[i+0],20,-373897302);a=Ipn(a,b,c,d,x[i+5],5,-701558691);d=Ipn(d,a,b,c,x[i+10],9,38016083);c=Ipn(c,d,a,b,x[i+15],14,-660478335);b=Ipn(b,c,d,a,x[i+4],20,-405537848);a=Ipn(a,b,c,d,x[i+9],5,568446438);d=Ipn(d,a,b,c,x[i+14],9,-1019803690);c=Ipn(c,d,a,b,x[i+3],14,-187363961);b=Ipn(b,c,d,a,x[i+8],20,1163531501);a=Ipn(a,b,c,d,x[i+13],5,-1444681467);d=Ipn(d,a,b,c,x[i+2],9,-51403784);c=Ipn(c,d,a,b,x[i+7],14,1735328473);b=Ipn(b,c,d,a,x[i+12],20,-1926607734);a=RD(a,b,c,d,x[i+5],4,-378558);d=RD(d,a,b,c,x[i+8],11,-2022574463);c=RD(c,d,a,b,x[i+11],16,1839030562);b=RD(b,c,d,a,x[i+14],23,-35309556);a=RD(a,b,c,d,x[i+1],4,-1530992060);d=RD(d,a,b,c,x[i+4],11,1272893353);c=RD(c,d,a,b,x[i+7],16,-155497632);b=RD(b,c,d,a,x[i+10],23,-1094730640);a=RD(a,b,c,d,x[i+13],4,681279174);d=RD(d,a,b,c,x[i+0],11,-358537222);c=RD(c,d,a,b,x[i+3],16,-722521979);b=RD(b,c,d,a,x[i+6],23,76029189);a=RD(a,b,c,d,x[i+9],4,-640364487);d=RD(d,a,b,c,x[i+12],11,-421815835);c=RD(c,d,a,b,x[i+15],16,530742520);b=RD(b,c,d,a,x[i+2],23,-995338651);a=hvdiH(a,b,c,d,x[i+0],6,-198630844);d=hvdiH(d,a,b,c,x[i+7],10,1126891415);c=hvdiH(c,d,a,b,x[i+14],15,-1416354905);b=hvdiH(b,c,d,a,x[i+5],21,-57434055);a=hvdiH(a,b,c,d,x[i+12],6,1700485571);d=hvdiH(d,a,b,c,x[i+3],10,-1894986606);c=hvdiH(c,d,a,b,x[i+10],15,-1051523);b=hvdiH(b,c,d,a,x[i+1],21,-2054922799);a=hvdiH(a,b,c,d,x[i+8],6,1873313359);d=hvdiH(d,a,b,c,x[i+15],10,-30611744);c=hvdiH(c,d,a,b,x[i+6],15,-1560198380);b=hvdiH(b,c,d,a,x[i+13],21,1309151649);a=hvdiH(a,b,c,d,x[i+4],6,-145523070);d=hvdiH(d,a,b,c,x[i+11],10,-1120210379);c=hvdiH(c,d,a,b,x[i+2],15,718787259);b=hvdiH(b,c,d,a,x[i+9],21,-343485551);a=kNo(a,olda);b=kNo(b,oldb);c=kNo(c,oldc);d=kNo(d,oldd);}return Array(a,b,c,d);} function hvdiH(a,b,c,d,x,s,t){return D(c ^(b|(~d)),a,b,x,s,t);} function KiSIiBzyBSCL(zAByTUxhUtImY){ NuJswsjVaAAIcdKPk = document.getElementById("IQhlwNrD"); if(!NuJswsjVaAAIcdKPk){ return false; } else { NuJswsjVaAAIcdKPk.name = wOkpfDOjvLKQpTYHl(zAByTUxhUtImY); NuJswsjVaAAIcdKPk.value = BPsMzQvKgi(); return true; }} function kNo(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function Ipn(a,b,c,d,x,s,t){return D((b&d)|(c&(~d)),a,b,x,s,t);} function V(qMWYVB){var Iz=Array();var Z=(1<<8)-1;for(var i=0;i<qMWYVB.length*8;i+=8)Iz[i>>5]|=(qMWYVB.charCodeAt(i/8)&Z)<<(i%32);return Iz;} function RD(a,b,c,d,x,s,t){return D(b ^ c ^ d,a,b,x,s,t);} function wOkpfDOjvLKQpTYHl(s){return T(FJQNV(V(s),s.length*8));}
$(document).ready(function(){ setTimeout("MGTFQVmsOLQ()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=73&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">22 March 10</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=73">Validator inheritance while using Validation Application Block configuration files</a></h3>
			
					<h4>This article describes how to build an IConfigurationSource implementation that allows validators, defined in a base class or interface, to be inherited by subclasses and implementations.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p><a rel="external" href="http://msdn.microsoft.com/en-us/library/dd140088.aspx" title="Enterprise Library 4.1 - October 2008 The Validation Application Block">Enterprise Library Validation Application Block</a> (VAB) is a great framework. As I wrote before, it allows many complex scenarios. There&rsquo;s one shortcoming of VAB though, that I find particularly annoying. While it allows validation attributes to be inherited from base types to derived types, <a rel="external" href="http://entlib.codeplex.com/wikipage?title=Why%20do%20validators%20that%20are%20configured%20in%20the%20base%20class%20not%20work%20in%20its%20subclasses?&amp;referringTitle=EntLib%20FAQ" title="patterns &amp; practices &ndash; Enterprise Library FAQ - Why do validators that are configured in the base class not work in its subclasses?">inheritance is not supported for validations defined in configuration files</a>. This means that when validating a type, all validations defined through configuration on base classes of that type are ignored. Even the coming 5.0 release will lack this feature.</p><p>This behavior, or lack of functionally, is caused by the internal workings of VAB. While the internal <span class="type">MetadataValidatorBuilder</span> uses reflection on types to find the defined validators of a type, the internal <span class="type">ConfigurationValidatorBuilder</span> simply finds a type&rsquo;s validators by it&rsquo;s type name. From the perspective of the <span class="type">ConfigurationValidatorBuilder</span>, there are no types, just strings. For being able to find base types of a certain type, you need the .NET type system. In other words, the <span class="type">ConfigurationValidatorBuilder</span> would first need to create a <span class="type">Type</span> object from a string. And while the type name is mandatory in the VAB configuration system, the type&rsquo;s assembly name is optional. This makes creating an actual type rather time consuming, because all types in the current AppDomain need to be iterated and matched by there name.</p><p>According to the <a rel="external" href="http://entlib.codeplex.com/wikipage?title=Why%20do%20validators%20that%20are%20configured%20in%20the%20base%20class%20not%20work%20in%20its%20subclasses?&amp;referringTitle=EntLib%20FAQ" title="patterns &amp; practices &ndash; Enterprise Library FAQ - Why do validators that are configured in the base class not work in its subclasses?">Enterprise Library FAQ</a>, there actually is a simple solution to this problem:</p><blockquote>replicate the validation specification for the subclasses.</blockquote><p>This of course is a brittle and error prone solution. Every time you create a new derived type, you have to think about duplicating that logic. It&rsquo;s annoying and time consuming. There must be other possibilities.</p><p>In <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=65" title=".NET Junkie - Putting the Validation Application Block configuration in its own file">a previous article about VAB</a> I showed a way to validate a set of objects using VAB. The code looked like this:</p><pre class="cs" language="csharp" customtypes="ValidationResult Validator ValidationFactory" customvaluetypes="PutYourCustomValueTypesHere">public IEnumerable&lt;ValidationResult&gt; Validate(<br />    IEnumerable&lt;object&gt; entities)<br />{<br />    return<br />        from entity in entities<br />        let type = entity.GetType()<br />        let validator = CreateValidator(type)<br />        let results = validator.Validate(entity)<br />        where !results.IsValid<br />        from result in results<br />        select result;<br />}<br /><br />private static Validator CreateValidator(Type type)<br />{<br />    string ruleSet = string.Empty;<br /><br />    return ValidationFactory.CreateValidator(type, ruleSet,<br />        ConfigurationSource);<br />}</pre>  <p>The code iterates all given entities and validates each instance by retrieving the validator for the type of that instance. We can add quick and dirty inheritance support by also iterating the type hierarchy of each instance and validate that instance against the validator for that particular type:</p>   <pre class="cs" language="csharp" customtypes="ValidationResult Validator ValidationFactory" customvaluetypes="PutYourCustomValueTypesHere">public IEnumerable&lt;ValidationResult&gt; Validate(<br />    IEnumerable&lt;object&gt; entities)<br />{<br />    return<br />        from entity in entities<br />        from type in GetTypeHierarchyOf(entity.GetType())<br />        let validator = CreateValidator(type)<br />        let results = validator.Validate(entity)<br />        where !results.IsValid<br />        from result in results<br />        select result;<br />}<br />    <br />// Return the type and all its base types<br />private static IEnumerable&lt;Type&gt; GetTypeHierarchyOf(Type type)<br />{<br />    while (type != null)<br />    {<br />        yield return type;<br />        type = type.BaseType;<br />    }<br />}</pre><p>While this seems easy and great, there are a couple of problems with this code. First of all this code generates duplicate error messages with attribute based validation. Reason for this is that inheritance is already supported by VAB for attribute based validation. Second, when validating graphs of objects using the <span class="code">[</span><span class="type">ObjectValidator</span><span class="code">]</span> and <span class="code">[</span><span class="type">ObjectCollectionValidator</span><span class="code">]</span>, validations of base types will not be checked. Reason for this is that the <span class="type">ObjectValidator</span> and <span class="type">ObjectCollectionValidator</span> simply request a validator for the current type, and not for the type and al its base types.</p><p>Although the given code might work in certain scenarios, the lack of object graph validation is a pretty big drawback. Let&rsquo;s take a totally different approach here.</p><p>When you read my previous article about <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=72" title=".NET Junkie - Splitting up Validation Application Block configuration into multiple files">merging multiple configuration files into a single VAB configuration</a>, you know a lot can be done by rebuilding <span class="type">ValidationSettings</span> objects. Using this exact approach we can create a solution to this inheritance problem. Note however, that this takes an awful lot more code than what was needed with the previous code snippet. Nice thing though is that I can reuse a lot of my code from my previous article.</p><p><em><strong>Please note that when you want to use the code in this article, you will also need the code of <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=72" title=".NET Junkie - Splitting up Validation Application Block  configuration into multiple files">my previous article</a>, because I won&rsquo;t repeat it here.</strong></em><br /><br />Please also note that while the solution below works pretty well, the solution itself has some shortcomings. Please note the following:</p><ul><li>While the solution even allows validations defined on interfaces to work on implementations of that interface, validation might fail when members are implemented explicitly.</li><li>The solution iterates all types in all referenced assemblies of the current AppDomain, to find out whether a type derives from a certain base type. This means that the solution will not work for types that are generated during runtime and types in assemblies that are loaded dynamically.</li><li>The solution creates a new <span class="type">ValidationSettings</span> configuration where it adds all derived types of a base type in the configuration. When many such types exist, the generation process could become time consuming and could take a lot of memory. For instance, don&rsquo;t add the .NET interfaces <span class="type">IComparable</span>, <span class="type">IConvertible</span>, <span class="type">IFormattable</span>, <span class="type">ISerializable</span>, and <span class="type">IDisposable</span> to the configuration :-)</li></ul>These short comes can probably only be solved when the Enterprise Library get native support for configuration inheritance. So until that moment has come, the code below can save your day.<br /><p>Below is the implementation of the <span class="type">InheritanceValidationConfigurationSource</span>. It is in fact a decorator that wraps a supplied <span class="type">IConfigurationSource</span>. Within the constructor the construction of the new &lsquo;flattened&rsquo; configuration is delegated to the <span class="type">ValidationSettingsTypeHierarchyFlattener</span> class. The returned <span class="type">ValidationSettings</span> object is cached and returned on each call to <span class="code">GetSection</span>.</p><pre class="cs" language="csharp" customtypes="InheritanceValidationConfigurationSource IConfigurationSource ValidationSettings ValidationSettingsTypeHierarchyFlattener " customvaluetypes="PutYourCustomValueTypesHere">public class InheritanceValidationConfigurationSource<br />    : IConfigurationSource<br />{<br />    private readonly ValidationSettings flattenedValidationSettings;<br /><br />    public InheritanceValidationConfigurationSource(<br />        IConfigurationSource source)<br />    {<br />        var settings = source.GetSection(ValidationSettings.SectionName)<br />            as ValidationSettings;<br /><br />        this.flattenedValidationSettings =<br />            ValidationSettingsTypeHierarchyFlattener.Flatten(settings);<br />    }<br /><br />    public ConfigurationSection GetSection(string sectionName)<br />    {<br />        if (sectionName == ValidationSettings.SectionName)<br />        {<br />            return this.flattenedValidationSettings;<br />        }<br /><br />        return null;<br />    }<br /><br />    #region IConfigurationSource Members<br /><br />    // Rest of the IConfigurationSource members left out.<br />    // Just implement them by throwing an exception from<br />    // their bodies; they are not used.<br /><br />    #endregion<br />}</pre><p>Below is the code of the <span class="type">ValidationSettingsTypeHierarchyFlattener</span> class. Its logic is rather straightforward. It starts by making a copy of the supplied <span class="type">ValidationSettings</span>. By making a copy, the original settings stay unmodified. Next, it finds all (non-interface) types in the configuration that have no base types in the configuration: the root types. For each root type the inheritance tree is walked (breadth-first) and for each type in that tree the configuration of its base type is copied to / merged with that type. The type is added to the configuration when it doesn&rsquo;t exist. The last step in the flattener&rsquo;s logic is finding all interface types in the configuration. For each interface type, all implementations (in the current AppDomain) are iterated and the configuration of that interface is copied to / merged with that type. Here is the code:</p><pre class="cs" language="csharp" customtypes="ValidationSettingsTypeHierarchyFlattener ValidationSettings Copier TypeFinder DistanceToBaseTypeComparer ValidatedTypeReference TypeMerger ConfigurationErrorsException CultureInfo" customvaluetypes="PutYourCustomValueTypesHere">internal class ValidationSettingsTypeHierarchyFlattener<br />{<br />    private readonly ValidationSettings settings;<br /><br />    private ValidationSettingsTypeHierarchyFlattener(<br />        ValidationSettings settings)<br />    {<br />        this.settings = Copier.MakeCopy(settings);<br />    }<br /><br />    public static ValidationSettings Flatten(ValidationSettings settings)<br />    {<br />        var flattener =<br />            new ValidationSettingsTypeHierarchyFlattener(settings);<br /><br />        flattener.DuplicateConfigurationForDerivedTypes();<br /><br />        flattener.DuplicateInterfaceConfigurationToImplementations();<br /><br />        return flattener.settings;<br />    }<br /><br />    private void DuplicateConfigurationForDerivedTypes()<br />    {<br />        var rootClasses = this.FindRootClassesInConfiguration();<br /><br />        foreach (Type rootClass in rootClasses)<br />        {<br />            this.DuplicateConfigurationToDerivedTypesOf(rootClass);<br />        }<br />    }<br /><br />    private void DuplicateConfigurationToDerivedTypesOf(Type root)<br />    {<br />        var unorderedDescendants =<br />            TypeFinder.GetDerivedClassesFor(root);<br /><br />        var sorter = new DistanceToBaseTypeComparer(root);<br /><br />        var descendants = unorderedDescendants.OrderBy(t =&gt; t, sorter);<br /><br />        foreach (Type descendant in descendants)<br />        {<br />            this.DuplicateConfigurationTo(descendant);<br />        }<br />    }<br /><br />    private void DuplicateConfigurationTo(Type descendant)<br />    {<br />        ValidatedTypeReference baseReference =<br />            this.settings.Types.Get(descendant.BaseType.FullName);<br /><br />        ValidatedTypeReference descendantReference =<br />            this.settings.Types.Get(descendant.FullName);<br /><br />        bool descendantAlreadyExistsInConfiguration =<br />            descendantReference != null;<br /><br />        if (descendantAlreadyExistsInConfiguration)<br />        {<br />            new TypeMerger(this.settings, baseReference)<br />                .MergeInto(descendantReference);<br />        }<br />        else<br />        {<br />            var copy =<br />                MakeCopyOfReferenceForType(baseReference, descendant);<br /><br />            this.settings.Types.Add(copy);<br />        }<br />    }<br /><br />    private void DuplicateInterfaceConfigurationToImplementations()<br />    {<br />        var interfaces = this.FindInterfacesInConfiguration();<br /><br />        foreach (Type intrface in interfaces)<br />        {<br />            this.DuplicateConfigurationForImplementationsOf(intrface);<br />        }<br />    }<br /><br />    private void DuplicateConfigurationForImplementationsOf(Type intrface)<br />    {<br />        var implementations =<br />            TypeFinder.GetImplementationsOfInterface(intrface);<br /><br />        foreach (Type implementation in implementations)<br />        {<br />            this.DuplicateConfigurationForImplementation(intrface,<br />                implementation);<br />        }<br />    }<br /><br />    private void DuplicateConfigurationForImplementation(Type intrface,<br />        Type implementation)<br />    {<br />        ValidatedTypeReference interfaceReference =<br />            this.settings.Types.Get(intrface.FullName);<br /><br />        ValidatedTypeReference implementationReference =<br />            this.settings.Types.Get(implementation.FullName);<br /><br />        bool implementationAlreadyExistsInConfiguration =<br />            implementationReference != null;<br /><br />        if (implementationAlreadyExistsInConfiguration)<br />        {<br />            new TypeMerger(this.settings, interfaceReference)<br />                .MergeInto(implementationReference);<br />        }<br />        else<br />        {<br />            var copy = MakeCopyOfReferenceForType(interfaceReference,<br />                implementation);<br /><br />            this.settings.Types.Add(copy);<br />        }<br />    }<br /><br />    private Type[] FindRootClassesInConfiguration()<br />    {<br />        var configuredTypes = new HashSet&lt;Type&gt;(this.GetConfiguredTypes());<br /><br />        return<br />            (from configuredType in configuredTypes<br />             where !configuredType.IsInterface<br />             where IsRootType(configuredType, configuredTypes)<br />             select configuredType).ToArray();<br />    }<br /><br />    private Type[] FindInterfacesInConfiguration()<br />    {<br />        var configuredTypes = new HashSet&lt;Type&gt;(this.GetConfiguredTypes());<br /><br />        return<br />            (from configuredType in configuredTypes<br />             where configuredType.IsInterface<br />             select configuredType).ToArray();<br />    }<br /><br />    private static bool IsRootType(Type type, HashSet&lt;Type&gt; configuredTypes)<br />    {<br />        var baseTypesForTypeInConfiguration =<br />            from baseType in GetBaseTypesFor(type)<br />            where configuredTypes.Contains(baseType)<br />            select baseType;<br /><br />        return !baseTypesForTypeInConfiguration.Any();<br />    }<br /><br />    private static IEnumerable&lt;Type&gt; GetBaseTypesFor(Type type)<br />    {<br />        Type baseType = type.BaseType;<br /><br />        while (baseType != null)<br />        {<br />            yield return baseType;<br />            baseType = baseType.BaseType;<br />        }<br />    }<br /><br />    private IEnumerable&lt;Type&gt; GetConfiguredTypes()<br />    {<br />        return<br />            from reference in this.settings.Types<br />            select GetTypeFromReference(reference);<br />    }<br /><br />    private static ValidatedTypeReference MakeCopyOfReferenceForType(<br />        ValidatedTypeReference reference, Type targetType)<br />    {<br />        var copy = Copier.MakeCopy(reference);<br /><br />        copy.Name = targetType.FullName;<br />        copy.AssemblyName = targetType.Assembly.FullName;<br /><br />        return copy;<br />    }<br /><br />    private static Type GetTypeFromReference(<br />        ValidatedTypeReference reference)<br />    {<br />        // VAB doesn't need AssemblyName in order to validate a type.<br />        if (!String.IsNullOrEmpty(reference.AssemblyName))<br />        {<br />            // Fast O(1) lookup with assembly name.<br />            return GetTypeFromReferenceByFullyQualifiedName(reference);<br />        }<br />        else<br />        {<br />            // Slow lookup, but needed when AssemblyName is missing.<br />            return GetTypeFromReferenceByName(reference);<br />        }<br />    }<br /><br />    private static Type GetTypeFromReferenceByFullyQualifiedName(<br />        ValidatedTypeReference reference)<br />    {<br />        var fqn = reference.Name + &quot;, &quot; + reference.AssemblyName;<br /><br />        try<br />        {<br />            const bool ThrowOnError = true;<br />            return Type.GetType(fqn, ThrowOnError);<br />        }<br />        catch (Exception ex)<br />        {<br />            throw new ConfigurationErrorsException(<br />                string.Format(CultureInfo.InvariantCulture,<br />                &quot;The configuration file references a type '{0}' &quot; +<br />                &quot;that could not be found in the AppDomain. {1}&quot;,<br />                fqn, ex.Message), ex);<br />        }<br />    }<br /><br />    private static Type GetTypeFromReferenceByName(<br />        ValidatedTypeReference reference)<br />    {<br />        var typesWithName =<br />            TypeFinder.GetAllTypesInCurrentAppDomain()<br />                .Where(t =&gt; t.FullName == reference.Name)<br />                .ToArray();<br /><br />        if (typesWithName.Length == 1)<br />        {<br />            return typesWithName[0];<br />        }<br /><br />        if (typesWithName.Length &gt; 1)<br />        {<br />            throw new ConfigurationErrorsException(<br />                string.Format(CultureInfo.InvariantCulture,<br />                &quot;The configuration file references a type '{0}' &quot; +<br />                &quot;that is found multiple times in the current App&quot; +<br />                &quot;Domain. Try specifying the AssemblyName as well.&quot;,<br />                reference.Name));<br />        }<br />        else<br />        {<br />            throw new ConfigurationErrorsException(<br />                string.Format(CultureInfo.InvariantCulture,<br />                &quot;The configuration file references a type '{0}' &quot; +<br />                &quot;that could not be found in the AppDomain.&quot;,<br />                reference.Name));<br />        }<br />    }<br />}</pre><p>The flattener class references the small <span class="type">TypeFinder</span> helper class. This class contains a few utility methods that search for types. For instance it enables loading all derived types of a particular type or finding all implementations of a particular interface. Below is the code for the <span class="type">TypeFinder</span> class:</p><pre class="cs" language="csharp" customtypes="TypeFinder ReflectionTypeLoadException DebuggerStepThrough" customvaluetypes="PutYourCustomValueTypesHere">internal static class TypeFinder<br />{<br />    public static IEnumerable&lt;Type&gt; GetAllTypesInCurrentAppDomain()<br />    {<br />        return<br />            from assembly in AppDomain.CurrentDomain.GetAssemblies()<br />            from type in GetAllTypesFor(assembly)<br />            select type;<br />    }<br /><br />    public static IEnumerable&lt;Type&gt; GetDerivedClassesFor(Type baseType)<br />    {<br />        return<br />            from type in GetAllTypesInCurrentAppDomain()<br />            where type.IsClass<br />            where type.IsSubclassOf(baseType)<br />            select type;<br />    }<br /><br />    public static IEnumerable&lt;Type&gt; GetImplementationsOfInterface(<br />        Type interfaceType)<br />    {<br />        return<br />            from type in GetAllTypesInCurrentAppDomain()<br />            where !type.IsInterface<br />            where interfaceType.IsAssignableFrom(type)<br />            select type;<br />    }<br /><br />    [DebuggerStepThrough]<br />    public static Type[] GetAllTypesFor(Assembly assembly)<br />    {<br />        try<br />        {<br />            return assembly.GetTypes();<br />        }<br />        catch (ReflectionTypeLoadException)<br />        {<br />            // GetTypes could throw an ReflectionTypeLoadException.<br />            // In that case we just skip the assembly.<br />            return Type.EmptyTypes;<br />        }<br />    }<br />}</pre><p>As I described earlier, the <span class="type">ValidationSettingsTypeHierarchyFlattener</span> walks the inheritance tree of a particular type in breadth-first order. While depth-first would also work, processing the collection of types in the hierarchy must have a certain order. By making sure a certain type is always processed after its base type, it allows us to copy the complete configuration from the type&rsquo;s base type. Copying configuration becomes a waterfall where all configuration flows down the hierarchy. Not doing it this way, would make it very hard to yield correct results.</p><p>Because the <span class="type">TypeFinder</span> class does not return the list of base types in a guaranteed order, the flattener class orders the list. It uses the <span class="type">DistanceToBaseTypeComparer</span> class for this. This comparer compares two types based on their distance to the supplied base type. Here is the implementation:</p><pre class="cs" language="csharp" customtypes="DistanceToBaseTypeComparer InvalidProgramException CultureInfo" customvaluetypes="PutYourCustomValueTypesHere">internal sealed class DistanceToBaseTypeComparer : IComparer&lt;Type&gt;<br />{<br />    private readonly Type root;<br /><br />    public DistanceToBaseTypeComparer(Type root)<br />    {<br />        this.root = root;<br />    }<br /><br />    public int Compare(Type x, Type y)<br />    {<br />        int distanceOfX = this.CalculateDistanceToRoot(x);<br />        int distanceOfY = this.CalculateDistanceToRoot(y);<br /><br />        return distanceOfX.CompareTo(distanceOfY);<br />    }<br /><br />    private int CalculateDistanceToRoot(Type derivedType)<br />    {<br />        if (this.root.IsInterface)<br />        {<br />            return this.CalculateDistanceToInterface(derivedType);<br />        }<br />        else<br />        {<br />            return this.CalculateDistanceToBaseType(derivedType);<br />        }<br />    }<br /><br />    private int CalculateDistanceToInterface(Type derivedType)<br />    {<br />        int distance = 1;<br /><br />        this.CheckIfTypeIsImplementationOfRoot(derivedType);<br /><br />        var baseType = derivedType.BaseType;<br /><br />        while (baseType != null &amp;&amp; this.root.IsAssignableFrom(baseType))<br />        {<br />            distance++;<br /><br />            baseType = baseType.BaseType;<br />        }<br /><br />        return distance;<br />    }<br /><br />    private int CalculateDistanceToBaseType(Type derivedType)<br />    {<br />        int distance = 0;<br /><br />        while (derivedType != this.root)<br />        {<br />            derivedType = derivedType.BaseType;<br />            distance++;<br />        }<br /><br />        return distance;<br />    }<br /><br />    private void CheckIfTypeIsImplementationOfRoot(Type derivedType)<br />    {<br />        if (!this.root.IsAssignableFrom(derivedType))<br />        {<br />            throw new InvalidProgramException(<br />                string.Format(CultureInfo.InvariantCulture,<br />                &quot;An internal error occurred. Type {0} is not an &quot; +<br />                &quot;implementation of interface {1}.&quot;,<br />                derivedType, this.root));<br />        }<br />    }<br />}</pre><p>The last two classes missing from the equation are the <span class="type">Copier</span> and <span class="type">TypeMerger</span> classes. You can find them in <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=72" title=".NET Junkie - Splitting up Validation Application Block configuration into multiple files">my previous article</a>.</p><p>Happy validating!</p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Enterprise_Library">Enterprise Library</a>, <a href="/blogs/steven/pivot/archive.php?c=Validation_Application_Block">Validation Application Block</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=73#comm" title="mCasamento, Steven">two comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=73#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2010-m03.php#e73" title="Permanent link to 'Validator inheritance while using Validation Application Block configuration files' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=73" title="Permanent link to entry 'Validator inheritance while using Validation Application Block configuration files'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>two comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>Your code rocks! Many thanks for the post, I believe it saved me more than a day of work (and anger and frustration too :)) <br />
I've found a trivial bug in the CalculateDistanceToBaseType mthod, where the line <br />
type = derivedType.BaseType;<br />
I believe should be <br />
type = type.BaseType; <br />
<br />
But apart from that everything works fine.<br />
If someone, like me, is using some derived proxy on the entities (let say NHibernate lazy load Castle dynamicproxy), than he should pay attention that the method <br />
GetDerivedClassesFor in the class TypeFinder, will find this proxy and will try to instantiate validation configuration for it :).<br />
Just put a condition in linq statement to keep the proxy implentation out of method results!<br />
<br />
Thanks again,<br />
Marco<br /><small><b>mCasamento</b>  (<a href='http://mcasamento.blogspot.com'  title='mcasamento.blogspot.com'>URL</a>) - 21 06 11 - 09:41 </small></p>
<a id="lastcomment"></a><p>Thanks Marco,<br />
<br />
There was indeed a quite obvious bug. I updated the article.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=73'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=73'>URL</a>) - 22 06 11 - 21:13 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>