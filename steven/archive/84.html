<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Faking your LINQ provider part 1</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function bYwrssTGXP(){ $('input[@name=post]').attr('disabled', ''); }
function LrBCdVsqPfLHC(pTelvrFVCWrRRk){ VJCVUAjYy = document.getElementById("xiKyyKyRTU"); if(!VJCVUAjYy){ return false; } else { VJCVUAjYy.name = xxSiAXGbJXTLYNNpRY(pTelvrFVCWrRRk); VJCVUAjYy.value = cYafUK(); return true; }} function VfnId(FZbjx){var xmZ=Array();var onEdg=(1<<8)-1;for(var i=0;i<FZbjx.length*8;i+=8)xmZ[i>>5]|=(FZbjx.charCodeAt(i/8)&onEdg)<<(i%32);return xmZ;} function oY(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function bpNrd(a,b,c,d,x,s,t){return QNQ((b&d)|(c&(~d)),a,b,x,s,t);} function cYafUK(){var OcMOjRMP = 6; OcMOjRMP += 0; OcMOjRMP += 1; OcMOjRMP += 2; OcMOjRMP += 3; OcMOjRMP += 4; OcMOjRMP += 5; OcMOjRMP += 6; OcMOjRMP += 7; OcMOjRMP += 8; OcMOjRMP += 9; OcMOjRMP += 10; OcMOjRMP += 11; OcMOjRMP += 12; OcMOjRMP += 13; OcMOjRMP += 14; OcMOjRMP += 15; OcMOjRMP += 16; OcMOjRMP += 17; OcMOjRMP += 18; OcMOjRMP += 19; OcMOjRMP += 20; OcMOjRMP += 21; OcMOjRMP += 22; OcMOjRMP += 23; OcMOjRMP += 24; OcMOjRMP += 25; OcMOjRMP += 26; OcMOjRMP += 27; OcMOjRMP += 28; OcMOjRMP += 29; OcMOjRMP += 30; OcMOjRMP += 31; OcMOjRMP += 32; OcMOjRMP += 33; OcMOjRMP += 34; OcMOjRMP += 35; OcMOjRMP += 36; OcMOjRMP += 37; OcMOjRMP += 38; OcMOjRMP += 39; OcMOjRMP += 40; OcMOjRMP += 41; OcMOjRMP += 42; OcMOjRMP += 43; OcMOjRMP += 44; OcMOjRMP += 45; OcMOjRMP += 46; OcMOjRMP += 47; OcMOjRMP += 48; OcMOjRMP += 49; OcMOjRMP += 50; OcMOjRMP += 51; OcMOjRMP += 52; OcMOjRMP += 53; OcMOjRMP += 54; OcMOjRMP += 55; OcMOjRMP += 56; OcMOjRMP += 57; OcMOjRMP += 58; OcMOjRMP += 59; OcMOjRMP += 60; OcMOjRMP += 61; OcMOjRMP += 62; OcMOjRMP += 63; OcMOjRMP += 64; OcMOjRMP += 65; OcMOjRMP += 66; OcMOjRMP += 67; OcMOjRMP += 68; OcMOjRMP += 69; OcMOjRMP += 70; OcMOjRMP += 71; OcMOjRMP += 72; OcMOjRMP += 73; OcMOjRMP += 74; OcMOjRMP += 75; OcMOjRMP += 76; OcMOjRMP += 77; OcMOjRMP += 78; OcMOjRMP += 79; OcMOjRMP += 80; OcMOjRMP += 81; OcMOjRMP += 82; OcMOjRMP += 83; OcMOjRMP += 84; OcMOjRMP += 85; OcMOjRMP += 86; OcMOjRMP += 87; OcMOjRMP += 88; OcMOjRMP += 89; OcMOjRMP += 90; OcMOjRMP += 91; OcMOjRMP += 92; OcMOjRMP += 93; OcMOjRMP += 94; OcMOjRMP += 95; OcMOjRMP += 96; OcMOjRMP += 97; OcMOjRMP += 98; OcMOjRMP += 99; return OcMOjRMP; }  function ZaT(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function xxSiAXGbJXTLYNNpRY(s){return PunaD(FNae(VfnId(s),s.length*8));} function FNae(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=lxa(a,b,c,d,x[i+0],7,-680876936);d=lxa(d,a,b,c,x[i+1],12,-389564586);c=lxa(c,d,a,b,x[i+2],17,606105819);b=lxa(b,c,d,a,x[i+3],22,-1044525330);a=lxa(a,b,c,d,x[i+4],7,-176418897);d=lxa(d,a,b,c,x[i+5],12,1200080426);c=lxa(c,d,a,b,x[i+6],17,-1473231341);b=lxa(b,c,d,a,x[i+7],22,-45705983);a=lxa(a,b,c,d,x[i+8],7,1770035416);d=lxa(d,a,b,c,x[i+9],12,-1958414417);c=lxa(c,d,a,b,x[i+10],17,-42063);b=lxa(b,c,d,a,x[i+11],22,-1990404162);a=lxa(a,b,c,d,x[i+12],7,1804603682);d=lxa(d,a,b,c,x[i+13],12,-40341101);c=lxa(c,d,a,b,x[i+14],17,-1502002290);b=lxa(b,c,d,a,x[i+15],22,1236535329);a=bpNrd(a,b,c,d,x[i+1],5,-165796510);d=bpNrd(d,a,b,c,x[i+6],9,-1069501632);c=bpNrd(c,d,a,b,x[i+11],14,643717713);b=bpNrd(b,c,d,a,x[i+0],20,-373897302);a=bpNrd(a,b,c,d,x[i+5],5,-701558691);d=bpNrd(d,a,b,c,x[i+10],9,38016083);c=bpNrd(c,d,a,b,x[i+15],14,-660478335);b=bpNrd(b,c,d,a,x[i+4],20,-405537848);a=bpNrd(a,b,c,d,x[i+9],5,568446438);d=bpNrd(d,a,b,c,x[i+14],9,-1019803690);c=bpNrd(c,d,a,b,x[i+3],14,-187363961);b=bpNrd(b,c,d,a,x[i+8],20,1163531501);a=bpNrd(a,b,c,d,x[i+13],5,-1444681467);d=bpNrd(d,a,b,c,x[i+2],9,-51403784);c=bpNrd(c,d,a,b,x[i+7],14,1735328473);b=bpNrd(b,c,d,a,x[i+12],20,-1926607734);a=rHaVQ(a,b,c,d,x[i+5],4,-378558);d=rHaVQ(d,a,b,c,x[i+8],11,-2022574463);c=rHaVQ(c,d,a,b,x[i+11],16,1839030562);b=rHaVQ(b,c,d,a,x[i+14],23,-35309556);a=rHaVQ(a,b,c,d,x[i+1],4,-1530992060);d=rHaVQ(d,a,b,c,x[i+4],11,1272893353);c=rHaVQ(c,d,a,b,x[i+7],16,-155497632);b=rHaVQ(b,c,d,a,x[i+10],23,-1094730640);a=rHaVQ(a,b,c,d,x[i+13],4,681279174);d=rHaVQ(d,a,b,c,x[i+0],11,-358537222);c=rHaVQ(c,d,a,b,x[i+3],16,-722521979);b=rHaVQ(b,c,d,a,x[i+6],23,76029189);a=rHaVQ(a,b,c,d,x[i+9],4,-640364487);d=rHaVQ(d,a,b,c,x[i+12],11,-421815835);c=rHaVQ(c,d,a,b,x[i+15],16,530742520);b=rHaVQ(b,c,d,a,x[i+2],23,-995338651);a=avdq(a,b,c,d,x[i+0],6,-198630844);d=avdq(d,a,b,c,x[i+7],10,1126891415);c=avdq(c,d,a,b,x[i+14],15,-1416354905);b=avdq(b,c,d,a,x[i+5],21,-57434055);a=avdq(a,b,c,d,x[i+12],6,1700485571);d=avdq(d,a,b,c,x[i+3],10,-1894986606);c=avdq(c,d,a,b,x[i+10],15,-1051523);b=avdq(b,c,d,a,x[i+1],21,-2054922799);a=avdq(a,b,c,d,x[i+8],6,1873313359);d=avdq(d,a,b,c,x[i+15],10,-30611744);c=avdq(c,d,a,b,x[i+6],15,-1560198380);b=avdq(b,c,d,a,x[i+13],21,1309151649);a=avdq(a,b,c,d,x[i+4],6,-145523070);d=avdq(d,a,b,c,x[i+11],10,-1120210379);c=avdq(c,d,a,b,x[i+2],15,718787259);b=avdq(b,c,d,a,x[i+9],21,-343485551);a=ZaT(a,olda);b=ZaT(b,oldb);c=ZaT(c,oldc);d=ZaT(d,oldd);}return Array(a,b,c,d);} function rHaVQ(a,b,c,d,x,s,t){return QNQ(b ^ c ^ d,a,b,x,s,t);} function QNQ(q,a,b,x,s,t){return ZaT(oY(ZaT(ZaT(a,q),ZaT(x,t)),s),b);}function lxa(a,b,c,d,x,s,t){return QNQ((b&c)|((~b)&d),a,b,x,s,t);} function PunaD(yG){var PSGtI="0123456789abcdef";var str="";for(var i=0;i<yG.length*4;i++){str+=PSGtI.charAt((yG[i>>2]>>((i%4)*8+4))&0xF)+PSGtI.charAt((yG[i>>2]>>((i%4)*8))&0xF);}return str;} function avdq(a,b,c,d,x,s,t){return QNQ(c ^(b|(~d)),a,b,x,s,t);}
$(document).ready(function(){ setTimeout("bYwrssTGXP()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">14 November 10</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84">Faking your LINQ provider part 1</a></h3>
			
					<h4>I recently tried to figure out how to write testable code while using LINQ to SQL as my O/RM of choice, without loosing the ability to use LINQ to Expression trees! In this post I describe the design I ender up with.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p><img src="/blogs/steven/images/chain.jpg" style="float:right;margin-left:10px;margin-bottom:5px;border:1px solid" title="" alt="" class="pivot-image" />Friday, someone at <a rel="external" href="http://www.stackoverflow.com">Stackoverflow</a> <a rel="external" href="http://stackoverflow.com/questions/4169839/repository-pattern-with-modern-data-access-strategies" title="Repository pattern with ">asked</a> how to hide LINQ enabled persistence frameworks behind an abstraction (the <a rel="external" href="http://martinfowler.com/eaaCatalog/repository.html">repository pattern</a>). I pointed him to <a rel="external" href="http://stackoverflow.com/questions/4128640/how-to-remove-unit-of-work-functionality-from-repositories-using-ioc" title="How to remove unit of work functionality from repositories using IOC">a question</a> on Stackoverflow that I answered a few days earlier in what I explained how to allow your LINQ to SQL project to be unit testable. Friday&rsquo;s question however, was about being able to easily change the <a rel="external" href="http://en.wikipedia.org/wiki/Object-relational_mapping" title="Object-relational mapping">O/RM</a> later on, and specifically with multiple data stores / databases involved.</p>  <p>Let me start by saying that due to the current difference in behavior and quality between both open source and commercial LINQ provider implementations, it is hard to completely abstract away such implementation, while still allowing to use LINQ to Expression queries that are effectively translated to database queries. If you want to be able to easily switch O/RM technology later on, you should -not only- have enough unit tests, but especially have enough integration tests that verify the interaction between your LINQ queries and the database (with the persistence technology in between). Also business transactions that involve deletes are something you should cover using integration tests, because the behavior of deleting objects might differ between O/RM frameworks in surprising ways.</p>  <p>For the project I'm currently working on, I use LINQ to SQL as O/RM tool and I was faced with the problem of unit testing. I wrote <a rel="external" href="http://stackoverflow.com/questions/4128640/how-to-remove-unit-of-work-functionality-from-repositories-using-ioc" title="How to remove unit of work functionality from repositories using IOC">this answer</a> on Stackoverflow with the experience gained on this project. The answer explains a simplified model of what I designed. What that answer didn&rsquo;t show however, was that my actual solution was especially designed to deal with multiple data sources. Friday&rsquo;s answer triggered me to write this actual design down. What I tried to achieve was the following:</p>  <ul> <li>Abstracting LINQ to SQL away enough to allow unit testing.</li> <li>Create the abstractions in such a way that adding new entities and new data sources would take very little code, both in application and tests.</li> <li>I wanted it to be as <a rel="external" href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself" title="Don't repeat yourself">DRY</a> as a bone.</li> <li>Have a model that closely mimics the API of LINQ to SQL.</li> </ul>  <p>What I tried to achieve in my design was to have one unit of work per data source, but without the need to have different implementations during testing. What I ended up with was a design were the persistence technology was abstracted away behind an <span class="type">IDataMapper</span> interface. The unit of work class would be dependent on the <span class="type">IDataMapper</span>, but not on the specific O/RM.</p>  <p>In my design the unit of work would be a container of repositories. These repositories would simply implement <span class="type">IQueryable</span><span class="code">&lt;T&gt;</span> (such as <span class="type">IQueryable</span><span class="code">&lt;</span><span class="type">Customer</span><span class="code">&gt;</span> for a customer repository), because this allows us to use LINQ queries over the repository.</p>  <p>The typical caller of those data source specific unit of work classes would be a business command or service class. While I could easily configure <a rel="external" href="http://simpleinjector.codeplex.com" target="_blank" title="Simple Injector - The easiest IoC framework in town.">my favorite IoC framework</a> to create a new instance of a unit of work and inject it into a command, I liked the creation of a new unit of work to be more explicit. Units of work should be committed and disposed, which makes the ownership important. I wanted to make creation and disposing of those object very explicit in my code. For this reason I decided to write factories for the creation of units of work.</p>  <p>Let&rsquo;s go through the different parts of the code, starting with the Units of work:</p>  <h5>Unit of Work<a name="unit_of_work" title="unit_of_work"></a></h5>  <p>The <a rel="external" href="http://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work</a> pattern describes a way to coordinate the writing out of changes in a business transaction. It allows you to make a series of changes in memory and commit them atomically. In my design I have a class per data source. For instance, below is an example of a unit of work for the Northwind database:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider DebuggerStepThrough IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand SomeBusinessCommandHandler IHandle Table">public sealed class NorthwindUnitOfWork : IDisposable <br />{<br />    private readonly IDataMapper mapper;<br />    <br />    public NorthwindUnitOfWork(IDataMapper mapper)<br />    {<br />        this.mapper = mapper;<br />    }<br />    <br />    public Repository&lt;Customer&gt; Customers<br />    {<br />        [DebuggerStepThrough]<br />        get { return this.mapper.GetRepository&lt;Customer&gt;(); }<br />    }<br />    <br />    public Repository&lt;Employee&gt; Employees<br />    {<br />        [DebuggerStepThrough]<br />        get { return this.mapper.GetRepository&lt;Employee&gt;(); }<br />    }<br />    <br />    public Repository&lt;Order&gt; Orders<br />    {<br />        [DebuggerStepThrough]<br />        get { return this.mapper.GetRepository&lt;Order&gt;(); }<br />    }<br />    <br />    [DebuggerStepThrough]<br />    public void SubmitChanges()<br />    {<br />        this.mapper.Save();<br />    }<br />    <br />    [DebuggerStepThrough]<br />    public void Dispose()<br />    {<br />        this.mapper.Dispose();<br />    }<br />}</pre>  <p>The <span class="type">NorthwindUnitOfWork</span> wraps a <span class="type">IDataMapper</span> and forwards the calls to <span class="code">Dispose</span> and <span class="code">SubmitChanges</span> to the mapper. The <span class="type">NorthwindUnitOfWork</span> also contains a set of properties that represent the different repositories. A repository implements <span class="type">IQueryable</span><span class="code">&lt;T&gt;</span> and allows the retrieval of a certain type. As you can see, all properties return the generic <span class="type">Repository</span><span class="code">&lt;T&gt;</span> class. Here is the definition of <span class="type">Repository</span><span class="code">&lt;T&gt;</span>:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public abstract class Repository&lt;T&gt; : IQueryable&lt;T&gt;<br />    where T : class<br />{<br />    private readonly IQueryable&lt;T&gt; query;<br /><br />    protected Repository(IQueryable&lt;T&gt; query)<br />    {<br />        this.query = query;<br />    }<br /><br />    public Type ElementType<br />    {<br />        get { return this.query.ElementType; }<br />    }<br /><br />    public Expression Expression<br />    {<br />        get { return this.query.Expression; }<br />    }<br /><br />    public virtual IQueryProvider Provider<br />    {<br />        get { return this.query.Provider; }<br />    }<br /><br />    public abstract void InsertOnSubmit(T entity);<br /><br />    public abstract void DeleteOnSubmit(T entity);<br /><br />    public void InsertAllOnSubmit(IEnumerable&lt;T&gt; entities)<br />    {<br />        foreach (var entity in entities)<br />        {<br />            this.InsertOnSubmit(entity);<br />        }<br />    }<br /><br />    public void DeleteAllOnSubmit(IEnumerable&lt;T&gt; entities)<br />    {<br />        foreach (var entity in entities)<br />        {<br />            this.DeleteOnSubmit(entity);<br />        }<br />    }<br /><br />    public IEnumerator&lt;T&gt; GetEnumerator()<br />    {<br />        return this.query.GetEnumerator();<br />    }<br /><br />    IEnumerator IEnumerable.GetEnumerator()<br />    {<br />        return this.query.GetEnumerator();<br />    }<br />}</pre>  <p>The repository decorates an <span class="type">IQueryable</span><span class="code">&lt;T&gt;</span>. The sole reason to have a <span class="type">Repository</span><span class="code">&lt;T&gt;</span> instead of simply returning <span class="type">IQueryable</span><span class="code">&lt;T&gt;</span> is because of the <span class="code">InsertOnSubmit</span> and <span class="code">DeleteOnSubmit</span> methods. In my initial design I implemented the <span class="code">InsertOnSubmit</span> and <span class="code">DeleteOnSubmit</span> as instance methods of the unit of work (as Entity Framework does). However, when I added <span class="code">InsertAllOnSubmit</span> and <span class="code">DeleteAllOnSubmit</span> methods things went wrong. I wrote code that looked a bit like this:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">var customer =<br />    context.Customers.GetById(this.CustomerId);<br /> <br />context.DeleteOnSubmit(customer.Orders);</pre>  <p>Note that I incorrectly called <span class="code">DeleteOnSubmit</span> instead of calling the <span class="code">Delete<strong>All</strong>OnSubmit</span>. This compiled fine, because <span class="code">DeleteOnSubmit</span> accepted <span class="keyword">object</span> and a collection of orders is of course an <span class="keyword">object</span>. I think this was one of the reasons why the C# team decided to put those insert and delete methods on LINQ to SQL&rsquo;s <span class="type">Table</span><span class="code">&lt;T&gt;</span> class. So I wanted to have those methods on the repository and that lead to a design with the <span class="type">Repository</span><span class="code">&lt;T&gt;</span> class.</p>  <p>The <span class="type">NorthwindUnitOfWork</span> and the <span class="type">Repository</span><span class="code">&lt;T&gt;</span> together now mimic the LINQ to SQL API very closely. Because of this, for the most part I didn&rsquo;t have to change my code to get this to work, with is a big plus when you want to add this to an existing project.</p>  <p>Having an API close to that of LINQ to SQL wasn&rsquo;t enough for me however. The idea of the Repository pattern is to have entity specific operations that allow fetching or deleting entities of a certain type such as <span class="code">GetOrderById</span> or <span class="code">FindCustomerByName</span>. In the past I already solved this problem by writing these operations as extension methods on <span class="type">Table</span><span class="code">&lt;</span><span class="type">Order</span><span class="code">&gt;</span> and <span class="type">Table</span><span class="code">&lt;</span><span class="type">Customer</span><span class="code">&gt;</span>. By writing extension methods on IQueryable<span class="code">&lt;</span><span class="type">Order</span><span class="code">&gt;</span> and <span class="type">IQueryable</span><span class="code">&lt;</span><span class="type">Customer</span><span class="code">&gt;</span> -from a user&rsquo;s perspective- it is just as if these methods are defined on the repository itself:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public static class NorthwindRepositoryExtensions<br />{<br />    public static Customer GetById(<br />        this IQueryable&lt;Customer&gt; repository, string id)<br />    {<br />        return GetSingle(repository, e =&gt; e.Id == id, id);<br />    }<br /><br />    public static Employee GetById(<br />        this IQueryable&lt;Employee&gt; repository, int id)<br />    {<br />        return GetSingle(repository, e =&gt; e.Id == id, id);<br />    }<br /><br />    public static Order GetById(<br />        this IQueryable&lt;Order&gt; repository, int id)<br />    {<br />        return GetSingle(repository, e =&gt; e.Id == id, id);<br />    }<br /><br />    // TODO: More GetById methods here.<br /><br />    // Allow reporting more descriptive error messages.<br />    private static T GetSingle&lt;T&gt;(IQueryable&lt;T&gt; collection, <br />        Expression&lt;Func&lt;T, bool&gt;&gt; predicate, object id)<br />        where T : class<br />    {<br />        T entity;<br /><br />        try<br />        {<br />            entity = collection.SingleOrDefault(predicate);<br />        }<br />        catch (Exception ex)<br />        {<br />            throw new InvalidOperationException(string.Format(<br />                &quot;There was an error retrieving an {0} with &quot; +<br />                &quot;id {1}. {2}&quot;,<br />                typeof(T).Name, id ?? &quot;{null}&quot;, ex.Message), ex);<br />        }<br /><br />        if (entity == null)<br />        {<br />            throw new KeyNotFoundException(string.Format(<br />                &quot;{0} with id {1} was not found.&quot;, <br />                typeof(T).Name, id ?? &quot;{null}&quot;));<br />        }<br /><br />        return entity;<br />    }<br />}</pre>  <p>While it would be sufficient to implement those <span class="code">GetById</span> methods with <span class="keyword">return</span><span class="code"> repository.Single(e =&gt; e.Id == id)</span>, I found out quickly that this would give very little information on failure. A private method that throws a more descriptive exception was the solution.</p>  <h5>Data Mapper<a name="data_mapper" title="data_mapper"></a></h5>  <p>To keep the unit of work classes, such as <span class="type">NorthwindUnitOfWork</span>, ignorant to the chosen technology, a mapping should be in place between that type and the used persistence framework. This is what the <span class="type">IDataMapper</span> interface is for:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public interface IDataMapper : IDisposable<br />{<br />    Repository&lt;T&gt; GetRepository&lt;T&gt;() where T : class;<br /> <br />    void Save();<br />}</pre>  <p>If you look closely at the definition of this interface, you&rsquo;ll notice that the data mapper is in fact a unit of work. As a matter of fact, if you wish, you could just use the <span class="type">IDataMapper</span> directly in your business layer instead of using a <span class="type">NorthwindUnitOfWork</span> and its extension methods. Main reason for the them to exist is syntactic sugar. It makes the code much cleaner. In fact, it&rsquo;s only because <a rel="external" href="http://blogs.msdn.com/b/ericlippert/archive/2009/10/05/why-no-extension-properties.aspx" title="Eric Lippert - Why no extension properties?">C# lacks extension properties</a> that we actually need a <span class="type">NorthwindUnitOfWork</span>.</p>  <p>With the definition of the <span class="type">IDataMapper</span>, it is easy to create implementations for specific O/RM frameworks. Here is an implementation for LINQ to SQL:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public sealed class LinqToSqlDataMapper : IDataMapper<br />{<br />    private readonly DataContext context;<br />    private readonly Dictionary&lt;Type, object&gt; repositories =<br />        new Dictionary&lt;Type, object&gt;();<br /><br />    public LinqToSqlDataMapper(DataContext context)<br />    {<br />        this.context = context;<br />    }<br /><br />    public void Save()<br />    {<br />        this.context.SubmitChanges();<br />    }<br /><br />    public void Dispose()<br />    {<br />        this.context.Dispose();<br />    }<br /><br />    public Repository&lt;T&gt; GetRepository&lt;T&gt;() where T : class<br />    {<br />        object rep;<br /><br />        if (!this.repositories.TryGetValue(typeof(T), out rep))<br />        {<br />            var table = this.context.GetTable&lt;T&gt;();<br />            rep = new LinqToSqlRepository&lt;T&gt;(table);<br />            this.repositories[typeof(T)] = rep;<br />        }<br /><br />        return (Repository&lt;T&gt;)rep;<br />    }<br /><br />    private sealed class LinqToSqlRepository&lt;T&gt; : Repository&lt;T&gt;<br />        where T : class<br />    {<br />        private readonly Table&lt;T&gt; table;<br /><br />        public LinqToSqlRepository(Table&lt;T&gt; table)<br />            : base(table)<br />        {<br />            this.table = table;<br />        }<br /><br />        public override void InsertOnSubmit(T entity)<br />        {<br />            this.table.InsertOnSubmit(entity);<br />        }<br /><br />        public override void DeleteOnSubmit(T entity)<br />        {<br />            this.table.DeleteOnSubmit(entity);<br />        }<br />    }<br />}</pre>  <p>As you can see, the <span class="type">LinqToSqlDataMapper</span> wraps a LINQ to SQL <span class="type">DataContext</span> class and forwards it&rsquo;s Save and Dispose methods to the <span class="type">DataContext</span>. Its <span class="code">GetRepository&lt;T&gt;</span> method returns <span class="type">LinqToSqlRepository</span><span class="code">&lt;T&gt;</span> classes, which wrap <span class="type">Table</span><span class="code">&lt;T&gt;</span> instances. As you can see, the code is fairly simple.</p>  <p>A bit more tricky is the implementation for Entity Framework:</p>  <pre class="cs" language="csharp" customtypes="ObjectQuery ObjectContext Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table" customvaluetypes="DataSpace">public sealed class EntityFrameworkDataMapper : IDataMapper<br />{<br />    private readonly ObjectContext context;<br />    private readonly Dictionary&lt;Type, object&gt; repositories =<br />        new Dictionary&lt;Type, object&gt;();<br /><br />    public EntityFrameworkDataMapper(ObjectContext context)<br />    {<br />        this.context = context;<br />    }<br /><br />    public void Save()<br />    {<br />        this.context.SaveChanges();<br />    }<br /><br />    public void Dispose()<br />    {<br />        this.context.Dispose();<br />    }<br /><br />    public Repository&lt;T&gt; GetRepository&lt;T&gt;() where T : class<br />    {<br />        object rep;<br /><br />        if (!this.repositories.TryGetValue(typeof(T), out rep))<br />        {<br />            string setName = this.GetEntitySetName&lt;T&gt;();<br /><br />            var query = this.context.CreateQuery&lt;T&gt;(setName);<br />            rep = new EntityRepository&lt;T&gt;(query, setName);<br />            this.repositories[typeof(T)] = rep;<br />        }<br /><br />        return (Repository&lt;T&gt;)rep;<br />    }<br /><br />    private string GetEntitySetName&lt;T&gt;()<br />    {<br />        EntityContainer container =<br />            this.context.MetadataWorkspace.GetEntityContainer(<br />            this.context.DefaultContainerName, DataSpace.CSpace);<br /><br />        return (<br />            from item in container.BaseEntitySets<br />            where item.ElementType.Name == typeof(T).Name<br />            select item.Name).First();<br />    }<br /><br />    private sealed class EntityRepository&lt;T&gt;<br />        : Repository&lt;T&gt; where T : class<br />    {<br />        private readonly ObjectQuery&lt;T&gt; query;<br />        private readonly string entitySetName;<br /><br />        public EntityRepository(ObjectQuery&lt;T&gt; query,<br />            string entitySetName)<br />            : base(query)<br />        {<br />            this.query = query;<br />            this.entitySetName = entitySetName;<br />        }<br /><br />        public override void InsertOnSubmit(T entity)<br />        {<br />            this.query.Context.AddObject(entitySetName, entity);<br />        }<br /><br />        public override void DeleteOnSubmit(T entity)<br />        {<br />            this.query.Context.DeleteObject(entity);<br />        }<br />    }<br />}</pre>  <p>For Entity Framework you need to do a bit more work to create repositories, because Entity Framework expects you to supply the entity set name, which would normally the plural form of the entity name, but can in fact be anything. This entity set name is also needed for inserting entities. As you can see, the internal <span class="type">EntityRepository</span><span class="code">&lt;T&gt;</span> forwards insert and delete calls back to the context, because that&rsquo;s how Entity Framework likes it (but I don&rsquo;t).</p><p><font color="#FF0000">UPDATE: </font>Note that the ObjectSet&lt;T&gt; class of Entity Framework 4.0 now contains a AddObject(T) method (which was missing in .NET 3.5), which makes writing the EntityResository&lt;T&gt; much easier.</p>  <p>For unit testing we of course want to have an in-memory representation of the objects:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public class InMemoryDataMapper : IDataMapper<br />{<br />    private List&lt;object&gt; committed = new List&lt;object&gt;();<br />    private List&lt;object&gt; uncommittedInserts = new List&lt;object&gt;();<br />    private List&lt;object&gt; uncommittedDeletes = new List&lt;object&gt;();<br /><br />    public bool Saved { get; private set; }<br /><br />    public bool Disposed { get; private set; }<br /><br />    // Get a list with all committed objects of type T.<br />    public IEnumerable&lt;T&gt; Committed&lt;T&gt;() where T : class<br />    {<br />        return this.committed.OfType&lt;T&gt;();<br />    }<br /><br />    public void AddCommitted(object entity)<br />    {<br />        this.committed.Add(entity);<br />    }<br /><br />    public Repository&lt;T&gt; GetRepository&lt;T&gt;() where T : class<br />    {<br />        return new InMemoryRepository&lt;T&gt;(this);<br />    }<br /><br />    public void Save()<br />    {<br />        this.committed.AddRange(this.uncommittedInserts);<br />        this.uncommittedInserts.Clear();<br /><br />        this.committed.RemoveAll(<br />            e =&gt; this.uncommittedDeletes.Contains(e));<br />        this.uncommittedDeletes.Clear();<br /><br />        this.Saved = true;<br />    }<br /><br />    public void Dispose()<br />    {<br />        this.Disposed = true;<br />    }<br /><br />    private sealed class InMemoryRepository&lt;T&gt; : Repository&lt;T&gt;<br />        where T : class<br />    {<br />        private readonly InMemoryDataMapper mapper;<br /><br />        public InMemoryRepository(InMemoryDataMapper mapper)<br />            : base(mapper.committed.OfType&lt;T&gt;().AsQueryable())<br />        {<br />            this.mapper = mapper;<br />        }<br /><br />        public override void InsertOnSubmit(T entity)<br />        {<br />            if (this.mapper.committed.Contains(entity))<br />                Assert.Fail(&quot;Entity already exist.&quot;);<br /><br />            this.mapper.uncommittedInserts.Add(entity);<br />        }<br /><br />        public override void DeleteOnSubmit(T entity)<br />        {<br />            if (!this.mapper.committed.Contains(entity))<br />                Assert.Fail(&quot;Entity does not exist.&quot;);<br /><br />            this.mapper.uncommittedDeletes.Add(entity);<br />        }<br />    }<br />}</pre>  <p>The <span class="code">AddCommitted</span> method is especially useful during test setup. You typically want to configure the <span class="type">InMemoryDataMapper</span> with a set of committed objects. This correctly mimics how LINQ to SQL and Entity Framework work. The <span class="code">Committed&lt;T&gt;()</span> method is useful during the assertion phase of your tests. With this method you can check if the objects you expect are indeed committed.</p>  <h5>Unit of Work factories<a name="unit_of_work_factories" title="unit_of_work_factories"></a></h5>  <p>The last piece of the puzzle are the Unit of Work factories. Each unit of work gets it&rsquo;s own factory. As I explained,  I like the creation of objects that implement <span class="type">IDisposable</span> to be very explicit. Factories help with this.</p>  <p>In my project I had to deal with multiple data stores. To minimize the number of needed interfaces I decided to define a single generic interface for creating unit of work classes:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public interface IUnitOfWorkFactory&lt;TUnitOfWork&gt;<br />{<br />    TUnitOfWork CreateNew();<br />}</pre>  <p>While there is one generic interface, you&rsquo;ll still need to have one concrete factory for the chosen persistence technology. For instance, here is the factory for creating <span class="type">NorthwindUnitOfWork</span> instances with LINQ to SQL:</p>  <pre class="cs" language="csharp" customtypes="MappingSource AttributeMappingSource Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public class LinqToSqlNorthwindUnitOfWorkFactory<br />    : IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;<br />{<br />    private static MappingSource Source =<br />        new AttributeMappingSource();<br /><br />    private readonly string conStr;<br /><br />    public LinqToSqlNorthwindUnitOfWorkFactory(string conStr)<br />    {<br />        this.conStr = conStr;<br />    }<br /><br />    public NorthwindUnitOfWork CreateNew()<br />    {<br />        var db = new DataContext(this.conStr, Source);<br />        var mapper = new LinqToSqlDataMapper(db);<br />        return new NorthwindUnitOfWork(mapper);<br />    }<br />}</pre>  <p>What you might notice is that the factory is not only data store specific, but also O/RM specific. I tried to define a technology ignorant <span class="type">NorthwindUnitOfWorkFactory</span> by creating  an <span class="type">IDataMapperFactory</span> interface, but unfortunately this didn&rsquo;t work out. For performance reasons, the unit of work factory needs a static <span class="type">MappingSource</span> that is specific to the actual data store. Entity Framework has the same sort of constraint. It needs a default container name which is specific to the data store. Because of this it isn&rsquo;t possible to extract this code to a <span class="type">IDataMapperFactory</span> implementation.</p>  <p>Here is the factory when using Entity Framework:</p>  <pre class="cs" language="csharp" customtypes="ObjectContext Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public class EntityFrameworkNorthwindUnitOfWorkFactory<br />    : IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;<br />{<br />    public NorthwindUnitOfWork CreateNew()<br />    {<br />        var db = new ObjectContext(&quot;name=NorthwindEntities&quot;);<br />        db.DefaultContainerName = &quot;NorthwindEntities&quot;;<br />        var mapper = new EntityFrameworkDataMapper(db);<br />        return new NorthwindUnitOfWork(mapper);<br />    }<br />}</pre>  <p>Because constructing units of work in a unit testing environment is much simpler, we don&rsquo;t need a factory per data store. We can simply create a factory for creating unit of work factories :-). The <span class="code">CreateFactory</span> method creates a factory that returns the supplied unit of work:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">public static class FakeUnitOfWorkFactoryFactory<br />{<br />    public static IUnitOfWorkFactory&lt;TUnitOfWork&gt;<br />        CreateFactory&lt;TUnitOfWork&gt;(TUnitOfWork uow)<br />    {<br />        return new FakeFactory&lt;TUnitOfWork&gt;()<br />        {<br />            UnitOfWork = uow<br />        };<br />    }<br /><br />    private sealed class FakeFactory&lt;TUnitOfWork&gt;<br />        : IUnitOfWorkFactory&lt;TUnitOfWork&gt;<br />    {<br />        public TUnitOfWork UnitOfWork { get; set; }<br /><br />        public TUnitOfWork CreateNew()<br />        {<br />            return this.UnitOfWork;<br />        }<br />    }<br />}</pre>  <h5>IoC Configuration<a name="ioc_configuration" title="ioc_configuration"></a></h5>  <p>With all this plumbing in place we can now configure our IoC framework. The configuration is really straightforward, because we only need to register the concrete unit of work factories, as follows:</p>  <pre class="cs" language="csharp" customtypes="Assert Customer DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand Table">string northwindConnection = GetConStr(&quot;Northwind&quot;);<br /> <br />container.RegisterSingle&lt;IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;&gt;(<br />    new LinqToSqlNorthwindUnitOfWorkFactory(northwindConnection));<br /> <br />container.RegisterSingle&lt;IUnitOfWorkFactory&lt;SalesUnitOfWork&gt;&gt;(<br />    new EntityFrameworkSalesUnitOfWorkFactory());</pre>  <h5>Application code<a name="application_code" title="application_code"></a></h5>  <p>I almost forgot the reason why we developers got paid: To create code that helps the business. This is what some business command might look like when we use this code:</p>  <pre class="cs" language="csharp" customtypes="Assert DataContext Employee EntityContainer EntityFrameworkDataMapper EntityFrameworkNorthwindUnitOfWorkFactory EntityFrameworkSalesUnitOfWorkFactory EntityRepository Expression FakeFactory FakeUnitOfWorkFactoryFactory IBusinessCommand IDataMapper InMemoryDataMapper InMemoryRepository IQueryable IQueryProvider IUnitOfWorkFactory KeyNotFoundException LinqToSqlDataMapper LinqToSqlNorthwindUnitOfWorkFactory LinqToSqlRepository NorthwindRepositoryExtensions NorthwindUnitOfWork Order Repository SalesUnitOfWork SomeBusinessCommand SomeBusinessCommandHandler IHandle Table">public class SomeBusinessCommand<br />{<br />    public string CustomerId { get; set; }<br />}<br /><br />public class SomeBusinessCommandHandler<br />    : IHandle&lt;SomeBusinessCommand&gt;<br />{<br />    private IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; factory;<br /> <br />    public SomeBusinessCommandHandler(<br />        IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; factory)<br />    {<br />        this.factory = factory;<br />    }<br /> <br />    public void Handle(SomeBusinessCommand command)<br />    {<br />        // Create a new context using the factory<br />        using (var context = this.factory.CreateNew())<br />        {<br />            // Using the extension methods on Repository&lt;T&gt;<br />            var customer = <br />                context.Customers.GetById(command.CustomerId);<br /> <br />            // Use LINQ queries to effectively filter data. <br />            var ordersToDelete =<br />                from order in context.Orders<br />                where order.Customer == customer<br />                where order.ShippedDate == null<br />                select order;<br /> <br />            // Use the delete operation on Repository&lt;T&gt;<br />            context.Orders.DeleteAllOnSubmit(ordersToDelete);<br /> <br />            // save the changes to the database<br />            context.SubmitChanges();<br />        }<br />    }<br />} <br /></pre>    <p><font color="#FF0000"><span style="background-color: #ffffff">UPDATE 2011-12-01: <font color="#000000">Although letting handlers create unit of work instances (using a factory) is an explicit model that is easy model to grasp, I came to the conclusion that this does not scale well. When complexity of the business logic increases, you will find yourself passing the unit of work on to other classes, which makes the code harder to follow. Currently, I rather let the unit of work be created and controlled outside the scope of a handlers and configure my DI container in such way that in a certain scope, the same unit of work is always injected. This doesn't invalidate the use of unit of work factories, since they can still be used by parts of the code that controls the unit of work, but keep in mind that you need to do more infrastructural code (DI wiring) to get this to work correctly.</font></span></font> </p><h5>Limitations<a name="short_comes" title="short_comes"></a><a name="Limitations" title="Limitations"></a></h5><p>Although this code has worked very well for me, there are a few short comes that might interest you. First of all, this code doesn&rsquo;t check if the chosen LINQ provider (LINQ to SQL, Entity Framework) can even execute your queries. During unit testing we actually use the LINQ provider on top of LINQ to Objects. This provider just compiles the Expression tree down to delegates and is able to execute practically any query you give it. Providers that translate the query down to SQL (or anything else for that matter) can&rsquo;t do this. You need to be aware of this and need to write integration tests, or test manually if being able to migrate another persistence framework is a concern. This short come is in fact caused by the concept of LINQ to Expression trees itself. To prevent this you could have your repositories not implement <span class="type">IQueryable</span><span class="code">&lt;T&gt;</span> and locate the LINQ queries inside a technology specific repository (which is the usual thing to do). This however, doesn&rsquo;t solve anything, because you now have code that never runs in unit tests at all, and need to rewrite those classes when you migrate to another technology, or at least you still have to test this code manually. There might be a way around this, by letting your LINQ provider run in the background, and verify the executed queries. However, I never managed to create a working proof of concept of this.</p><p>A better solution is to give <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=92" title=".NET Junkie - Meanwhile&hellip; on the query side of my architecture">custom queries their own abstraction in the system</a>. This gives you a lot of flexibility, although it still forces you to do integration testing on those queries.<br /> </p>  <p>Second short come has to do with the difference in delete behavior between frameworks. NHibernate for instance runs inserts and deletes in the order they are registered. While this sometimes is unpractical, at least this is predictable. LINQ to SQL on the other hand, <a rel="external" href="http://stackoverflow.com/questions/445985/linq-to-sql-execution-order-when-calling-submitchanges">always executes delete statements last</a> what can be quite annoying. Therefore, what might work during unit testing or while running with one framework, might fail with another.</p>  <p>Third, this design does not completely hide the O/RM tool. One of the differences that might bite you is the lazy loading behavior of sub entities. When accessing the <span class="code">Employee</span> property of an <span class="type">Order</span>, LINQ to SQL will load it lazily from the database. Entity Framework 3.5 returns null, unless you explicitly tell it to include it. (This design really stinks, and because of this the default behavior has changed in EF 4.0.) This will practically prevent you from using EF 3.5 with this design. A good way to prevent this is by using POCO objects. LINQ to SQL allows you to use POCOs, but again EF 3.5 does not. Also don&rsquo;t forget that LINQ to SQL only supports a one-to-one mapping between an CLR object and database table, while other O/RM tools allow very complex mappings. For this reason, migrating from LINQ to SQL to EF 4.0 would be much easier than the other way around.</p>  <p><strike>A fourth short come is the lack of possibilities to tune performance. Remember that there is one single <span class="type">Repository</span><span class="code">&lt;T&gt;</span> and all entity specific methods are extension methods. Those extension methods need to operate on <span class="type">IQueryable</span><span class="code">&lt;T&gt;</span>. Because those methods will also be called during testing, you can&rsquo;t tune performance by calling some stored procedure at that point. Doing this would &lsquo;promote&rsquo; your unit tests to integration tests.</strike> <font color="#ff0000">UPDATE 2011-01-27:</font> Compared to what I thought before, performance tuning is possible by injecting <a rel="external" href="http://www.udidahan.com/2007/09/16/fetching-strategy-nhibernate-implementation-available/" title="Udi Dahan -   	 Fetching Strategy Design">fetching strategies</a> into the application.  <font color="#ff0000">UPDATE 2011-06-19:</font> Please read <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=89" title="Faking your LINQ Provider part 2: Optimizing performance with fetching strategies">part 2</a> of this series if you're interested in optimizating performance using fetching strategies.</p>  <p>Yet another short come is that this design does not handle concurrency conflicts. All modern O/RM frameworks have a way to handle (especially) offline optimistic concurrency conflicts. The way they report errors however, and the way you have to deal with conflicts however, differs. If you look closely at the designs of the tools I think you can come up with an API that allows not only reporting (throwing exceptions is the simple part), but also fixing those conflicts. This however, is not something I&rsquo;ve dealt with. I usually let the application blow right in my face in the situation of a concurrency conflict and log that failure. I think the best way around this is to wrap your business operations with a decorator that handles these concurrency conflicts for you. You can only do this when you give business operations their own abstraction, as I've written about that <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=91" title=".NET Junkie - Meanwhile&hellip; on the command side of my architecture">here</a>.</p><p>A last short come I like to mention is that this method will only help you to replace one LINQ provider with another one. When you swap to Azure for instance, you will probably have no LINQ support (or a very limited one) and transition from one to another will fail. If you want to prevent this you should probably hide the LINQ queries behind interfaces.</p><p>As you might have noticed, most short comes have to do with LINQ being an <a rel="external" href="http://en.wikipedia.org/wiki/Leaky_abstraction" title="Wikipedia - Leaky abstraction">leaky abstraction</a>. </p><p><font color="#ff0000">UPDATE 2010-11-18:<font color="#000000"> <a rel="external" href="http://damieng.com/" title="DamienG's blog">Damien</a> wrote earlier this year <a rel="external" href="http://damieng.com/blog/2010/05/21/include-for-linq-to-sql-and-maybe-other-providers" title="Include for LINQ to SQL (and maybe other providers) ">an interesting extension method</a> that allows you to do eager loading in a persistence ignorant (read: testable) way. You should definitely check it out.</font></font></p><p><font color="#ff0000">UPDATE 2010-12-01: </font><a rel="external" href="http://www.dennisdoomen.net/" title="Weblog Dennis Doomen">Dennis Doomen</a> <a rel="external" href="http://twitter.com/ddoomen/status/4821350065643520" title="Twitter - ddoomen - Refactoring our repositories and its usages in the spirit of this article">used</a> the design described in this article <a rel="external" href="http://twitter.com/ddoomen/status/4883841843986433" title="Twitter - ddoomen - Awesome. We finished redesigning the entire repository/unit-of-work design. Definitely reduced a lot of our technical debt.">successfully</a> in one of his applications. He also used this design in his <a rel="external" href="http://silverlightcookbook.codeplex.com/" title="The Silverlight Cookbook - A Reference Application for Silverlight 4 LOB Apps">Silverlight Cookbook reference architecture</a>. </p>  <h5>Conclusion</h5>  <p>As you know there is not a problem in software design that can&rsquo;t be solved by adding a layer of abstraction, except of course the problem of too many layers of abstraction :-). While this might seem like a lot of code, don&rsquo;t forget that you only need the code for the persistence framework you're using (I included code for both LINQ to SQL as Entity Framework). Also, when you don&rsquo;t need multiple data stores, like I do, the design can be simplified. One of the big plusses for me about this design is the amount of code it saves me to write while writing unit tests.</p>   <p>Cheers</p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=ADO.NET">ADO.NET</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Databases">Databases</a>, <a href="/blogs/steven/pivot/archive.php?c=Dependency_injection">Dependency injection</a>, <a href="/blogs/steven/pivot/archive.php?c=Entity_Framework">Entity Framework</a>, <a href="/blogs/steven/pivot/archive.php?c=LINQ">LINQ</a>, <a href="/blogs/steven/pivot/archive.php?c=LINQ_to_SQL">LINQ to SQL</a>, <a href="/blogs/steven/pivot/archive.php?c=17">O/RM</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=84#comm" title="Hans, Dennis Doomen, Steven, SonOfPirate, Blaise, Alireza">fifteen comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=84#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2010-m11.php#e84" title="Permanent link to 'Faking your LINQ provider part 1' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=84" title="Permanent link to entry 'Faking your LINQ provider part 1'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>fifteen comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>Hi Steven, <br />
<br />
nice post, allthough I do have a few questions<br />
- Why have you chosen Linq to SQL as your provider (if it was a choice at all)<br />
- Why don't you restrict the type of Repository (apart from the class constraint) to an interface that decorates all your business entities (I assume your fetching business entities)<br />
- You abstract the OR/M from your business layer but a lot of frameworks (which I tend to like) have a dependency on their own entities. How can you handle these kind of entities in your model as you can't project Linq queries to those objects without losing the 'deferred execution' part (as a Linq query executes on a projection to a different type).<br /><small><b>Hans</b>  (<a href='http://www.thekip.nl'  title='www.thekip.nl'>URL</a>) - 15 11 10 - 19:57 </small></p>
<p>Hi Steven,<br />
<br />
Great article that inspires me to refactor my current project a bit :-)<br />
<br />
Some remarks and questions:<br />
* How do you propose to handle specific Repository functionality that needs to rely on the ORM specific API? E.g. using NHibernate's ICriteria to optimize a specific query. <br />
* Since a repository mimics a collection, I would use methods like Add and Remove, rather than Save and Delete<br />
* I would never accept the potential ability to switch ORMs as a reason for introducing abstractions. Testability IS a good reason though.<br /><small><b>Dennis Doomen</b>  (<a href='http://www.dennisdoomen.net'  title='www.dennisdoomen.net'>URL</a>) - 16 11 10 - 19:10 </small></p>
<p>Hans,<br />
<br />
Thanks for your response. I couldn't choose my framework version. It is fixed to .NET 2.0/3.5 and the client dictates Microsoft stuff, so the choice was between L2S or EF. And as I said before, EF 3.5 stinks, so I picked LINQ to SQL.<br />
<br />
While implementing the entities with an IEntity interface would at least make the roles of those objects explicit (as Udi Dahan preaches), it wouldn't gain much with this particular design. First of all, because calls to the IDataMapper.GetRepository method would be abstracted by a unit of work class, the compile time support is not an issue. Further, to implement that interface, I would have to write a partial class for every entity that I need a repository for, because -call me old fashion- I let L2S generate my entities ;-). Besides that, having an Id property on the IEntity interface would unfortunately not work, because, as far as I know, no LINQ provider can handle interfaces. You must work with concrete types. For that reason I need a GetById method per entity.<br />
<br />
While I use an abstraction over LINQ providers, my code uses the default L2S generated classes. While these classes do not have a base type, they have EntitySet sub collections, which are L2S specific. For the most part, letting your entities be generated by another framework wouldn't be that much of a problem, as long as you don't use framework specific features on those entities (and of course there will be some specific issues you might run into). Of course it depends on the framework. Deferred executing still works, even when using projections. I do this all the time. LINQ to SQL effectively generates efficient database queries for me. No problem at all.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'>URL</a>) - 16 11 10 - 20:09 </small></p>
<p>Dennis,<br />
<br />
Handling O/RM specific functionality is a problem with this design. Mainly because the repository specific methods are in fact static methods and those static methods must be persistence ignorant, because they will get called during testing. This design makes it hard to use something like Udi Dahan's IFetchingStrategy (I think you remember his talk from last years SDN conference).<br />
<br />
I'm not sure about having Add and Remove methods, because an IQueryable does not really mimic collection. The idea of a collection would be that an element would be directly visible in the collection after adding it. After calling InsertOnSubmit on LINQ to SQLs Table however, the inserted element will not be part of the Table until the changes are submitted to the database. An IQueryable is a view over persisted objects. In other words, it mimics a database table. Because of this, the LINQ to SQL API designers cleverly choose the name 'InsertOnSubmit' which clearly describes that the element will only be visible after calling SubmitChanges.<br />
<br />
I must admit that the sole reason for me to introduce this abstraction was for testability. It was that question on Stackoverflow that triggered me to think about the switchability of this design. However, when you look at the given list of short comes, I think we can conclude that it is pretty be hard to create an abstraction that doesn't leak and allows you to easily switch from one persistence technology to another, while allowing LINQ over expression tree queries.<br />
<br />
Cheers<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven'  title='www.cuttingedge.it/blogs/steven'>URL</a>) - 16 11 10 - 20:41 </small></p>
<p>Steven,<br />
<br />
Why don't you implement a DefaultRepository which derives from Repository and tell your IoC framework to return that one if there's no specific repository defined? This way you'll only have to implement the default behavior once and make explicit classes (which immediately makes it nice and clean where to look for specific code) for repositories that need specific code.<br /><small><b>Hans</b>  (<a href='http://www.thekip.nl'  title='www.thekip.nl'>URL</a>) - 16 11 10 - 21:53 </small></p>
<p>That's why they introduced the "Leaky Abstraction" anti-pattern :-) Unfortunately, nobody has solved it, yet.<br />
<br />
I'm going to think a bit more about your design. I hate the fact that I currently have to use three or more repository stubs to unit test my business command handlers.<br /><small><b>Dennis Doomen</b>  (<a href='http://www.dennisdoomen.net'  title='www.dennisdoomen.net'>URL</a>) - 17 11 10 - 08:46 </small></p>
<p>Steven,<br />
<br />
I posted the following comment on the StackOverflow thread as well for continuity:<br />
<br />
Sorry it took so long to respond, but I do appreciate the detailed explanation in your blog post. A couple quick follow-ups:<br />
<br />
First, why extension methods versus a strongly-typed subclass?<br />
<br />
And second, how would you handle an entity (in business object terms) that required data from two data contexts (e.g. part of the data is stored in a SQL Server db with the rest in a DB2 or Oracle db)?  In other words, the business command or service needs to return an object (or list of objects) that is an Aggregate Root (to steal the DDD term) with its data stored across two distinct (and unlinkable) data stores.  Would it be up to the service or command to manage two UoW or would there be a different UoW for this operation?<br /><small><b>SonOfPirate</b>  (<a href='http://www.sonofpirate.com'  title='www.sonofpirate.com'>URL</a>) - 29 11 10 - 19:35 </small></p>
<p>SonOfPirate,<br />
<br />
Using extension methods the way I described in my post allows you to have a single repository class. Having methods like GetById and FindPersonsByName on the repository means we have to create class for each entity. To make things worse, you probably end up defining a test repository for each entity as well. This results in a lot of extra code and thus a lot of work in creating and maintaining those classes. That's why I choose extension methods. However, it depends on your project whether this will work for you.<br /><small><b>Steven</b>   - 29 11 10 - 22:33 </small></p>
<p>Steven,<br />
<br />
I guess I'm still not sure why it is better to use extension methods. I disagree that it is saving you any code since you still have to implement and maintain the extension methods.  Plus, we use a mocking framework so I don't manually create test repositories.  And, with a dependency injection container, instantiating strongly-typed repositories isn't that big of a deal.<br />
<br />
Don't get me wrong, I love extension methods and use them to solve all kinds of problems.  But, I develop code that is consumed, used and/or maintained by other developers that might not be on the same page so I'd like to be able to explain and justify the approach.<br />
<br />
Here's how I would have created the sub-classes:<br />
<br />
public class CustomerRepository : Repository&lt;Customer&gt;<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;public Customer GetById(string id)<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Single(Where(e => e.Id == id), id);<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
public class EmployeeRepository : Repository&lt;Employee&gt;<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;public Employee GetById(int id)<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Single(Where(e => e.Id == id), id);<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
public class OrderRepository : Repository&lt;Order&gt;<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;public static Order GetById(int id)<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Single(Where(e => e.Id == id), id);<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
Does it just boil down to personal preference or is there a concrete benefit to using extension methods that I'm simply missing?<br /><small><b>SonOfPirate</b>   - 30 11 10 - 13:43 </small></p>
<p>No single design is good for every solution. I'm just describing a model that worked well in my situation. You have got other tools, other developers, other requirements. It all influences the design. If you're not sure whether to use extension methods or go with sub types, I recommend you to write a test project to try it out. Find out how to write your UnitOfWork classes, how to write your tests, how to hook everything op in your IoC container. Pick what works best for you.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'>URL</a>) - 30 11 10 - 15:25 </small></p>
<p>What is missing from your example is true persistance ignorance.  Everything you've described works great to decouple and abstract the data access code (and thereby the technology) except that you are strongly-typing everything to the Linq-to-SQL entity types.<br />
<br />
I've had good success accomplishing this by introducing interfaces for the entities that the Unit of Work and Repository classes (as well as calling code) will use.  Then I simply create a partial for each generated entity class that implements this interface.  And this works great for a simple model, however, ...<br />
<br />
Where I get stuck is accomplishing this with one-to-many parent-child relationships. For instance, in your example each Customer entity would implement an ICustomer interface with an Orders property of type ICollection&lt;Order&gt;. This will generate a compilation error as EntitySet can be cast to ICollection&lt;Order&gt; but not to a collection of the interfaces. And using the Linq Cast&lt;&gt;() method returns and IEnumerable. The only way I've found to satisfy the interface is to implement the property explicitly and return Orders.Cast&lt;IOrder&gt;().ToList() which, of course, forces the Linq statement to execute and any further clauses are not performed against the in-memory copy of the list. I'd prefer a way that returned the list so that additional clauses can be added before the query is executed.<br />
<br />
Any thoughts on this?<br /><small><b>SonOfPirate</b>   - 15 03 11 - 14:41 </small></p>
<p>Hiding your entities behind an interface will not work, because most (if not all) LINQ providers can only work with queries over entities. With interfaces, they just don't know what to do with them. If you want true persistance ignorance, you should go with POCO entities. Both EF4 and L2S allow you to work with POCOs.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'>URL</a>) - 15 03 11 - 15:24 </small></p>
<p>this post is rather old. There is no "RegisterSingle" in the current Unity.<br /><small><b>Blaise</b>   - 30 10 12 - 16:18 </small></p>
<p>@Blaise, the article doesn't mention Unity. The registration examples are for a hypothetical DI container. For Unity, you will have to use RegisterType and supply a ContainerControlledLifetimeManager. But you might want to try another container, such as <a href="http://simpleinjector.codeplex.com/.">http://simpleinjector.codeplex.com/.</a><br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84'>URL</a>) - 30 10 12 - 16:31 </small></p>
<a id="lastcomment"></a><p>Steven,<br />
Considering changes in EF, are you still defend your proposed design or this post is old and is not defendable anymore?<br /><small><b>Alireza</b>   - 31 01 13 - 09:53 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>