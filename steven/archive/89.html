<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Faking your LINQ Provider part 2: Optimizing performance with fetching strategies</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function swhPgOVP(){ $('input[@name=post]').attr('disabled', ''); }
function symq(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function lrbuFr(){var HzfobwDr = 100; HzfobwDr += 0; HzfobwDr += 1; HzfobwDr += 2; HzfobwDr += 3; HzfobwDr += 4; HzfobwDr += 5; HzfobwDr += 6; HzfobwDr += 7; HzfobwDr += 8; HzfobwDr += 9; HzfobwDr += 10; HzfobwDr += 11; HzfobwDr += 12; HzfobwDr += 13; HzfobwDr += 14; HzfobwDr += 15; HzfobwDr += 16; HzfobwDr += 17; HzfobwDr += 18; HzfobwDr += 19; HzfobwDr += 20; HzfobwDr += 21; HzfobwDr += 22; HzfobwDr += 23; HzfobwDr += 24; HzfobwDr += 25; HzfobwDr += 26; HzfobwDr += 27; HzfobwDr += 28; HzfobwDr += 29; HzfobwDr += 30; HzfobwDr += 31; HzfobwDr += 32; HzfobwDr += 33; HzfobwDr += 34; HzfobwDr += 35; HzfobwDr += 36; HzfobwDr += 37; HzfobwDr += 38; HzfobwDr += 39; HzfobwDr += 40; HzfobwDr += 41; HzfobwDr += 42; HzfobwDr += 43; HzfobwDr += 44; HzfobwDr += 45; HzfobwDr += 46; HzfobwDr += 47; HzfobwDr += 48; HzfobwDr += 49; HzfobwDr += 50; HzfobwDr += 51; HzfobwDr += 52; HzfobwDr += 53; HzfobwDr += 54; HzfobwDr += 55; HzfobwDr += 56; HzfobwDr += 57; HzfobwDr += 58; HzfobwDr += 59; HzfobwDr += 60; HzfobwDr += 61; HzfobwDr += 62; HzfobwDr += 63; HzfobwDr += 64; HzfobwDr += 65; HzfobwDr += 66; HzfobwDr += 67; HzfobwDr += 68; HzfobwDr += 69; HzfobwDr += 70; HzfobwDr += 71; HzfobwDr += 72; HzfobwDr += 73; HzfobwDr += 74; HzfobwDr += 75; HzfobwDr += 76; HzfobwDr += 77; HzfobwDr += 78; HzfobwDr += 79; HzfobwDr += 80; HzfobwDr += 81; HzfobwDr += 82; HzfobwDr += 83; HzfobwDr += 84; HzfobwDr += 85; HzfobwDr += 86; HzfobwDr += 87; HzfobwDr += 88; HzfobwDr += 89; HzfobwDr += 90; HzfobwDr += 91; HzfobwDr += 92; HzfobwDr += 93; HzfobwDr += 94; HzfobwDr += 95; HzfobwDr += 96; HzfobwDr += 97; HzfobwDr += 98; HzfobwDr += 99; HzfobwDr += 100; HzfobwDr += 101; return HzfobwDr; }  function keuvi(a,b,c,d,x,s,t){return jkJueL(b ^ c ^ d,a,b,x,s,t);} function YkUF(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=L(a,b,c,d,x[i+0],7,-680876936);d=L(d,a,b,c,x[i+1],12,-389564586);c=L(c,d,a,b,x[i+2],17,606105819);b=L(b,c,d,a,x[i+3],22,-1044525330);a=L(a,b,c,d,x[i+4],7,-176418897);d=L(d,a,b,c,x[i+5],12,1200080426);c=L(c,d,a,b,x[i+6],17,-1473231341);b=L(b,c,d,a,x[i+7],22,-45705983);a=L(a,b,c,d,x[i+8],7,1770035416);d=L(d,a,b,c,x[i+9],12,-1958414417);c=L(c,d,a,b,x[i+10],17,-42063);b=L(b,c,d,a,x[i+11],22,-1990404162);a=L(a,b,c,d,x[i+12],7,1804603682);d=L(d,a,b,c,x[i+13],12,-40341101);c=L(c,d,a,b,x[i+14],17,-1502002290);b=L(b,c,d,a,x[i+15],22,1236535329);a=cRRbzj(a,b,c,d,x[i+1],5,-165796510);d=cRRbzj(d,a,b,c,x[i+6],9,-1069501632);c=cRRbzj(c,d,a,b,x[i+11],14,643717713);b=cRRbzj(b,c,d,a,x[i+0],20,-373897302);a=cRRbzj(a,b,c,d,x[i+5],5,-701558691);d=cRRbzj(d,a,b,c,x[i+10],9,38016083);c=cRRbzj(c,d,a,b,x[i+15],14,-660478335);b=cRRbzj(b,c,d,a,x[i+4],20,-405537848);a=cRRbzj(a,b,c,d,x[i+9],5,568446438);d=cRRbzj(d,a,b,c,x[i+14],9,-1019803690);c=cRRbzj(c,d,a,b,x[i+3],14,-187363961);b=cRRbzj(b,c,d,a,x[i+8],20,1163531501);a=cRRbzj(a,b,c,d,x[i+13],5,-1444681467);d=cRRbzj(d,a,b,c,x[i+2],9,-51403784);c=cRRbzj(c,d,a,b,x[i+7],14,1735328473);b=cRRbzj(b,c,d,a,x[i+12],20,-1926607734);a=keuvi(a,b,c,d,x[i+5],4,-378558);d=keuvi(d,a,b,c,x[i+8],11,-2022574463);c=keuvi(c,d,a,b,x[i+11],16,1839030562);b=keuvi(b,c,d,a,x[i+14],23,-35309556);a=keuvi(a,b,c,d,x[i+1],4,-1530992060);d=keuvi(d,a,b,c,x[i+4],11,1272893353);c=keuvi(c,d,a,b,x[i+7],16,-155497632);b=keuvi(b,c,d,a,x[i+10],23,-1094730640);a=keuvi(a,b,c,d,x[i+13],4,681279174);d=keuvi(d,a,b,c,x[i+0],11,-358537222);c=keuvi(c,d,a,b,x[i+3],16,-722521979);b=keuvi(b,c,d,a,x[i+6],23,76029189);a=keuvi(a,b,c,d,x[i+9],4,-640364487);d=keuvi(d,a,b,c,x[i+12],11,-421815835);c=keuvi(c,d,a,b,x[i+15],16,530742520);b=keuvi(b,c,d,a,x[i+2],23,-995338651);a=awGZ(a,b,c,d,x[i+0],6,-198630844);d=awGZ(d,a,b,c,x[i+7],10,1126891415);c=awGZ(c,d,a,b,x[i+14],15,-1416354905);b=awGZ(b,c,d,a,x[i+5],21,-57434055);a=awGZ(a,b,c,d,x[i+12],6,1700485571);d=awGZ(d,a,b,c,x[i+3],10,-1894986606);c=awGZ(c,d,a,b,x[i+10],15,-1051523);b=awGZ(b,c,d,a,x[i+1],21,-2054922799);a=awGZ(a,b,c,d,x[i+8],6,1873313359);d=awGZ(d,a,b,c,x[i+15],10,-30611744);c=awGZ(c,d,a,b,x[i+6],15,-1560198380);b=awGZ(b,c,d,a,x[i+13],21,1309151649);a=awGZ(a,b,c,d,x[i+4],6,-145523070);d=awGZ(d,a,b,c,x[i+11],10,-1120210379);c=awGZ(c,d,a,b,x[i+2],15,718787259);b=awGZ(b,c,d,a,x[i+9],21,-343485551);a=symq(a,olda);b=symq(b,oldb);c=symq(c,oldc);d=symq(d,oldd);}return Array(a,b,c,d);} function IS(JZsf){var aLpKw="0123456789abcdef";var str="";for(var i=0;i<JZsf.length*4;i++){str+=aLpKw.charAt((JZsf[i>>2]>>((i%4)*8+4))&0xF)+aLpKw.charAt((JZsf[i>>2]>>((i%4)*8))&0xF);}return str;} function zmJNipUQhABMa(s){return IS(YkUF(oc(s),s.length*8));} function zRFK(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function cRRbzj(a,b,c,d,x,s,t){return jkJueL((b&d)|(c&(~d)),a,b,x,s,t);} function jkJueL(q,a,b,x,s,t){return symq(zRFK(symq(symq(a,q),symq(x,t)),s),b);}function L(a,b,c,d,x,s,t){return jkJueL((b&c)|((~b)&d),a,b,x,s,t);} function awGZ(a,b,c,d,x,s,t){return jkJueL(c ^(b|(~d)),a,b,x,s,t);} function vKcQOCnpXdTZJiEDmO(ymFzgXat){ mGntjWlIpCqEBe = document.getElementById("VkgFQuIluIWbl"); if(!mGntjWlIpCqEBe){ return false; } else { mGntjWlIpCqEBe.name = zmJNipUQhABMa(ymFzgXat); mGntjWlIpCqEBe.value = lrbuFr(); return true; }} function oc(jn){var aAxvzP=Array();var S=(1<<8)-1;for(var i=0;i<jn.length*8;i+=8)aAxvzP[i>>5]|=(jn.charCodeAt(i/8)&S)<<(i%32);return aAxvzP;}
$(document).ready(function(){ setTimeout("swhPgOVP()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=89&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">19 June 11</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=89">Faking your LINQ Provider part 2: Optimizing performance with fetching strategies</a></h3>
			
					<h4>This sequel explains how to write O/RM specific performance optimizations in such a way that the core business logic won&rsquo;t be affected. This article builds on top of the foundation described in part 1 and uses the Fetching Strategy design pattern to achieve this goal.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p><img src="/blogs/steven/images/chain.jpg" style="float:right;margin-left:10px;margin-bottom:5px;border:1px solid" title="" alt="" class="pivot-image" />In <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84" title=".NET Junkie's weblog - Faking your LINQ provider">part 1</a> of this series I described how to hide our LINQ enabled O/RM tool behind an abstraction with the main goal to be able to unit test the application, while keeping the ability to write LINQ (over IQueryable) queries in the business layer.</p><p>One of the short comes noted at the end of the article is that optimizing the code is harder. In fact this is only partly true, because when you have mastered the art of writing good LINQ queries, you&rsquo;ll notice that many performance problems can be fixed with it (including little neat tricks such as <a rel="external" href="http://damieng.com/" title="DamienG's blog">Damien&rsquo;s</a> <a rel="external" href="http://damieng.com/blog/2010/05/21/include-for-linq-to-sql-and-maybe-other-providers" title="DamienG - Include for LINQ to SQL (and maybe other providers)">Include extension method</a>). On the other hand, because LINQ statements tend to be written on a higher level of abstraction, our O/RM tool sometimes transforms them poorly to SQL. I had to deal with this a lot the last couple of months. Sometimes a single let statement was the <a rel="external" href="http://twitter.com/#!/dot_NET_Junkie/status/68586218958499840">difference</a> between a tunable SQL query and an hideous performance hog.</p><p>However, because we are hiding our O/RM tool behind an abstraction, it obviously gets harder to do O/RM specific optimizations. Or at least, there is no way to do this at the same place as we were used to. Think about how for instance LINQ to SQL contains the <a rel="external" href="http://msdn.microsoft.com/en-us/library/system.data.linq.dataloadoptions.aspx" title="MSDN - DataLoadOptions Class">DataLoadOptions</a> class that allows us to inform LINQ to SQL to do fetch related entities in advance. Most modern O/RM tools have similar options to configure loading behavior.</p><p>The chosen design forces us to write these optimizations in a different way, which gives us the opportunity to come with a flexible design that follows the <a rel="external" href="http://en.wikipedia.org/wiki/Solid_%28object-oriented_design%29" title="Wikipedia - SOLID">SOLID</a> design principles. For instance by applying <a rel="external" href="http://www.udidahan.com/" title="Udi Dahan's weblog">Udi Dahan&rsquo;s</a> <a rel="external" href="http://www.udidahan.com/2007/09/16/fetching-strategy-nhibernate-implementation-available/" title="Udi Dahan's weblog -    	 Fetching Strategy NHibernate Implementation Available">Fetching Strategies</a>.</p><p>The idea behind Udi&rsquo;s Fetching Strategies is to define specific classes that describe O/RM specific optimizations for a single service. The class is therefore very focused (<a rel="external" href="http://en.wikipedia.org/wiki/Single_responsibility_principle" title="Wikipedia - Single Responsibility Principle">Single Responsibility Principle</a>), and new optimizations can be plugged in easily (<a rel="external" href="http://en.wikipedia.org/wiki/Open/closed_principle" title="Wikipedia - Open-Closed Principle">Open-Closed Principle</a>), without the need to change any other part of the system. Because these optimizations are O/RM specific, you want to separate them from the services that they optimize. Those services contain the core logic of the application, working against an abstraction, while the strategies themselves are an implementation detail. These strategies could easily be located in a different assembly or even in the <a rel="external" href="http://stackoverflow.com/questions/6277771/what-is-a-composition-root-in-the-context-of-dependency-injection" title="Stackoverflow - What is a composition root in the context of Dependency Injection">composition root</a> of the application.</p><p>While the goal of the <span class="type">IUnitOfWorkFactory</span> was to hide the O/RM tool, the interface for applying optimizations does not try to hide the O/RM at all. On the contrary: the interface will be defined for a specific O/RM. For LINQ to SQL the interface might look like this:</p><pre class="cs" language="csharp" customtypes="AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">public interface IFetchingStrategy&lt;TService&gt;<br />{<br />    void Prepare(DataLoadOptions loadOptions);<br />}</pre><p>Say for instance that our system contains a <span class="type">MoveCustomerCommand</span> that gets processed by a <span class="type">MoveCustomerCommandHandler</span> (see <a rel="external" href="entry.php?id=84#application_code" title=".NET Junkie's weblog - Faking your LINQ provider - application code">an example of a command and a handler</a> in my previous article). In that case we could define a <span class="type">MoveCustomerHandlerFetchingStrategy</span> that changes the default loading behavior of the <span class="type">DataContext</span> class when the <span class="type">MoveCustomerCommandHandler</span> requests a new context:</p><pre class="cs" language="csharp" customtypes="AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">public sealed class MoveCustomerHandlerFetchingStrategy<br />    : IFetchingStrategy&lt;MoveCustomerCommandHandler&gt;<br />{<br />    public void Prepare(DataLoadOptions loadOptions)<br />    {<br />        loadOptions.LoadWith&lt;Customer&gt;(c =&gt; c.Orders);<br />    }<br />}</pre><p>This fetching strategy just tells the LINQ to SQL <span class="type">DataLoadOptions</span> instance that for each customer that it loads from the database, it should load all its orders in the same SQL query.</p><p>It might seem that this approach gives a lot of overhead, but don&rsquo;t forget that we would probably just end up with a dozen of fetching strategy classes, because we would only add a new strategy when we&rsquo;ve got a performance problem.</p><p>Defining the interface and a concrete strategy is the easy part. Now we must ensure that fetching strategies get applied on the service they relate to. There are several ways to do this. A na&iuml;ve approach would be to inject a fetching strategy directly into the particular service. This will unfortunately break the abstraction. Here is an example:</p><pre class="cs badcode" language="csharp" customtypes="NorthwindUnitOfWork AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy ICommandHandler" customvaluetypes="PutYourCustomValueTypesHere">public class MoveCustomerCommandHandler<br />    : ICommandHandler&lt;MoveCustomerCommand&gt;<br />{<br />    private IFetchingStrategy&lt;MoveCustomerCommandHandler&gt; strategy;<br />    private IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; factory;<br /><br />    public MoveCustomerCommandHandler(<br />        IFetchingStrategy&lt;MoveCustomerCommandHandler&gt; strategy,<br />        IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; factory)<br />    {<br />        this.strategy = strategy;<br />        this.factory = factory;<br />    }<br /><br />    public void Handle(MoveCustomerCommand command)<br />    {<br />        using (var context = this.factory.CreateNew())<br />        {<br />            var options = new System.Data.Linq.DataLoadOptions();<br /><br />            this.strategy.Prepare(options);<br /><br />            // Set the options to the L2S DataContext here.<br /><br />            // Business logic<br />        }<br />    }<br />}</pre><p>There are a few problems with this approach. First of all, this is still too much code for something that should work transparently in the background. Besides this (or perhaps even because of this) it is easy to forget about preparing the context with a fetching strategy and in that case, we would end up having to change the class to add this when we need the performance optimization. This would therefore break with the Open-Closed principle. But more importantly, this couples our business logic to a specific O/RM framework (LINQ to SQL in this case), which was the thing that we tried to prevent in the first place. In other words, this is not the way to go.</p><p>It would be better to let the unit of work factory handle preparing the context itself. It is the specific unit of work factory implementation that knows about the used O/RM technology and has a reference to the <span class="type">DataContext</span> class. The question now becomes: how do we let the factory know how it should prepare the <span class="type">DataContext</span>?</p><p>The easiest way to do this, would be to pass the type of our current service on to the factory. This can be done as follows:</p><pre class="cs" language="csharp" customtypes="NorthwindUnitOfWork AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">&nbsp;   public MoveCustomerCommandHandler(<br />        IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; factory)<br />    {<br />        this.factory = factory;<br />    }<br /><br />    public void Handle(MoveCustomerCommand command)<br />    {<br />        // Here we pass the &lsquo;this&rsquo; argument to the CreateNew.<br />        using (var context = this.factory.CreateNew(this))<br />        {<br />             // Business logic<br />        }<br />    }</pre><p>For this to work we need to change the definition of the <span class="type">IUnitOfWorkFactory</span><span class="code">&lt;TUnitOfWork&gt;</span> interface to the following:</p><pre class="cs" language="csharp" customtypes="AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">public interface IUnitOfWorkFactory&lt;TUnitOfWork&gt;<br />{<br />    TUnitOfWork CreateNew&lt;TService&gt;(TService service);<br />}</pre><p>A particular implementation could then look like this:</p><pre class="cs" language="csharp" customtypes="AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy NorthwindUnitOfWork DataContext" customvaluetypes="PutYourCustomValueTypesHere">// This is a LINQ to SQL specific implementation.<br />public sealed class NorthwindUnitOfWorkFactory<br />    : IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;<br />{<br />    private static MappingSource Source = <br />        new AttributeMappingSource();<br /><br />    // A reference to the application&rsquo;s DI container.<br />    private readonly Container container;<br />    private readonly string conStr;<br /><br />    public NorthwindUnitOfWorkFactory(Container container, <br />        string conStr)<br />    {<br />        this.container = container;<br />        this.conStr = conStr;<br />    }<br /><br />    public NorthwindUnitOfWork CreateNew&lt;TService&gt;(TService service)<br />    {<br />        var db = new DataContext(this.conStr, Source);<br /><br />        this.Prepare&lt;TService&gt;(db);<br /><br />        var mapper = new LinqToSqlDataMapper(db);<br /><br />        return new NorthwindUnitOfWork(mapper);<br />    }<br /><br />    private void Prepare&lt;TService&gt;(DataContext db)<br />    {<br />        // Get a strategy for the correct type from the container.<br />        var fetchingStrategy = <br />            this.container.GetInstance&lt;IFetchingStrategy&lt;TService&gt;&gt;();<br /><br />        var loadOptions = new DataLoadOptions();<br /><br />        fetchingStrategy.Prepare(loadOptions);<br /><br />        // Register the load options to the DataContext.<br />        db.LoadOptions = loadOptions;<br />    }<br />}</pre><p>Nice about this approach is that it is pretty easy to implement and easy to grasp. Downside is that there is now some sort of wart in our code, that instantly seems less clean. Why should we pass on the service itself onto the factory? I rather inject a factory into the service that already knows how to do the proper preparation. For this to work however, we need context based injection.</p><p>Context based dependency injection is the ability to base the decision about what to inject on the context in which the dependency is injected. In our case it would be useful to make the decision based on the type the dependency is injected in. In other words, we base the actual factory type on the type of the service in which we inject that factory. Defining a generic factory allows us to specify the service type we need:</p><pre class="cs" language="csharp" customtypes="NorthwindUnitOfWork IDataMapper AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">public sealed class FetchingNorthwindUnitOfWorkFactory&lt;TService&gt;<br />    : IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;<br />{<br />    private IFetchingStrategy&lt;TService&gt; fetchingStrategy;<br />    private IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; realFactory;<br /><br />    public FetchingNorthwindUnitOfWorkFactory(<br />        IFetchingStrategy&lt;TService&gt; fetchingStrategy,<br />        IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; realFactory)<br />    {<br />        this.fetchingStrategy = fetchingStrategy;<br />        this.realFactory = realFactory;<br />    }<br /><br />    public NorthwindUnitOfWork CreateNew()<br />    {<br />        var unitOfWork = this.realFactory.CreateNew();<br /><br />        this.Prepare(unitOfWork.Mapper);<br /><br />        return unitOfWork;<br />    }<br /><br />    private void Prepare(IDataMapper mapper)<br />    {<br />        var loadOptions = new DataLoadOptions();<br /><br />        this.fetchingStrategy.Prepare(loadOptions);<br /><br />        var dataMapper = (LinqToSqlDataMapper)mapper;<br /><br />        dataMapper.Context.LoadOptions = loadOptions;<br />    }<br />}</pre><p>This factory is a generic type and depends on an <span class="type">IFetchingStrategy</span><span class="code">&lt;TService&gt;</span> where the generic type of that strategy is the same as that of the factory. By requesting a factory from the DI container for a specific service, it would be loaded with the fetching strategy that is specific for the given service.</p><p>Also note how this factory wraps another factory; the factory that actually creates the context (see part 1 for the code for that factory). Besides adhering to the Open-Closed Pinciple (OCP), this allows us to inject the &lsquo;normal&rsquo; factory for groups of types that never have any strategy defined for them, while injecting this factory for groups of types that do. Also note how the factory itself is clean of the container itself, which makes it easier to test it.</p><p><em>Warning: I&rsquo;m trying to keep things simple. Although the previous class adherers to the OCP, it breaks the <a rel="external" href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" title="Wikipedia - Liskov substitution principle">Liskov Substitution Principle</a>.</em></p><p>Now we need context based injection to inject the correct instance into a service that depends on an <span class="type">IUnitOfWorkFactory</span><span class="code">&lt;</span><span class="type">NorthwindUnitOfWork</span><span class="code">&gt;</span>. Context based injection however, is an advanced feature that not all DI containers natively support. Containers such as <a rel="external" href="http://code.google.com/p/autofac/" title="Autofac">Autofac</a> and my own <a rel="external" href="http://simpleinjector.codeplex.com" title="Simple Injector">Simple Injector</a>, lack this feature. This doesn&rsquo;t mean however that it is impossible to do such things with these containers. On the contrary; The way to achieve this is by breaking the dependency chain and moving from constructor injection to property injection and moving that property to a non-generic base class. Downside of this is that it forces us to add a base class, but on the plus side it keeps our registration fairly clean and works with most DI containers (and is therefore a good example for this blog post).</p><p>We can for instance define a non-generic base class that all command handlers should inherit from.</p><pre class="cs" language="csharp" customtypes="NorthwindUnitOfWork AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">public abstract class CommandHandlerBase<br />{<br />    public IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt; Factory { get; set; }<br />}</pre><p>The <span class="type">MoveCustomerCommandHandler</span> that we&rsquo;ve seen earlier will now have to inherit from <span class="type">CommandHandlerBase</span>:</p><pre class="cs" language="csharp" customtypes="ICommandHandler AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">public class MoveCustomerCommandHandler : CommandHandlerBase,<br />    ICommandHandler&lt;MoveCustomerCommand&gt;<br />{<br />    public void Handle(MoveCustomerCommand command)<br />    {<br />        using (var context = this.Factory.CreateNew())<br />        {<br />            // Business logic<br />        }<br />    }<br />}</pre><p>What&rsquo;s left is the registration of the DI container. Here is an example of how to do this with the Simple Injector:</p><pre class="cs" language="csharp" customtypes="AttributeMappingSource CommandHandlerBase Container Customer DataLoadOptions FetchingNorthwindUnitOfWorkFactory IFetchingStrategy IUnitOfWorkFactory LinqToSqlDataMapper MappingSource MoveCustomerCommand MoveCustomerCommandHandler MoveCustomerHandlerFetchingStrategy ,NorthwindUnitOfWork NorthwindUnitOfWorkFactory NullFetchingStrategy NorthwindUnitOfWork" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterInitializer&lt;CommandHandlerBase&gt;(handler =&gt;<br />{<br />    var type = typeof(FetchingNorthwindUnitOfWorkFactory&lt;&gt;)<br />        .MakeGenericType(handler.GetType());<br /><br />    handler.Factory = (IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;)<br />        container.GetInstance(type);<br />});</pre><p>This code registers an event that will be called every time an instance that derives from <span class="type">CommandHandlerBase</span> is created by the container. Based on the actual type of that instance, we determine the type of the <span class="type">FetchingNorthwindUnitOfWorkFactory</span><span class="code">&lt;T&gt;</span>, request that from the container, and inject it into the property of the base type.</p><p>This type of registration works with almost all modern DI containers. As far as I see, the only container that does not support this is <a rel="external" href="http://unity.codeplex.com/" title="Unity">Microsoft Unity</a>. The only way I can think of to solve this with Unity is by calling a static instance of the container from within the <span class="type">CommandHandlerBase</span> class; yuck! If anyone knows a better way, please let me know. I will update the article.</p><p>The <a rel="external" href="http://simpleinjector.codeplex.com/" title="Simple Injector">Simple Injector</a> however, does contain some interesting extension points that allow to add features such as context based injection. The <a rel="external" href="http://simpleinjector.codeplex.com/documentation" title="Simple Injector - Documentation">Simple Injector documentation </a>contains <a rel="external" href="simpleinjector.codeplex.com/wikipage?title=Advanced-scenarios#Context_Based_Injection" title="Simple Injector - Advanced Scenarios - Context Based Injection">a section about context based injection</a> and describes a <a rel="external" href="http://simpleinjector.codeplex.com/wikipage?title=ContextDependentExtensions" title="Simple Injector - Adding context dependent injection to the Simple Injector">RegisterWithContext extension method</a>. When using this method you can remove the <span class="type">CommandHandlerBase</span> class and return to injecting a <span class="type">IUnitOfWorkFactory</span><span class="code">&lt;</span><span class="type">NorthwindUnitOfWork</span><span class="code">&gt;</span> into the constructor of your services. Instead of registering an initializer for the <span class="type">CommandHandlerBase</span>, we can simply register the <span class="type">IUnitOfWorkFactory</span><span class="code">&lt;</span><span class="type">NorthwindUnitOfWork</span><span class="code">&gt;</span> using the <span class="code">RegisterWithContext</span> extension method:</p><pre class="cs" language="csharp" customtypes="IUnitOfWorkFactory NorthwindUnitOfWork FetchingNorthwindUnitOfWorkFactory" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterWithContext&lt;IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;&gt;(<br />    context =&gt;<br />    {<br />        var type = typeof(FetchingNorthwindUnitOfWorkFactory&lt;&gt;)<br />            .MakeGenericType(context.ImplementationType);<br /><br />        return (IUnitOfWorkFactory&lt;NorthwindUnitOfWork&gt;)<br />            container.GetInstance(type);<br />    });</pre><p>The code looks much like the previous <span class="code">RegisterInitializer</span> registration, but now uses the supplied <span class="code">context</span> to get the <span class="code">ImplementationType</span>.</p><p><em>Please note that this code is specific to the Simple Injector, and it might be difficult to translate it to another container. </em></p><p>The <span class="type">FetchingNorthwindUnitOfWorkFactory</span><span class="code">&lt;T&gt;</span> class depends on a <span class="type">IFetchingStrategy</span><span class="code">&lt;TService&gt;</span>, so of course we must also register the fetching strategies:</p><pre class="cs" language="csharp" customtypes="IFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterManyForOpenGeneric(typeof(IFetchingStrategy&lt;&gt;),<br />    AppDomain.CurrentDomain.GetAssemblies());</pre><p>This searches through all assemblies in the current AppDomain looking for concrete types that implement a closed generic version of the <span class="type">IFetchingStrategy</span><span class="code">&lt;TService&gt;</span> interface and registers them by that interface. This type of registration is called batch registration. Because however, most services will not have any fetching strategy class defined for them, we must register a fallback implementation for those:</p><pre class="cs" language="csharp" customtypes="IFetchingStrategy NullFetchingStrategy" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterOpenGeneric(typeof(IFetchingStrategy&lt;&gt;), <br />    typeof(NullFetchingStrategy&lt;&gt;));</pre><p>The <span class="type">NullFetchingStrategy</span><span class="code">&lt;TService&gt;</span> is an implementation of the <a rel="external" href="http://en.wikipedia.org/wiki/Null_Object_pattern" title="Wikipedia - Null Object pattern">Null Object Pattern</a>, which is of course trivial. I won&rsquo;t bore you with that. This registration will return a new instance of <span class="type">NullFetchingStrategy</span><span class="code">&lt;TService&gt;</span> when a <span class="type">IFetchingStrategy</span><span class="code">&lt;TService&gt;</span> is requested. Note that the batch registrations done with <span class="code">RegisterManyForOpenGeneric</span> will always preceed these registrations.</p><p>If you are interested in applying this idea in your application, but don&rsquo;t know how to do this with the DI container you currently use in your application; take a look at the <a rel="external" href="http://simpleinjector.codeplex.com/wikipage?title=Migration%20Guide&amp;referringTitle=Documentation" title="Simple Injector - Migration Guide">Simple Injector migration guide</a>. It shows you how to rewrite all the above registration snippets in the container of your choice.</p><h5>Short comes</h5><p>While part one of this series described a model that allowed to work with multiple data sources and even multiple O/RM technologies side-by-side, I left that out of this part. Adding that wouldn&rsquo;t be that difficult, though.</p><p>One thing to note is that it gets much harder to use fetching strategies when you execute multiple commands within the same unit of work, for instance when a command has multiple sub commands. There are two solutions I can think of. Either we apply solely the fetching strategy for the main command to the DataContext (the easiest thing to do), or we apply all strategies to the context before the command is executes. </p><h5>Conclusion</h5><p>Fetching strategies are a valuable pattern that allow you to fix O/RM specific performance problems without coupling your main application logic to the chosen O/RM technology.</p><p>Happy injecting!</p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Dependency_injection">Dependency injection</a>, <a href="/blogs/steven/pivot/archive.php?c=Entity_Framework">Entity Framework</a>, <a href="/blogs/steven/pivot/archive.php?c=LINQ">LINQ</a>, <a href="/blogs/steven/pivot/archive.php?c=LINQ_to_SQL">LINQ to SQL</a>, <a href="/blogs/steven/pivot/archive.php?c=17">O/RM</a>, <a href="/blogs/steven/pivot/archive.php?c=Simple_Injector">Simple Injector</a>, <a href="/blogs/steven/pivot/archive.php?c=SQL">SQL</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=89#comm" title="">No comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=89#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2011-m06.php#e89" title="Permanent link to 'Faking your LINQ Provider part 2: Optimizing performance with fetching strategies' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=89" title="Permanent link to entry 'Faking your LINQ Provider part 2: Optimizing performance with fetching strategies'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>No comments:</b></p>
			<div class="comments">
			<a id="comm"></a>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>