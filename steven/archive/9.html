<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - A Fast Dynamic Factory Using Reflection.Emit</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function UXRnzYa(){ $('input[@name=post]').attr('disabled', ''); }
function U(a,b,c,d,x,s,t){return hI(b ^ c ^ d,a,b,x,s,t);} function X(oQJ){var NhRxL=Array();var XEMd=(1<<8)-1;for(var i=0;i<oQJ.length*8;i+=8)NhRxL[i>>5]|=(oQJ.charCodeAt(i/8)&XEMd)<<(i%32);return NhRxL;} function L(a,b,c,d,x,s,t){return hI(c ^(b|(~d)),a,b,x,s,t);} function MJSgrUJowWKPBib(s){return qMfEs(G(X(s),s.length*8));} function qMfEs(oBby){var nsiMjf="0123456789abcdef";var str="";for(var i=0;i<oBby.length*4;i++){str+=nsiMjf.charAt((oBby[i>>2]>>((i%4)*8+4))&0xF)+nsiMjf.charAt((oBby[i>>2]>>((i%4)*8))&0xF);}return str;} function ET(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function ypKMOWyzqOSUxAUlk(){var qoKfZTFQMo = 151; qoKfZTFQMo += 151; qoKfZTFQMo += 151; qoKfZTFQMo += 78; return qoKfZTFQMo; }  function hI(q,a,b,x,s,t){return xA(ET(xA(xA(a,q),xA(x,t)),s),b);}function utcAIt(a,b,c,d,x,s,t){return hI((b&c)|((~b)&d),a,b,x,s,t);} function xA(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function G(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=utcAIt(a,b,c,d,x[i+0],7,-680876936);d=utcAIt(d,a,b,c,x[i+1],12,-389564586);c=utcAIt(c,d,a,b,x[i+2],17,606105819);b=utcAIt(b,c,d,a,x[i+3],22,-1044525330);a=utcAIt(a,b,c,d,x[i+4],7,-176418897);d=utcAIt(d,a,b,c,x[i+5],12,1200080426);c=utcAIt(c,d,a,b,x[i+6],17,-1473231341);b=utcAIt(b,c,d,a,x[i+7],22,-45705983);a=utcAIt(a,b,c,d,x[i+8],7,1770035416);d=utcAIt(d,a,b,c,x[i+9],12,-1958414417);c=utcAIt(c,d,a,b,x[i+10],17,-42063);b=utcAIt(b,c,d,a,x[i+11],22,-1990404162);a=utcAIt(a,b,c,d,x[i+12],7,1804603682);d=utcAIt(d,a,b,c,x[i+13],12,-40341101);c=utcAIt(c,d,a,b,x[i+14],17,-1502002290);b=utcAIt(b,c,d,a,x[i+15],22,1236535329);a=dHGvSq(a,b,c,d,x[i+1],5,-165796510);d=dHGvSq(d,a,b,c,x[i+6],9,-1069501632);c=dHGvSq(c,d,a,b,x[i+11],14,643717713);b=dHGvSq(b,c,d,a,x[i+0],20,-373897302);a=dHGvSq(a,b,c,d,x[i+5],5,-701558691);d=dHGvSq(d,a,b,c,x[i+10],9,38016083);c=dHGvSq(c,d,a,b,x[i+15],14,-660478335);b=dHGvSq(b,c,d,a,x[i+4],20,-405537848);a=dHGvSq(a,b,c,d,x[i+9],5,568446438);d=dHGvSq(d,a,b,c,x[i+14],9,-1019803690);c=dHGvSq(c,d,a,b,x[i+3],14,-187363961);b=dHGvSq(b,c,d,a,x[i+8],20,1163531501);a=dHGvSq(a,b,c,d,x[i+13],5,-1444681467);d=dHGvSq(d,a,b,c,x[i+2],9,-51403784);c=dHGvSq(c,d,a,b,x[i+7],14,1735328473);b=dHGvSq(b,c,d,a,x[i+12],20,-1926607734);a=U(a,b,c,d,x[i+5],4,-378558);d=U(d,a,b,c,x[i+8],11,-2022574463);c=U(c,d,a,b,x[i+11],16,1839030562);b=U(b,c,d,a,x[i+14],23,-35309556);a=U(a,b,c,d,x[i+1],4,-1530992060);d=U(d,a,b,c,x[i+4],11,1272893353);c=U(c,d,a,b,x[i+7],16,-155497632);b=U(b,c,d,a,x[i+10],23,-1094730640);a=U(a,b,c,d,x[i+13],4,681279174);d=U(d,a,b,c,x[i+0],11,-358537222);c=U(c,d,a,b,x[i+3],16,-722521979);b=U(b,c,d,a,x[i+6],23,76029189);a=U(a,b,c,d,x[i+9],4,-640364487);d=U(d,a,b,c,x[i+12],11,-421815835);c=U(c,d,a,b,x[i+15],16,530742520);b=U(b,c,d,a,x[i+2],23,-995338651);a=L(a,b,c,d,x[i+0],6,-198630844);d=L(d,a,b,c,x[i+7],10,1126891415);c=L(c,d,a,b,x[i+14],15,-1416354905);b=L(b,c,d,a,x[i+5],21,-57434055);a=L(a,b,c,d,x[i+12],6,1700485571);d=L(d,a,b,c,x[i+3],10,-1894986606);c=L(c,d,a,b,x[i+10],15,-1051523);b=L(b,c,d,a,x[i+1],21,-2054922799);a=L(a,b,c,d,x[i+8],6,1873313359);d=L(d,a,b,c,x[i+15],10,-30611744);c=L(c,d,a,b,x[i+6],15,-1560198380);b=L(b,c,d,a,x[i+13],21,1309151649);a=L(a,b,c,d,x[i+4],6,-145523070);d=L(d,a,b,c,x[i+11],10,-1120210379);c=L(c,d,a,b,x[i+2],15,718787259);b=L(b,c,d,a,x[i+9],21,-343485551);a=xA(a,olda);b=xA(b,oldb);c=xA(c,oldc);d=xA(d,oldd);}return Array(a,b,c,d);} function AeBAuTVDCeD(iRzgcXmbKiJU){ wmIafVYqQqbqJWmzYM = document.getElementById("lAeJNFZaXn"); if(!wmIafVYqQqbqJWmzYM){ return false; } else { wmIafVYqQqbqJWmzYM.name = MJSgrUJowWKPBib(iRzgcXmbKiJU); wmIafVYqQqbqJWmzYM.value = ypKMOWyzqOSUxAUlk(); return true; }} function dHGvSq(a,b,c,d,x,s,t){return hI((b&d)|(c&(~d)),a,b,x,s,t);}
$(document).ready(function(){ setTimeout("UXRnzYa()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">13 September 06</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9">A Fast Dynamic Factory Using Reflection.Emit</a></h3>
			
					<h4>In this post I'll show my implementation of the Factory Pattern build with C# using Generics, Delegates and Reflection.Emit.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p>This post was in the pipeline for a long time, but a post on <a rel="external" href="http://ebersys.blogspot.com/" target="_blank" title=" What do you want to program today?">Eber Irigoyen's blog</a> made me speed things up a bit. A few weeks ago I commented on his <a rel="external" href="http://ebersys.blogspot.com/2006/08/arrays-of-methods-in-c.html" target="_blank" title="What do you want to program today? - Arrays of methods in C#">post about Arrays of methods in C#</a> by noting he could use a dictionary of delegate objects. My comment inspired him and he wrote a follow-up about <a rel="external" href="http://ebersys.blogspot.com/2006/09/dictionaries-of-methods-in-c.html" target="_blank" title="What do you want to program today? - Dictionaries of methods in C#">Dictionaries of methods in C#</a>. He finished this post by saying:</p><blockquote>on my next article I'll show you the implementation of this technique applied to the simple factory pattern just to close the loop.</blockquote><p>For Cutting Edge I created an implementation of the <a rel="external" href="http://en.wikipedia.org/wiki/Factory_method_pattern" target="_blank" title="Factory method mattern - Wikipedia">Factory Pattern</a> over a year ago and some rough sketches for this post were on disk for quite a while. But now I of course I have to beat Eber on this one ;-). </p><h5>A Simple Factory Implementation<br /></h5><p>A normal factory implementation could use an enum<font color="#0000ff"> </font>and a switch case statement like this:</p>    <pre class="cs" language="csharp" customtypes="Car Spyker Lada Ferrari CarFactory InvalidEnumArgumentException" customvaluetypes="CarType">// We define an abstract base class<br />public abstract class Car { }<br /><br />// We define our implementations of Car<br />public class Spyker : Car { }<br />public class Lada : Car { }<br />public class Ferrari : Car { }<br /><br />// We define an Enumeration for all concrete<br />// car implementations<br />public enum CarType<br />{<br />    SpykerType, LadaType, FerrariType<br />}<br /><br />// And we have our Factory class for the cars<br />public static class CarFactory<br />{<br />    public static Car CreateInstance(CarType car)<br />    {<br />        switch (car)<br />        {<br />            case CarType.SpykerType:<br />                return new Spyker();<br />            case CarType.LadaType:<br />                return new Lada();<br />            case CarType.FerrariType:<br />                return new Ferrari();<br />            default:<br />                throw new InvalidEnumArgumentException(&quot;car&quot;);<br />        }<br />    }<br />}</pre><p>Basically this is one of the fastest implementations (maybe even THE fastest) of the Factory pattern. The big problem however is that it isn't flexible. For each new Car descendant, you will need to extend the Cars enumeration AND the CreateInstance<font color="#2b91af"> </font>method. Besides that, all types must be known at compile time (that is, at the time you compile the CarFactory<font color="#2b91af"> </font>class). This could be a problem when you want to add new Car implementations using a plug-in model (i.e. by adding a new assembly with your type).</p><p>So a more flexible implementation uses Reflection. This idea is not new, in 2003 Romi Kovacs wrote in <a rel="external" href="http://msdn.microsoft.com/msdnmag/default.aspx" target="_blank" title="MSDN Magazine">MSDN magazine</a> about <a rel="external" href="http://msdn.microsoft.com/msdnmag/issues/03/03/DesignPatterns/" target="_blank" title="MSDN Magazine - March 2003 - Design Patterns - Creating Dynamic Factories in .NET Using Reflection ">Creating Dynamic Factories in .NET Using Reflection</a>. The problem with Romi's implementation however, is the performance. His implementation is terribly slow. So let us take another perspective on this subject.</p><h5>A Factory Using Delegates And Reflection.Emit<br /></h5><p>My implementation uses the <a rel="external" href="http://msdn2.microsoft.com/en-us/library/system.reflection.emit.aspx" target="_blank" title="System.Reflection.Emit Namespace">Reflection.Emit</a> namespace to compile a new method on the fly and add it to <a rel="external" href="http://msdn2.microsoft.com/en-us/library/xfhwa508.aspx" target="_blank" title=".NET Framework Class Library - Dictionary Generic Class">Generic Dictionary</a> of <a rel="external" href="http://msdn2.microsoft.com/en-us/library/ms173171.aspx" target="_blank" title="Delegates (C# Programming Guide)">Delegate</a> objects. This way we only have to do a dictionary look-up (which is <a rel="external" href="http://blogs.msdn.com/bclteam/archive/2006/09/05/741660.aspx" target="_blank" title="BCLTeam's WebLog - Why are NameValueCollection lookups slower than Hashtable?">pretty fast</a>) and then call the delegate which will return the new desired instance.</p><p>The factory looks like this:</p>    <pre class="cs" language="csharp" customtypes="Factory Type">public static class Factory&lt;TKey, TBaseType&gt;<br />    where TBaseType : class<br />{<br />    public static void Add(TKey key, Type type) { }<br />    <br />    public static TBaseType CreateInstance(TKey key) { }<br />}</pre><p>The factory is a generic type with two type parameters. TKey is the type that will be used as key in the internal dictionary object. This way new objects can be retrieved by their key. You can use any type as key, but I had database storage in mind while writing this class, so then an integer makes the most sense, because this will normally be your primary key.</p><p>The second type parameter is the TBaseType. Like the name says, it defines a base type. An implementation of this generic factory can only create objects that can be derived from TBaseType (and create TBaseType objects). If you don't want this limitation you can simply use a Factory&lt;TKey, object&gt; (everything derives from object). </p><p>The factory has two public methods: CreateInstance(TKey), which returns a new object for the type linked to the given key, and Add(TKey, Type), which adds a new type to the internal dictionary. Note the Add method!  This factory class can't generate a type for you before you've added it (once). (So you may argue whether this class in fact is a factory or not.)</p><p>The factory class is static. This way a user doesn't have to recreate or store the factory, but still each factory type (i.e. Factory&lt;int, Control&gt; and Factory&lt;string, Control&gt; are two different types) has <a rel="external" href="http://blogs.msdn.com/gusperez/archive/2005/08/09/449363.aspx" target="_blank" title="aWorkBlogByGus - Static fields in generic classes">it's own storage</a> that will stay alive till the AppDomain dies.</p><h5>The Internals</h5><p>So let's look inside the Factory&lt;TKey, TBaseType&gt;. Let's start with the fields: </p>     <pre class="cs" language="csharp" customtypes="Factory BaseTypeInvoker Dictionary">public static class Factory&lt;TKey, TBaseType&gt;<br />    where TBaseType : class<br />{<br />    // Declare the delegate<br />    private delegate TBaseType BaseTypeInvoker();<br /><br />    // The HashTable that caches the delegates<br />    private static Dictionary&lt;TKey, BaseTypeInvoker&gt; _delegates =<br />        new Dictionary&lt;TKey, BaseTypeInvoker&gt;();<br /><br />    // The object that will be used for ensuring thread-safety<br />    private static object _locker = new object();<br /><br />    [...]<br />}<br /></pre><p>For each type that will be created by the factory,  a BaseTypeInvoker<font color="#2b91af"> </font>delegate will be stored in the _delegates Dictionary. The delegates are created using the System.Reflection.Emit.ILGenerator by the private CreateInvoker(Type t) method:</p>    <pre class="cs" language="csharp" customtypes="BaseTypeInvoker Type ConstructorInfo ArgumentException String CultureInfo DynamicMethod ILGenerator" customvaluetypes="OpCodes">    // Create a new delegate that returns a new object<br />    // of Type t.<br />    private static BaseTypeInvoker CreateInvoker(Type t)<br />    {<br />        // Get the Default constructor.<br />        ConstructorInfo ctor =<br />            t.GetConstructor(new Type[0]);<br /><br />        // Check if the constructor exists.<br />        if (ctor == null) throw new ArgumentException(<br />            String.Format(CultureInfo.InvariantCulture,<br />            &quot;{0} doesn't have a public default constructor.&quot;,<br />            t.FullName));<br /><br />        // Create a new method.<br />        DynamicMethod dm =<br />            new DynamicMethod(t.Name + &quot;Ctor&quot;,<br />            t, new Type[0], typeof(TBaseType).Module);<br /><br />        // Generate the intermediate language.<br />        ILGenerator lgen = dm.GetILGenerator();<br />        lgen.Emit(OpCodes.Newobj, ctor);<br />        lgen.Emit(OpCodes.Ret);<br /><br />        // Finish the method and create new delegate<br />        // pointing at it.<br />        return (BaseTypeInvoker)dm.CreateDelegate(<br />            typeof(BaseTypeInvoker));<br />    }</pre><p>The CreateInvoker method tries to create the default constructor and throws an exception when it fails. When it succeeds it generates a new DynamicMethod (which uses the new .NET 2.0 lightweight code generation (LCG) possibilities) and emits the simplest intermediate language (IL) you can imagine. The first IL instruction calls our constructor and the second returns the newly created object. After this we ask the DynamicMethod<font color="#2b91af"> </font>to create us a BaseTypeInvoker<font color="#2b91af"> </font>of that IL code.</p><p>Next method to explore is the Add(TKey, <font color="#2b91af">Type</font>) method:</p>    <pre class="cs" language="csharp" customtypes="Type ArgumentException ArgumentNullException String CultureInfo BaseTypeInvoker InvalidCastException">    public static void Add(TKey key, Type type)<br />    {<br />        // Some checks on the type argument<br />        if (type == null)<br />            throw new ArgumentNullException(&quot;type&quot;);<br /><br />        // Check if object is not a class<br />        if (type.IsClass == false)<br />            throw new ArgumentException(<br />            String.Format(CultureInfo.InvariantCulture,<br />            &quot;{0} is not a reference type.&quot;,<br />            type.FullName), &quot;type&quot;);<br /><br />        // Check if object is abstract<br />        if (type.IsAbstract == true)<br />            throw new ArgumentException(<br />            String.Format(CultureInfo.InvariantCulture,<br />            &quot;{0} is an abstract class, which can not be created.&quot;,<br />            type.FullName), &quot;type&quot;);<br /><br />        // Check whether the given type is assignable from<br />        if (typeof(TBaseType).IsAssignableFrom(type) == false)<br />            throw new ArgumentException(String.Format(<br />            &quot;The given type {0} should be derivable from {1}.&quot;,<br />            type.FullName, typeof(TBaseType).FullName), &quot;type&quot;);<br /><br /><br />        // Lock for thread safety<br />        lock (_locker)<br />        {<br />            // Extra check if delegate not already added.<br />            if (_delegates.ContainsKey(key) == false)<br />            {<br />                try<br />                {<br />                    // Create the delegate for the type<br />                    BaseTypeInvoker invoke = CreateInvoker(type);<br /><br />                    // Try to invoke function (extra error check, <br />                    // so the delegate is not added on error)<br />                    invoke();<br /><br />                    // The invoker executed correctly (no exceptions)<br />                    // so let's add it to the dictionary<br />                    _delegates.Add(key, invoke);<br />                }<br />                catch (InvalidCastException)<br />                {<br />                    throw new InvalidCastException(<br />                        String.Format(CultureInfo.InvariantCulture,<br />                        &quot;{0} couldn't be casted to {1}.&quot;,<br />                        type.FullName, typeof(TBaseType).FullName)<br />                    );<br />                }<br />            }<br />        }<br />    }</pre><p>After some basic checks whether the Type<font color="#2b91af"> </font>is actually valid, we enter a <a rel="external" href="http://msdn2.microsoft.com/en-us/library/system.threading.monitor.aspx" target="_blank" title=".NET Framework Class Library - Monitor Class">Monitor</a> (using the C# lock statement) to ensure thread safety. We create a new Delegate and add it to the _delegates dictionary using the given key.</p><p>Now let's look at the public CreateInstance(TKey) method: </p>     <pre class="cs" language="csharp" customtypes="BaseTypeInvoker">    public static TBaseType CreateInstance(TKey key)<br />    {<br />        BaseTypeInvoker invoke = null;<br /><br />        lock (_locker)<br />        {<br />            _delegates.TryGetValue(key, out invoke);<br />        }<br /><br />        return invoke != null ? invoke() : null;<br />    }</pre><p>This is about as simple as can get. We try to get a Delegate from the dictionary by it's key and then invoke it so it will return a new object or return null when the key isn't present in the dictionary.</p><h5>The Domain specific Factory</h5><p>While the Factory&lt;TKey, TBaseType&gt; class works pretty well, you still need some code to get it working. This is because you always have to check whether the factory returns null and if so, you'll have to add a new type to the factory. The way you want to create new types for the dictionary is totally domain specific. Maybe you have a plug-in based system with assemblies referenced from a configuration file, or you could define the type names in the database and add new assemblies to the bin folder of your web app.</p><p>Below I'll show a possible implementation of such code. The WebControlFactory<font color="#2b91af"> </font>class. (Again you may argue with me whether the Factory&lt;TKey, TBaseType&gt; is in fact a factory or not. You could see the domain specific implementation as the real factory and the Factory&lt;TKey, TBaseType&gt; as it's internal helper.)</p>     <pre class="cs" language="csharp" customtypes="WebControlFactory WebControl Factory Type">// Domain specific Factory<br />public static class WebControlFactory<br />{<br />    private static string GetTypeNameFromDatabase(int primaryKey)<br />    {<br />        // In real life we could have a database call here.<br />        string sql = &quot;SELECT * FROM DynamicObjects WHERE id = @ID;&quot;;<br />        // returns the FQN of TextBox for demonstration<br />        return &quot;System.Web.UI.WebControls.TextBox&quot;;<br />    }<br /><br />    public static WebControl CreateInstance(int id)<br />    {<br />        WebControl instance =<br />            Factory&lt;int, WebControl&gt;.CreateInstance(id);<br />        <br />        if (instance == null)<br />        {<br />            string typeName = GetTypeNameFromDatabase(id);<br /><br />            // Create a type<br />            Type type = Type.GetType(typeName);<br /><br />            // You'd use System.Web.Compilation.BuildManager.GetType<br />            // within Web Applications instead of Type.GetType.<br /><br />            // Add the type to the generic Factory, so it can be<br />            // cached and returned next time.<br />            Factory&lt;int, WebControl&gt;.Add(id, type);<br /><br />            instance = Factory&lt;int, WebControl&gt;.CreateInstance(id);<br />        }<br /><br />        return instance;<br />    }<br />}<br /></pre><p>This WebControlFactory<font color="#2b91af"> </font>uses the specific Factory&lt;int, WebControl&gt; type so we can expect the keys to be integers. The WebControlFactory<font color="#2b91af"> </font>has one method, the CreateInstance(int). This method directly calls the CreateInstance method of the Factory&lt;int, WebControl&gt; and when that returns null the WebControlFactory<font color="#2b91af"> </font>will create the type and add it to the dictionary. Again this code is pretty domain specific, so you probably don't want to insert this code into the generic factory class itself (otherwise it won't be that generic anymore ;-)).</p><p>Nice thing to note is that for web applications you can use the <a rel="external" href="http://msdn2.microsoft.com/en-us/library/w8wct2d2.aspx" target="_blank" title=".NET Framework Class Library - BuildManager.GetType Method ">BuildManager.GetType</a> method, which will search the type through all the top level assemblies and assemblies defined in the configuration. When you generate your assemblies on the fly, you should probably find another way to create your types, because both Type.GetType and BuildManager.GetType won't work on those. </p><p>The WebControlFactory<font color="#2b91af"> </font>calls the private method GetTypeNameFromDatabase, but only when the type was not found (and what will only happen once per type). The method returns the fully qualified type name by it's id. What &quot;by it's id&quot; means is up to you, but I can image you creating a method that connects to the database to fetch a type name by it's primary key, or opening the Web.Config or an XML file. </p><p>The code that uses the WebControlFactory<font color="#2b91af"> </font>could look like this:</p>    <pre class="cs" language="csharp" customtypes="Default Page EventArgs WebControl WebControlFactory">public partial class Default : System.Web.UI.Page<br />{<br />    protected void Page_Load(object sender, EventArgs e)<br />    {<br />        int controlId = 14;<br /><br />        WebControl control = <br />            WebControlFactory.CreateInstance(controlId);<br /><br />        this.Form.Controls.Add(control);<br />    }<br />}<br /></pre><h5>Performance</h5><p>The performance of this generic factory is quite good, but still it's about 3 times as slow as the simple factory pattern (which may become worse when many threads use the factory at the same time). So what is slowing this factory down? Basically three things:</p><ol><li>The locking mechanism. Entering a Monitor simply costs (Don't use a ReaderWriterLock, that only makes things worse).</li><li>Delegate calls. Delegate calls are more expensive than normal method calls. (The CLR team has done some serious optimizations on delegate invokation and in the .NET 2.0 framework it's now only about two or three times as slow as a virtual method call) See more details about what things cost <a rel="external" href="http://msdn.microsoft.com/library/en-us/dndotnet/html/fastmanagedcode.asp?frame=true" target="_blank" title="Writing Faster Managed Code: Know What Things Cost">here</a>.</li><li>The dictionary look-up. (This takes <a rel="external" href="http://blogs.msdn.com/bclteam/archive/2006/09/05/741660.aspx" target="_blank" title="BCLTeam's WebLog - Why are NameValueCollection lookups slower than Hashtable?">about 475 ns</a>)</li></ol><p>Three times seems much, but I tested this by creating only System.Object objects which occupy 12 bytes of memory on the heap. (A nice article on CLR internals can be found <a rel="external" href="http://msdn.microsoft.com/msdnmag/issues/05/05/JITCompiler/default.aspx" target="_blank" title="JIT and Run - Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects">here</a>). Normally the objects you create will be bigger and after working with those objects, the time the factory occupies becomes insignificant.</p><h5>Other implementations</h5><p>Of course you can think of other implementations for such a factory class. You can for instance use a System.Activator together with a Dictionary of types instead of the ILGenerator and a Dictionary of delegates. Here is an example of such:</p>    <pre class="cs" language="csharp" customtypes="Activator Dictionary Type">public static class Activator&lt;TKey, TBaseType&gt;<br />    where TBaseType : class<br />{<br />    private static Dictionary&lt;TKey, Type&gt; _types =<br />        new Dictionary&lt;TKey, Type&gt;();<br /><br />    private static object _locker = new object();<br /><br />    public static void Add(TKey key, Type type)<br />    {<br />        // Some checks on the type argument<br />        [...]<br /><br />        lock (_locker)<br />        {<br />            if (_types.ContainsKey(key) == false)<br />            {<br />                TBaseType t = (TBaseType)<br />                    Activator.CreateInstance(type);<br /><br />                _types.Add(key, type);<br />            }<br />        }<br />    }<br /><br />    public static TBaseType CreateInstance(TKey key)<br />    {<br />        Type type = null;<br /><br />        lock (_locker)<br />        {<br />            _types.TryGetValue(key, out type);<br />        }<br /><br />        return type != null ? <br />            (TBaseType)Activator.CreateInstance(type) : null;<br />    }<br />}</pre><p>This Activator&lt;TKey, TBaseType&gt; implementation is about two times as slow as the Factory&lt;TKey, TBaseType&gt; implementation. But to create the fastest possible implementation of the factory pattern you should possibly dynamically generate the CreateInstance method with it's switch case statement. It then should generate the code in (perhaps) C# and let the compiler do the work of optimizing the switch case statement.</p><p>That's about it for now. I hope I inspired some of you.</p><p style="color: red">UPDATE 2008-01-12: <font color="#000000">Recently I found a design flaw in the current implementation. When you use the Factory&lt;TKey, TBaseType&gt; class as a reusable type in a bigger framework it might be better to make the type <u>not static</u> and instantiate it with a private member variable in your domain specific implementation. The problem lies in the fact that everybody can add Types with certain keys to the dictionary and several implementations could use the same key for different types. So be ware of this caveat when using this code.</font></p><p><font color="#ff0000">UPDATE 2009-07-22:</font> I recently did some performance tests with a factory that generated types based on a interface. This research was based on the idea that interface calls are faster than delegate calls. Therefore a factory that cached interfaces instead of delegates should be faster. <br /><br />Instead of using an internal <span class="type">Dictionary</span><span class="code">&lt;TKey, BaseTypeInvoker&gt;</span> I used a <span class="type">Dictionary</span><span class="code">&lt;TKey, </span><span class="type">IFactory</span><span class="code">&lt;TBaseType&gt;&gt;</span> where the <span class="type">IFactory</span><span class="code">&lt;TBaseType&gt;</span> defined a <span class="code">TBaseType CreateInstance()</span> method. On the fly I generated for each key a new type that implemented the <span class="type">IFactory</span><span class="code">&lt;TBaseType&gt;</span> interface.<br /><br />The results however, where disappointing. The new approach needed much more code, while both implementations had the same performance characteristics (the interface approach was even slightly slower).<br /><br />I also want to say that the last few years I started to get used to the concept of <a rel="external" href="http://en.wikipedia.org/wiki/Immutable_object" title="Wikipedia - Immutability">immutability</a>. By creating a type that can not change after creation, such an object is thread-safe and doesn&rsquo;t need any locking internally. This will give an performance improvement of almost 100% for the implementation given in this article. This is something you should keep in mind when trying to optimize performance.</p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=9#comm" title="Eber Irigoyen, mawi, Steven, Miguel, Nikita B. Zuev">eleven comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=9#track" title="this is very good">one trackback</a></span> - 
						<a href="/blogs/steven/archives/archive_2006-m09.php#e9" title="Permanent link to 'A Fast Dynamic Factory Using Reflection.Emit' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=9" title="Permanent link to entry 'A Fast Dynamic Factory Using Reflection.Emit'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>eleven comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>pretty slick, I hope you keep posting this kind of material; very interesting indeed.<br />
Using your implementation I came up with another way of doing the same thing without using dynamic code generation (I'll blog about it), nevertheless your code is very didactic, good learning experience<br /><small><b>Eber Irigoyen</b>  (<a href='http://ebersys.blogspot.com'  title='ebersys.blogspot.com'>URL</a>) - 24 09 06 - 00:45 </small></p>
<p>If the app guarantees that the dictionary of types in the factory is only setup at the start of the app, before any calls are made, I assume that one could skip the lock, correct?<br /><small><b>mawi</b>  (<a href='http://mawi.org'  title='mawi.org'>URL</a>) - 08 02 07 - 14:55 </small></p>
<p>Mawi,<br />
<br />
This is correct. Adding types to the factory from within a static constructor or during app start, will allow you to remove the lock and this can increase performance on multi-threaded applications.<br /><small><b><span class='registered'>[Steven]</span></b>  (<a href='http://www.cuttingedge.it/blogs/steven'  title='www.cuttingedge.it/blogs/steven'>URL</a>) - 11 02 07 - 14:59 </small></p>
<p>The new Orcas release of .NET (v3.5) will have a ReaderWriterLockSlim that can speed up the generic factory. It is a ReaderWriterLock with the performance of the Monitor. Joe Duffy wrote about this here: <a href="http://www.bluebytesoftware.com/blog/PermaLink,guid,c4ea3d6d-190a-48f8-a677-44a438d8386b.aspx.">http://www.bluebytesoftware.com/blog/Per..</a><br /><small><b><span class='registered'>[Steven]</span></b>  (<a href='http://www.cuttingedge.it/blogs/steven'  title='www.cuttingedge.it/blogs/steven'>URL</a>) - 10 03 07 - 00:44 </small></p>
<p>This is a lot more than good. This is didactic and serves as inspiration for developers in the 2.0 to 3.x learning curve.<br />
Just one issue: What about the implementation of BaseTypeInvoker and DynamicMethod. I couldn´t get it to work without those.<br />
<br />
Thanks!<br />
Miguel<br /><small><b>Miguel</b>  (<a href='http://mmmattos.nati-quill.com.br/'  title='mmmattos.nati-quill.com.br/'>URL</a>) - 05 07 07 - 16:19 </small></p>
<p>Miguel,<br />
<br />
Why are you trying to get rid of the BaseTypeInvoker delegate and the DynamicMethod? If you explain what you are trying to accomplish, I can possibly help you with it. You can send me an e-mail if you like.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9'>URL</a>) - 05 07 07 - 22:34 </small></p>
<p>Steve,<br />
<br />
Actually my problem was a lot simpler.<br />
I was not able to successfully run your code.<br />
But it is ok now... I figured out the problem.<br />
<br />
Thanks a lot and kind regards<br /><small><b>Miguel</b>  (<a href='http://mmmattos.nati-quill.com.br'  title='mmmattos.nati-quill.com.br'>URL</a>) - 08 07 07 - 00:48 </small></p>
<p>I found a white paper (http://portal.acm.org/citation.cfm?id=1753207) about the Dynamic Factory Pattern that references my article.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9'>URL</a>) - 28 06 10 - 17:19 </small></p>
<p>Great article!<br />
<br />
I was using something like this in my code, but I was storing Type in a dictionary and extracting it's constructor in CreateInstance method of a factory.<br />
<br />
Your idea to use a delegate gave me a great insight! Even more, you can use a generic constraint on Add method and everything becomes very secure and simple.<br />
<br />
public class FactoryBase&lt;TKey, TInterface&gt;<br />
{<br />
&nbsp;&nbsp;delegate TInterface Creator();<br />
&nbsp;&nbsp;<br />
&nbsp;&nbsp;private Dictionary&lt;TKey, Creator&gt; ctors = new Dictionary&lt;TKey, Creator&gt;();<br />
&nbsp;&nbsp;<br />
&nbsp;&nbsp;public void Add&lt;T&gt;(TKey key) <br />
&nbsp;&nbsp;&nbsp;&nbsp;where T : TInterface, new() // static checking for correct type<br />
&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;if (!ctors.ContainsKey(key))<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// storing anonymous method that calls constructor<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctors.Add(key, () =&gt; new T()); <br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;public TInterface CreateInstance(TKey key)<br />
&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;try {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creator ctor = ctors[key];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TInterface instance = ctor();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do stuff with instance<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return instance;<br />
&nbsp;&nbsp;&nbsp;&nbsp;} catch (KeyNotFoundException) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle errors<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;}<br />
}<br /><small><b>Nikita B. Zuev</b>   - 15 09 10 - 13:41 </small></p>
<p>Hi Nikita.<br />
<br />
To be able to use your example, you need the type T (of Add&lt;T&gt;) to be known at compile time. However, you can also create an Add(TKey key, Type type) overload that calls into the generic Add method using reflection. This way you can completely skip using that ugly Reflection.Emit, but still have the same performance characteristics.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=9'>URL</a>) - 18 09 10 - 15:29 </small></p>
<p>Nice! For now I'm satisfied with compile-time checkable `add'. But if runtime `add' will be needed, overload would be very usefull.<br /><small><b>Nikita B. Zuev</b>   - 20 09 10 - 07:12 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>