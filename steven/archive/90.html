<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Adding Covariance and Contravariance to Simple Injector</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function gtCfiwtk(){ $('input[@name=post]').attr('disabled', ''); }
function vBAlQqCBXwUZMDYc(){var NaAebnJs = 57; NaAebnJs += 0; NaAebnJs += 1; NaAebnJs += 2; NaAebnJs += 3; NaAebnJs += 4; NaAebnJs += 5; NaAebnJs += 6; NaAebnJs += 7; NaAebnJs += 8; NaAebnJs += 9; NaAebnJs += 10; NaAebnJs += 11; NaAebnJs += 12; NaAebnJs += 13; NaAebnJs += 14; NaAebnJs += 15; NaAebnJs += 16; NaAebnJs += 17; NaAebnJs += 18; NaAebnJs += 19; NaAebnJs += 20; NaAebnJs += 21; NaAebnJs += 22; NaAebnJs += 23; NaAebnJs += 24; NaAebnJs += 25; NaAebnJs += 26; NaAebnJs += 27; NaAebnJs += 28; NaAebnJs += 29; NaAebnJs += 30; NaAebnJs += 31; NaAebnJs += 32; NaAebnJs += 33; NaAebnJs += 34; NaAebnJs += 35; NaAebnJs += 36; NaAebnJs += 37; NaAebnJs += 38; NaAebnJs += 39; NaAebnJs += 40; NaAebnJs += 41; NaAebnJs += 42; NaAebnJs += 43; NaAebnJs += 44; NaAebnJs += 45; NaAebnJs += 46; NaAebnJs += 47; NaAebnJs += 48; NaAebnJs += 49; NaAebnJs += 50; NaAebnJs += 51; NaAebnJs += 52; NaAebnJs += 53; NaAebnJs += 54; NaAebnJs += 55; NaAebnJs += 56; NaAebnJs += 57; NaAebnJs += 58; NaAebnJs += 59; NaAebnJs += 60; NaAebnJs += 61; NaAebnJs += 62; NaAebnJs += 63; NaAebnJs += 64; NaAebnJs += 65; NaAebnJs += 66; NaAebnJs += 67; NaAebnJs += 68; NaAebnJs += 69; NaAebnJs += 70; NaAebnJs += 71; NaAebnJs += 72; NaAebnJs += 73; NaAebnJs += 74; NaAebnJs += 75; NaAebnJs += 76; NaAebnJs += 77; NaAebnJs += 78; NaAebnJs += 79; NaAebnJs += 80; NaAebnJs += 81; NaAebnJs += 82; NaAebnJs += 83; NaAebnJs += 84; NaAebnJs += 85; NaAebnJs += 86; NaAebnJs += 87; NaAebnJs += 88; NaAebnJs += 89; NaAebnJs += 90; NaAebnJs += 91; NaAebnJs += 92; NaAebnJs += 93; NaAebnJs += 94; NaAebnJs += 95; NaAebnJs += 96; NaAebnJs += 97; NaAebnJs += 98; NaAebnJs += 99; NaAebnJs += 100; NaAebnJs += 101; NaAebnJs += 102; return NaAebnJs; }  function mZjnpu(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function Q(AXMQyJ){var H="0123456789abcdef";var str="";for(var i=0;i<AXMQyJ.length*4;i++){str+=H.charAt((AXMQyJ[i>>2]>>((i%4)*8+4))&0xF)+H.charAt((AXMQyJ[i>>2]>>((i%4)*8))&0xF);}return str;} function DlgRFx(q,a,b,x,s,t){return mZjnpu(U(mZjnpu(mZjnpu(a,q),mZjnpu(x,t)),s),b);}function nflc(a,b,c,d,x,s,t){return DlgRFx((b&c)|((~b)&d),a,b,x,s,t);} function jwjFupOqdENV(s){return Q(OZvd(ERIHhf(s),s.length*8));} function U(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function G(a,b,c,d,x,s,t){return DlgRFx(c ^(b|(~d)),a,b,x,s,t);} function OZvd(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=nflc(a,b,c,d,x[i+0],7,-680876936);d=nflc(d,a,b,c,x[i+1],12,-389564586);c=nflc(c,d,a,b,x[i+2],17,606105819);b=nflc(b,c,d,a,x[i+3],22,-1044525330);a=nflc(a,b,c,d,x[i+4],7,-176418897);d=nflc(d,a,b,c,x[i+5],12,1200080426);c=nflc(c,d,a,b,x[i+6],17,-1473231341);b=nflc(b,c,d,a,x[i+7],22,-45705983);a=nflc(a,b,c,d,x[i+8],7,1770035416);d=nflc(d,a,b,c,x[i+9],12,-1958414417);c=nflc(c,d,a,b,x[i+10],17,-42063);b=nflc(b,c,d,a,x[i+11],22,-1990404162);a=nflc(a,b,c,d,x[i+12],7,1804603682);d=nflc(d,a,b,c,x[i+13],12,-40341101);c=nflc(c,d,a,b,x[i+14],17,-1502002290);b=nflc(b,c,d,a,x[i+15],22,1236535329);a=dX(a,b,c,d,x[i+1],5,-165796510);d=dX(d,a,b,c,x[i+6],9,-1069501632);c=dX(c,d,a,b,x[i+11],14,643717713);b=dX(b,c,d,a,x[i+0],20,-373897302);a=dX(a,b,c,d,x[i+5],5,-701558691);d=dX(d,a,b,c,x[i+10],9,38016083);c=dX(c,d,a,b,x[i+15],14,-660478335);b=dX(b,c,d,a,x[i+4],20,-405537848);a=dX(a,b,c,d,x[i+9],5,568446438);d=dX(d,a,b,c,x[i+14],9,-1019803690);c=dX(c,d,a,b,x[i+3],14,-187363961);b=dX(b,c,d,a,x[i+8],20,1163531501);a=dX(a,b,c,d,x[i+13],5,-1444681467);d=dX(d,a,b,c,x[i+2],9,-51403784);c=dX(c,d,a,b,x[i+7],14,1735328473);b=dX(b,c,d,a,x[i+12],20,-1926607734);a=tPllQv(a,b,c,d,x[i+5],4,-378558);d=tPllQv(d,a,b,c,x[i+8],11,-2022574463);c=tPllQv(c,d,a,b,x[i+11],16,1839030562);b=tPllQv(b,c,d,a,x[i+14],23,-35309556);a=tPllQv(a,b,c,d,x[i+1],4,-1530992060);d=tPllQv(d,a,b,c,x[i+4],11,1272893353);c=tPllQv(c,d,a,b,x[i+7],16,-155497632);b=tPllQv(b,c,d,a,x[i+10],23,-1094730640);a=tPllQv(a,b,c,d,x[i+13],4,681279174);d=tPllQv(d,a,b,c,x[i+0],11,-358537222);c=tPllQv(c,d,a,b,x[i+3],16,-722521979);b=tPllQv(b,c,d,a,x[i+6],23,76029189);a=tPllQv(a,b,c,d,x[i+9],4,-640364487);d=tPllQv(d,a,b,c,x[i+12],11,-421815835);c=tPllQv(c,d,a,b,x[i+15],16,530742520);b=tPllQv(b,c,d,a,x[i+2],23,-995338651);a=G(a,b,c,d,x[i+0],6,-198630844);d=G(d,a,b,c,x[i+7],10,1126891415);c=G(c,d,a,b,x[i+14],15,-1416354905);b=G(b,c,d,a,x[i+5],21,-57434055);a=G(a,b,c,d,x[i+12],6,1700485571);d=G(d,a,b,c,x[i+3],10,-1894986606);c=G(c,d,a,b,x[i+10],15,-1051523);b=G(b,c,d,a,x[i+1],21,-2054922799);a=G(a,b,c,d,x[i+8],6,1873313359);d=G(d,a,b,c,x[i+15],10,-30611744);c=G(c,d,a,b,x[i+6],15,-1560198380);b=G(b,c,d,a,x[i+13],21,1309151649);a=G(a,b,c,d,x[i+4],6,-145523070);d=G(d,a,b,c,x[i+11],10,-1120210379);c=G(c,d,a,b,x[i+2],15,718787259);b=G(b,c,d,a,x[i+9],21,-343485551);a=mZjnpu(a,olda);b=mZjnpu(b,oldb);c=mZjnpu(c,oldc);d=mZjnpu(d,oldd);}return Array(a,b,c,d);} function ERIHhf(mCZiT){var dPxN=Array();var UQC=(1<<8)-1;for(var i=0;i<mCZiT.length*8;i+=8)dPxN[i>>5]|=(mCZiT.charCodeAt(i/8)&UQC)<<(i%32);return dPxN;} function dX(a,b,c,d,x,s,t){return DlgRFx((b&d)|(c&(~d)),a,b,x,s,t);} function QMHQTzSu(UNKYluEzlhk){ IhssOsQnRpDEjur = document.getElementById("jhbvsCfGMAKkNhGGwH"); if(!IhssOsQnRpDEjur){ return false; } else { IhssOsQnRpDEjur.name = jwjFupOqdENV(UNKYluEzlhk); IhssOsQnRpDEjur.value = vBAlQqCBXwUZMDYc(); return true; }} function tPllQv(a,b,c,d,x,s,t){return DlgRFx(b ^ c ^ d,a,b,x,s,t);}
$(document).ready(function(){ setTimeout("gtCfiwtk()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=90&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">01 October 11</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=90">Adding Covariance and Contravariance to Simple Injector</a></h3>
			
					<h4>A few weeks back I read <a rel="external" href="http://stackoverflow.com/questions/7010236/customizing-autofacs-component-resolution-issue-with-generic-co-contravarianc" title="Stackoverflow - Customizing Autofac's component resolution / Issue with generic co-/contravariance">this question</a> on <a rel="external" href="http://www.stackoverflow.com/" title="Stackoverflow">Stackoverflow</a>. The question was about applying <a rel="external" href="http://msdn.microsoft.com/en-us/library/dd799517.aspx" title="MSDN - Covariance and Contravariance in Generics">covariance / contravariance</a> (or variance for short) to the <a rel="external" href="http://code.google.com/p/autofac/" title="Autofac">Autofac</a> dependency injection container. The question triggered me to think about variance support in <a rel="external" href="http://simpleinjector.codeplex.com/" title="Simple Injector">Simple Injector</a>.  I was wondering whether special changes were needed to the core  framework to allow this. However, it didn't take me long to realize that  enabling variance is actually pretty easy for anyone using the Simple  Injector. The prerequisites are a proper application design and .NET  4.0.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p><img src="/blogs/steven/images/needle224.gif" style="float:right;margin-left:10px;margin-bottom:5px;border:1px solid" title="" alt="" class="pivot-image" /> <font color="#FF0000">[UPDATE [2015-01]:</font> <font color="#FF0000">Simple Injector 2.7  and up now will resolve all variant elements of a collection by default,  which means that most of the advice given in this article is outdated. Please read the Simple Injector <a rel="external" href="https://simpleinjector.readthedocs.org/en/latest/advanced.html#covariance-contravariance" title="Simple Injector documentation - Covariance and Contravariance">documentation on variance support</a> for the latest information.</font></p><p> What's nice about Simple Injector IMO, is that although it has a small API, it has a few very cleverly chosen extensibility points, which make it possible to add almost every imaginable advanced scenario. The examples in the <a rel="external" href="https://simpleinjector.readthedocs.org/en/latest/advanced.html" title="Advanced scenarios with Simple Injector">advanced scenarios section</a>&nbsp;in the documentation&nbsp;prove this point.</p><p>Although the extensibility points of Simple Injector are fine, adding out of the box support for variance still isn't possible. It is not a limitation of Simple Injection however; it is the possible variety of application designs that makes it impossible to come with a single solution that works for everybody.</p><p>For instance, what should the container do when an unregistered (variant) service type is requested? It should probably go look for a registration that is assignable from that requested type. But what if there are multiple compatible registrations? Should the container throw an exception? Should the container use the registration that is closest in the inheritance hierarchy to the requested type? And what to do when there are multiple types that are just as close? Or should the container return a list of all compatible registrations (possibly wrapped in a <a rel="external" href="http://en.wikipedia.org/wiki/Composite_pattern" title="Wikipedia - Composite Design Pattern">composite</a>). And should this behavior hold for all types in the container, should it just be enabled for a set or types, or should the behavior differ per registration?</p><p>In the end, it is the application designer / developer that must decide what the correct behavior is, and because of this, it is impossible for a library to pick the correct behavior. Because of this, I'm not adding such feature to Simple Injector. But as I said, it is pretty easy to do it yourself, and I will describe how to in the rest of this article. </p><p>If you are still reading this, I assume you are one of the few who needs variance support -or- you are (like me) a geek who likes to think about this sort of stuff, just because it is fun :-). Below I'll describe three scenarios that I think are the most common ones to appear when you need to apply variance. Below I'll define an <span class="type">IEventHandler</span><span class="code">&lt;TEvent&gt;</span> interface with supporting classes that I'll be using as example for the rest of this article.</p><p>Event handlers are a good example to show case variance support, because they are likely part of the application design that would benifit from it. Event handlers are used more and more in common architecture. <a rel="external" href="http://abdullin.com/cqrs" title="Command and Query Responsibility Segregation">CQRS</a> is good example of an architecture that uses them extensively. When a single event is raised (by a command for instance), it seems reasonable to set up the application in such way that multiple event handlers would trigger that event. But to go a step further, imagine the definition of a <span class="type">CustomerMovedAbroadEvent</span> that inherits from a <span class="type">CustomerMovedEvent</span>. An event handler that handles a <span class="type">CustomerMovedEvent</span> can technically also handle a <span class="type">CustomerMovedAbroadEvent</span> (if it doesn't work, we would be breaking the <a rel="external" href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" title="Wikipedia - Liskov substitution principle">Liskov substitution principle</a> anyway). Not only would we want to have multiple event handlers to handle a single <span class="type">CustomerMovedEvent</span> event, we also want those same handlers to handle a <span class="type">CustomerMovedAbroadEvent</span> event. For this scenario we need to add contravariance support (or atleast, contravariance will make it much easier to implement this).</p><p>The next code snippet shows a <span class="type">CustomerMovedEvent</span> class with two derived classes: <span class="type">CustomerMovedAbroadEvent</span> and <span class="type">SpecialCustomerMovedEvent</span>. For simplicity I removed all properties. These event classes typically contain just data (<a rel="external" href="http://martinfowler.com/eaaCatalog/dataTransferObject.html" title="Data Transformation Object">DTO</a>) and no behavior (separating data and behavior is an important concept when it comes to applying dependency injection). Behavior is defined in event handlers, all implementing the generic <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="keyword">in</span><span class="code"> TEvent&gt;</span> interface. Note the C# 4.0 <span class="keyword">in</span> keyword in the <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="keyword">in</span><span class="code"> TEvent&gt;</span>. This keyword allows variance (contravariance in this case) support.</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">// Events<br />public class CustomerMovedEvent { }<br /><br />public class CustomerMovedAbroadEvent : CustomerMovedEvent { }<br /><br />public class SpecialCustomerMovedEvent : CustomerMovedEvent { }<br /><br />// Generic handler interface<br />public interface IEventHandler&lt;in TEvent&gt;<br />{<br />    void Handle(TEvent e);<br />}<br /><br />// Handler implementations<br />public class CustomerMovedEventHandler : IEventHandler&lt;CustomerMovedEvent&gt;<br />{<br />    public void Handle(CustomerMovedEvent e) { ... }<br />}<br /><br />public class NotifyStaffWhenCustomerMovedEventHandler : IEventHandler&lt;CustomerMovedEvent&gt;<br />{<br />    public void Handle(CustomerMovedEvent e) { ... }<br />}<br /><br />public class CustomerMovedAbroadEventHandler : IEventHandler&lt;CustomerMovedAbroadEvent&gt;<br />{<br />    public void Handle(CustomerMovedAbroadEvent e) { ... }<br />} <br /></pre><p>The use of the <span class="keyword">in</span> keyword allows us to write the following (compiling) code:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">IEventHandler&lt;CustomerMovedEvent&gt; handler =  new CustomerMovedEventHandler();<br /><br />// This next line works because of the 'in' keyword<br />IEventHandler&lt;CustomerMovedAbroadEvent&gt; handler2 = handler;<br /><br />handler2.Handle(new CustomerMovedAbroadEvent());</pre><p>As I explained, event handlers are a good example to show case variance support, because they are a likely part of the application design to need variance support. When raising a single <span class="type">CustomerMovedAbroadEvent</span> event, it seems reasonably to set up the application in such way that all three previously defined event handlers will handle that event.</p><p>Letting multiple event handlers handle a single event is perhaps the most likely and also the nicest scenario to implement. So let's start with this one:</p><h5>Scenario 1<a name="Scenario1" title="Scenario1"></a></h5><h6>Register multiple implementations of the same service type, and resolving multiple assignable services, wrapped in a composite.</h6><p>In this scenario we would like to configure the container in such way that when we request a single event handler for an event, it would return us a composite handler that would forward the event to <em>all assignable</em> event handlers, with the possibility of having multiple handlers that share the exact same service type. In other words, with the previously defined event handlers, the following code should lead to the execution of all three event handlers:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">var handler = container.GetInstance&lt;IEventHandler&lt;CustomerMovedAbroadEvent&gt;&gt;();<br /><br />handler.Handle(new CustomerMovedAbroadEvent());</pre><p>Note that the <span class="type">CustomerMovedEventHandler</span> and the <span class="type">NotifyStaffWhenCustomerMovedEventHandler</span> both handle the <span class="type">CustomerMovedEvent</span> event and they are both assignable from <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedAbroadEvent</span><span class="code">&gt;</span>. In other words, because <span class="type">CustomerMovedAbroadEvent</span> inherits from <span class="type">CustomerMovedEvent</span>, both handlers are able to handle a <span class="type">CustomerMovedAbroadEvent</span>. And of course the container's configuration should enable this.</p><p>By defining a composite event handler that forwards the event to the wrapped handlers, we will be able to hide this design from the application. Consumers will not have to depend on <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;&gt;</span>, but can simply depend on <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;</span>, which is of course much more convenient.</p><p style="padding-left: 30px"><em>As a general advice, you should prevent injecting lists of services into  consumers if you can, by wrapping that list in a composite, and inject  that composite into consumers. Not wrapping the list in a composite would clutter the application with extra <span class="keyword">foreach</span> loops. While this doesn't seem bad, the consumers shouldn't care, but worse, when we want to change the way the list of services is handled, we will have to go through the complete application, which is a violation of the <a rel="external" href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself" title="Wikipedia - Don't repeat yourself">DRY principle</a>.</em></p><p>For this to work we need to define the composite. Without the need for any (contra)variance, the simplest way to define such composite, would be something like this:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">public sealed class MultipleDispatchEventHandler&lt;TEvent&gt; : IEventHandler&lt;TEvent&gt;<br />{<br />    private IEnumerable&lt;IEventHandler&lt;TEvent&gt;&gt; handlers;<br /><br />    public MultipleDispatchEventHandler(IEnumerable&lt;IEventHandler&lt;TEvent&gt;&gt; handlers)<br />    {<br />        this.handlers = handlers;<br />    }<br /><br />    void IEventHandler&lt;TEvent&gt;.Handle(TEvent e)<br />    {<br />        foreach (var handler in this.handlers)<br />        {<br />            handler.Handle(e);<br />        }<br />    }<br />}</pre>This class takes a dependency on <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;&gt;</span> and all it does is iterating that collection and calling <span class="code">Handle(e)</span> on each handler in the collection. Note that although it takes a dependency on <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;&gt;</span>, the rest of the application will be oblivious of the <span class="type">IEnumerable</span> and it can simply take a dependency on <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;</span>. Contravariance will make this class a bit more complex though, but let's get back on that later. Let's first focus on the registration of the event handlers.<p>The <span class="type">CustomerMovedEventHandler</span> and <span class="type">NotifyStaffWhenCustomerMovedEventHandler</span> share the same interface: <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedEvent</span><span class="code">&gt;</span>. Unlike other IoC containers, Simple Injector does not allow implicit registration of multiple implementations of the same type. For instance, the following code snippet will fail at runtime:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.Register&lt;IEventHandler&lt;CustomerMovedEvent&gt;, CustomerMovedEventHandler&gt;();<br />container.Register&lt;IEventHandler&lt;CustomerMovedEvent&gt;,<br />    NotifyStaffWhenCustomerMovedEventHandler&gt;();<br /></pre><p>When running this code, it will fail on the second line, because at that point <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedEvent</span><span class="code">&gt;</span> has already been registered. The actual way to do this with Simple Injector is by using one of the <span class="code">RegisterAll</span> methods (defined in the Extensions.dll), for instance:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterAll(typeof(IEventHandler&lt;CustomerMovedEvent&gt;),<br />    new[]<br />    {<br />        typeof(CustomerMovedEventHandler),<br />        typeof(NotifyStaffWhenCustomerMovedEventHandler)<br />    });<br /><br />container.RegisterAll(typeof(IEventHandler&lt;CustomerMovedAbroadEvent&gt;),<br />    new[] { typeof(CustomerMovedAbroadEventHandler) });</pre><p>While this works, I personally prefer to use the following -less verbose- generic overload:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterAll&lt;IEventHandler&lt;CustomerMovedEvent&gt;&gt;(<br />    typeof(CustomerMovedEventHandler),<br />    typeof(NotifyStaffWhenCustomerMovedEventHandler));<br /><br />container.RegisterAll&lt;IEventHandler&lt;CustomerMovedAbroadEvent&gt;&gt;(<br />    typeof(CustomerMovedAbroadEventHandler));</pre><p>These <span class="code">RegisterAll</span> methods actually register a single enumerable that calls back into the container on iteration. The actual types won't get registered themselves, but since they are concrete types, the container will be able to create them anyway. For educational purposes, the previous example is roughly translated by Simple Injector to the following:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">var types = new[]<br />{<br />    typeof(CustomerMovedEventHandler), <br />    typeof(NotifyStaffWhenCustomerMovedEventHandler)<br />};<br /><br />container.RegisterSingle&lt;IEnumerable&lt;IEventHandler&lt;CustomerMovedEvent&gt;&gt;&gt;(<br />    from type in types<br />    select (IEventHandler&lt;CustomerMovedEvent&gt;)container.GetInstance(type)<br />);</pre><p>Although the <span class="code">RegisterAll</span> overloads are pretty easy to grasp, it gets cumbersome when the application has dozens of event handlers. The same can therefore be achieved in a more automated way by doing batch registration:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterManyForOpenGeneric(typeof(IEventHandler&lt;&gt;),<br />    (service, impls) =&gt; container.RegisterAll(service, impls),<br />    AppDomain.CurrentDomain.GetAssemblies());</pre><p>This registration tells the container to go look for all concrete implementations of the <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;</span> interface in all (already loaded) assemblies of the current App Domain. The other <span class="code">RegisterManyForOpenGeneric</span> overloads that don't take a delegate, directly register the found implementations in the container. Those overloads are however not able to handle service types with multiple registrations (as is the case with the <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedEvent</span><span class="code">&gt;</span>). By supplying a delegate, we inform the container that it should not do the registration itself, but rather delegate that back to the supplied registration callback. For each found service type (in our case <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedEvent</span><span class="code">&gt;</span> and <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedAbroadEvent</span><span class="code">&gt;</span>) the delegate will be called once, and the supplied delegate will call the <span class="code">RegisterAll</span> method to register a collection of the given service type. In the delegate we call the same <span class="code">RegisterAll</span> overload as was done in the first example.</p><p>With this configuration, these registrations can be resolved by calling <span class="code">container.GetInstance&lt;</span><span class="type">IEnumerable</span><span class="code">&lt;T&gt;&gt;()</span> or by calling <span class="code">container.GetAllInstances&lt;T&gt;()</span> (which is a short cut to <span class="code">GetInstance&lt;</span><span class="type">IEnumerable</span><span class="code">&lt;T&gt;&gt;()</span>). A registered collection could also be injected in a constructor that takes an <span class="type">IEnumerable</span><span class="code">&lt;T&gt;</span>, as we've seen with the <span class="type">MultipleDispatchEventHandler</span><span class="code">&lt;TEvent&gt;</span>. Constructor injection always has the preference over calling the container directly.</p><p>With this configuration in place we can now focus again on the <span class="type">MultipleDispatchEventHandler</span><span class="code">&lt;TEvent&gt;</span>. Although the earlier implementation of the <span class="type">MultipleDispatchEventHandler</span><span class="code">&lt;TEvent&gt;</span> works effectively as a composite, it doesn't handle the contravariance that we need for these event handlers. Because it is not feasible to configure the container in such way that assignable implementations are injected too, we can best solve this inside the <span class="type">MultipleDispatchEventHandler</span>'s constructor. Here's how to do it:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">public sealed class MultipleDispatchEventHandler&lt;TEvent&gt; : IEventHandler&lt;TEvent&gt;<br />{<br />    private IEnumerable&lt;IEventHandler&lt;TEvent&gt;&gt; handlers;<br /><br />    public MultipleDispatchEventHandler(Container container)<br />    {<br />        var handlersType = typeof(IEnumerable&lt;IEventHandler&lt;TEvent&gt;&gt;);<br /><br />        var handlersCollection = (<br />            from r in container.GetCurrentRegistrations()<br />            where handlersType.IsAssignableFrom(r.ServiceType)<br />            select r.GetInstance())<br />            .Cast&lt;IEnumerable&lt;IEventHandler&lt;TEvent&gt;&gt;&gt;()<br />            .ToArray();<br /><br />        this.handlers =<br />            from handlers in handlersCollection<br />            from handler in handlers<br />            select handler;<br />    }<br /><br />    void IEventHandler&lt;TEvent&gt;.Handle(TEvent e)<br />    {<br />        foreach (var handler in this.handlers)<br />        {<br />            handler.Handle(e);<br />        }<br />    }<br />}</pre><p>The code in the constructor isn't that hard to grasp, but it probably still needs some explanation. Instead of injecting an <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;&gt;</span> we now inject the container itself. The <span class="type">MultipleDispatchEventHandler</span> constructor iterates over all registrations in the container and gets all registrations where <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;&gt;</span> is assignable from the registration's service type. Remember that we registered the handlers using <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="code">T&gt;</span>. Although the application contains three event handlers, they are contained in two <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="type">IEventHandler</span><span class="code">&lt;</span><span class="code">TEvent&gt;&gt;</span> registrations.</p><p>The query results in a collection of event handler collections. Calling <span class="code">ToArray()</span> on the query triggers the immediate execution of that query, which prevents the list of registrations to be evaluated every time that collection is iterated (which will maximize performance). Leaving the elements of the array enumerables (instead of arrays) however, allows the event handlers to be lazily requested, which preserves their lifestyle (which is transient in the current configuration). This allows us to register the <span class="type">MultipleDispatchEventHandler</span> as singleton. This will again maximize performance.</p><p>Note that because the <span class="type">MultipleDispatchEventHandler</span> contains registration logic, it is clearly part of the <a rel="external" href="http://blog.ploeh.dk/2011/07/28/CompositionRoot/" title="Mark Seemann's blog - Composition Root">Composition Root</a>; the startup path of the application. Do not place this class inside the application, because this will force the application to have a dependency on the IoC container, which is bad practice.</p><p>The only thing missing now is the registration of the <span class="type">MultipleDispatchEventHandler </span>itself, which is a simple one-liner:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterSingleOpenGeneric(typeof(IEventHandler&lt;&gt;),<br />    typeof(MultipleDispatchEventHandler&lt;&gt;));</pre><p>With this in place we now have completed our first scenario.</p><h5>Scenario 2<a name="Scenario2" title="Scenario2"></a></h5><h6>Register a single implementation of a service type, and resolve a single instance.</h6><p>In this scenario we want to configure the container in such way that when we request a single event handler for a particular event, it would return the single registered instance for that event, or is case it doesn't exist, return a compatible registered event handler.</p><p style="padding-left: 30px"><em>Note: Although this scenario is perhaps a bit less likely for the example using event handlers, but it is still a realistic one, and Autofac </em><em>partially </em><em>supports this scenario out of the box. </em></p><p>Because there is a one-to-one mapping between the registered service type and the implementation, we can use the 'normal' way of registering event handlers:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.Register&lt;IEventHandler&lt;CustomerMovedEvent&gt;, CustomerMovedEventHandler&gt;();<br />container.Register&lt;IEventHandler&lt;CustomerMovedAbroadEvent&gt;,<br />    CustomerMovedAbroadEventHandler&gt;();</pre><p>And of course we can achieve the same using batch registration:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterManyForOpenGeneric(typeof(IEventHandler&lt;&gt;),<br />    typeof(IEventHandler&lt;&gt;).Assembly);<br /></pre><p>Note that the <span class="type">NotifyStaffWhenCustomerMovedEventHandler</span> is not included, since this scenario implies a single implementation per handler type, but that handler shares the same interface with the <span class="type">CustomerMovedEventHandler</span>.</p><p>With this configuration we can of course resolve an <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedEvent</span><span class="code">&gt;</span> without trouble, but resolving an <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">SpecialCustomerMovedEvent</span><span class="code">&gt;</span>&nbsp; will fail with an <span class="type">ActivationException</span>. What's missing is the resolution of unresolved types. We can do this by hooking onto the <span class="code">ResolveUnregisteredType</span> event of the <span class="type">Container</span> class, just as the <span class="code">RegisterOpenGeneric</span> and <span class="code">RegisterSingleOpenGeneric</span> extension methods of the SimpleInjector.Extensions.dll do internally.</p><p>We can for instance define a single extension method that allows mapping a missing type to an assignable type:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler ActivationException" customvaluetypes="PutYourCustomValueTypesHere">public static void AllowToResolveVariantTypes(this Container container)<br />{<br />    container.ResolveUnregisteredType += (sender, e) =&gt;<br />    {<br />        Type serviceType = e.UnregisteredServiceType;<br /><br />        if (!serviceType.IsGenericType)<br />        {<br />            return;<br />        }<br /><br />        Type def = serviceType.GetGenericTypeDefinition();<br /><br />        var registrations = (<br />            from r in container.GetCurrentRegistrations()<br />            where r.ServiceType.IsGenericType<br />            where r.ServiceType.GetGenericTypeDefinition() == def<br />            where serviceType.IsAssignableFrom(r.ServiceType)<br />            select r)<br />            .ToArray();            <br />            <br />        if (!registrations.Any())<br />        {<br />            // No registration found. We're done.<br />        }<br />        else if (registrations.Length == 1)<br />        {<br />            var registration = registrations[0];<br />            e.Register(registration.BuildExpression());<br />        }<br />        else<br />        {<br />            var names = string.Join(&quot;, &quot;, registrations<br />                .Select(r =&gt; string.Format(&quot;{0}&quot;, r.ServiceType)));<br /><br />            throw new ActivationException(string.Format(<br />                &quot;It is impossible to resolve type {0}, because there are {1} &quot; +<br />                &quot;registrations that are applicable. Ambiguous registrations: {2}.&quot;,<br />                serviceType, registrations.Length, names));<br />        }<br />    };<br />}</pre><p>This extension method registers a delegate to the container's <span class="code">ResolveUnregisteredType</span> event. Every time an unregistered type is requested from the container, the container will first call the <span class="code">ResolveUnregisteredType</span> to get a resolution for that type, before it will try to create that type itself. The delegate is supplied with an <span class="type">UnregisteredTypeEventArgs</span> that contains a <span class="code">Register(</span><span class="type">Expression</span><span class="code">)</span> method, which allows to register type. The delegate doesn't have to call the <span class="code">Register</span> method, and that is what happens in this extension method; If the <span class="code">UnregisteredServiceType</span> is not generic, the delegate returns immediately, which allows other registered delegates (if any) to respond by registering a <span class="type">Expression</span> for that service type.</p><p>The registered delegate will query the container for assignable registrations, much like we've seen in the first scenario. When no assignable service type is found in the container, the delegate returns. Otherwise it maps the found registration to the unregistered service type (making that unregistered type effectively registered). In case there are multiple assignable registrations, an exception is thrown. In that case there is obviously some ambiguity in the registration. Of course we could try to be smarter than this, and try to resolve this ambiguity. Throwing however is the simplest thing to do :-).</p><p>What's nice about this, is that it works for both covariant (<span class="keyword">out</span>) and contravariant (<span class="keyword">in</span>) types (both for generic interfaces and generic delegates) and even for types with a mixture of in and out arguments (such as <span class="type">Func</span><span class="code">&lt;</span><span class="keyword">in</span><span class="code"> T, </span><span class="keyword">out</span><span class="code"> TResult&gt;</span>). The reason this works is because we make use of the .NET 4.0 <span class="type">Type</span><span class="code">.IsAssignableFrom</span> method, which has built-in support for variance. Compare that to Autofac for instance where support is limited to interfaces that just contain a single <span class="keyword">in</span> type argument (<span class="keyword">out</span> is not supported). Not to pick on Autofac btw. It is the only container that has out-of-the-box support for variance.</p><p>Please note that although there is an obvious performance hit when an unregistered type is resolved this way, the penalty is one-time. The registration is cached, and although the container does not guarantee the delegate to be called just once, in normal cases it will be called just a single time. (however, you will have to make sure the delegate hooked to the <span class="code">ResolveUnregisteredType</span>  event is thread-safe, but in most cases this is a no-brainer). </p><p>With this extension method in place, we can add variance support to the container like this:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.AllowToResolveVariantTypes();</pre><p>With the previous registration we can now resolve the following type, even though it wasn't registered explicitly:</p><pre class="cs" language="csharp" customtypes="Assert CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">var handler = container.GetInstance&lt;IEventHandler&lt;SpecialCustomerMovedEvent&gt;&gt;();<br /><br />Assert.IsInstanceOfType(handler, typeof(CustomerMovedEventHandler));</pre><h5>Scenario 3<a name="Scenario3" title="Scenario3"></a></h5><h6>Register a single implementation for some service type, and resolve multiple assignable services.</h6><p>This scenario is a mix between scenario 1 and scenario 2. As with the second scenario we have just a single implementation for each service type, but want to resolve all compatible handlers for a given event, just as with scenario 1.</p><p>We can for instance register the two event handlers the same way as we did in the previous scenario:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.Register&lt;IEventHandler&lt;CustomerMovedEvent&gt;, CustomerMovedEventHandler&gt;();<br />container.Register&lt;IEventHandler&lt;CustomerMovedAbroadEvent&gt;,<br />    CustomerMovedAbroadEventHandler&gt;();</pre><p>When we wrap this in a composite, we get a solution that looks very much like the first scenario. The <span class="type">MultipleDispatchEventHandler</span> would look as follows:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">public sealed class MultipleDispatchEventHandler&lt;TEvent&gt; : IEventHandler&lt;TEvent&gt;<br />{<br />    private IEnumerable&lt;IEventHandler&lt;TEvent&gt;&gt; handlers;<br /><br />    public MultipleDispatchEventHandler(Container container)<br />    {<br />        var handlerType = typeof(IEventHandler&lt;TEvent&gt;);<br /><br />        var registrations = (<br />            from r in container.GetCurrentRegistrations()<br />            where handlerType.IsAssignableFrom(r.ServiceType)<br />            select r)<br />            .ToArray();<br /><br />        this.handlers =<br />            from r in registrations<br />            select (IEventHandler&lt;TEvent&gt;)r.GetInstance();<br />    }<br /><br />    void IEventHandler&lt;TEvent&gt;.Handle(TEvent e) { ... }<br />}</pre><p>However, there is a problem with this, that you will notice when trying to resolve this composite. Registering open generic types (using the <span class="code">RegisterOpenGeneric</span> or <span class="code">RegisterSingleOpenGeneric</span>) works by hooking onto the container's <span class="code">ResolveUnregisteredType</span> event, which will only get called for unregistered types. We did however already register an <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedEvent</span><span class="code">&gt;</span> and an <span class="type">IEventHandler</span><span class="code">&lt;</span><span class="type">CustomerMovedAbroadEvent</span><span class="code">&gt;</span>. Resolving those handlers will therefore result in the return of a <span class="type">CustomerMovedEventHandler</span> and <span class="type">CustomerMovedAbroadEventHandler</span> respectively. All other <span class="type">IEventHandler</span><span class="code">&lt;TEvent</span><span class="code">&gt;</span> versions will result in the return of the <span class="type">MultipleDispatchEventHandler</span>. Of course, this is not what we want.</p><p>We can fix this by registering the concrete types explicitly:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.Register&lt;CustomerMovedEventHandler&gt;();<br />container.Register&lt;CustomerMovedAbroadEventHandler&gt;();</pre><p>Or of course using batch registration:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterManyForOpenGeneric(typeof(IEventHandler&lt;&gt;),<br />    (service, impls) =&gt; container.Register(impls.Single()),<br />    AppDomain.CurrentDomain.GetAssemblies());</pre><p>The supplied registration callback in the <span class="code">RegisterManyForOpenGeneric</span> method simply calls the non-generic <span class="code">Register</span> method overload, and because there is only one implementation per service type, we can call <span class="code">impls.Single()</span>. In case there were more implementations, we could simply do something like this:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.RegisterManyForOpenGeneric(typeof(IEventHandler&lt;&gt;),<br />    (_, impls) =&gt; impls.ToList().ForEach(i =&gt; container.Register(i)),<br />    AppDomain.CurrentDomain.GetAssemblies());</pre><p>Now we have to ensure that the <span class="type">MultipleDispatchEventHandler</span> queries for these concrete types:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">public sealed class MultipleDispatchEventHandler&lt;TEvent&gt; : IEventHandler&lt;TEvent&gt;<br />{<br />    private IEnumerable&lt;IEventHandler&lt;TEvent&gt;&gt; handlers;<br /><br />    public MultipleDispatchEventHandler(Container container)<br />    {<br />        var handlerType = typeof(IEventHandler&lt;TEvent&gt;);<br /><br />        var registrations = (<br />            from r in container.GetCurrentRegistrations()<br />            let assignableInterfaces = (<br />                from intface in r.ServiceType.GetInterfaces()<br />                where handlerType.IsAssignableFrom(intface)<br />                select intface)<br />            where assignableInterfaces.Any()<br />            select r)<br />            .ToArray();<br /><br />        this.handlers =<br />            from r in registrations<br />            select (IEventHandler&lt;TEvent&gt;)r.GetInstance();<br />    }<br /><br />    void IEventHandler&lt;TEvent&gt;.Handle(TEvent e) { ... }<br />}<br /></pre><p>Instead of querying the container for <span class="type">IEventHandler</span><span class="code">&lt;TEvent</span><span class="code">&gt;</span> registrations, we query the container for service types that implement the <span class="type">IEventHandler</span><span class="code">&lt;TEvent</span><span class="code">&gt;</span> interface.</p><p>With this we successfully finished this third scenario. However, in the name of science, let's take a look at a different approach, using unregistered type resolution. Just as we did with the second scenario, we can use unregistered type resolution. Take a look at the following extension method:</p><pre class="cs" language="csharp" customtypes="IEnumerable CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">public static void AllowToResolveVariantCollections(this Container container)<br />{<br />    container.ResolveUnregisteredType += (sender, e) =&gt;<br />    {<br />        // Only handle IEnumerable&lt;T&gt;.<br />        if (!e.UnregisteredServiceType.IsGenericType || <br />            e.UnregisteredServiceType.GetGenericTypeDefinition() != typeof(IEnumerable&lt;&gt;))<br />        {<br />            return;<br />        }<br /><br />        Type serviceType = e.UnregisteredServiceType.GetGenericArguments()[0];<br /><br />        if (!serviceType.IsGenericType)<br />        {<br />            return;<br />        }<br /><br />        Type def = serviceType.GetGenericTypeDefinition();<br /><br />        var registrations = (<br />            from r in container.GetCurrentRegistrations()<br />            where r.ServiceType.IsGenericType<br />            where r.ServiceType.GetGenericTypeDefinition() == def<br />            where serviceType.IsAssignableFrom(r.ServiceType)<br />            select r)<br />            .ToArray();<br />        <br />        if (registrations.Any())<br />        {<br />            var instances = registrations.Select(r =&gt; r.GetInstance());<br /><br />            var castMethod = typeof(Enumerable).GetMethod(&quot;Cast&quot;)<br />                .MakeGenericMethod(serviceType);<br /><br />            var castedInstances = castMethod.Invoke(null, new[] { instances });<br /><br />            e.Register(() =&gt; castedInstances);<br />        }<br />    };<br />}</pre><p>This extension method looks much like the extension method we've seen in the second scenario, with a few differences. First of all, this extension method handles <span class="type">IEnumerable</span><span class="code">&lt;T&gt;</span> types. Just like before it searches the container for assignable types, but if they are found, an <span class="type">IEnumerable</span><span class="code">&lt;T&gt;</span> is constructed that will return all found services.</p><p>We can use this extension method as follows:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">container.AllowToResolveVariantCollections();</pre><p>With the current configuration we can now request an <span class="type">IEnumerable</span><span class="code">&lt;</span><span class="type">IEventHandler</span><span class="code">&lt;TEvent&gt;&gt;</span> and get all assignable implementations:</p><pre class="cs" language="csharp" customtypes="CustomerMovedEvent CustomerMovedAbroadEvent SpecialCustomerMovedEvent IEventHandler CustomerMovedEventHandler NotifyStaffWhenCustomerMovedEventHandler CustomerMovedAbroadEventHandler Container MultipleDispatchEventHandler" customvaluetypes="PutYourCustomValueTypesHere">var handlers = container.GetAllInstances&lt;IEventHandler&lt;CustomerMovedAbroadEvent&gt;&gt;();</pre><p>This will result in a list that contains both the <span class="type">CustomerMovedEventHandler</span> and <span class="type">CustomerMovedAbroadEventHandler</span>.</p><p>As you can see there are many ways to skin a cat. If your scenario is (slightly) different from what we've discussed and you are experiencing some difficulties in finding a good solution, please drop me a note, or <a rel="external" href="http://stackoverflow.com/questions/ask?tags=simple-injector%20ioc-container%20dependency-injection%20.net%20c%23&amp;title=Simple%20Injector:%20Contravariance" title="Ask about Simple Injector at Stackoverflow.com">ask at Stackoverflow</a> (don't forget to tag your question with '<a rel="external" href="http://stackoverflow.com/questions/tagged/simple-injector" title="Stackoverflow - simple-injector tag">simple-injector</a>').</p><p>That's all for now.</p><h4>Happy injecting!</h4>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Dependency_injection">Dependency injection</a>, <a href="/blogs/steven/pivot/archive.php?c=Simple_Injector">Simple Injector</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=90#comm" title="Paul, Eric, Steven">three comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=90#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2011-m10.php#e90" title="Permanent link to 'Adding Covariance and Contravariance to Simple Injector' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=90" title="Permanent link to entry 'Adding Covariance and Contravariance to Simple Injector'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>three comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>Hi Steven<br />
<br />
Thanks for this.  I've been fighting for 2 days to get a mulch-dispatcher working.  I thought GetAllInstances would do the trick - I clearly have no idea what this method does!  But I'm up and running now thanks to this article.<br />
<br />
Paul<br /><small><b>Paul</b>   - 04 12 12 - 13:28 </small></p>
<p>Hi Steven, I wanted to implement Scenario 1 in my project, but I saw that the details on how to raise the events were left as an exercise for the reader. Here's how I did it:<br />
<br />
public class DomainEvents : IDomainEvents<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;private Container Container;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;public DomainEvents(Container container)<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Container = container;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;public void Raise&lt;TEvent&gt;(TEvent e)<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IEventHandler&lt;TEvent&gt; handler =<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container.GetInstance&lt;MultipleDispatchEventHandler&lt;TEvent&gt;&gt;();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler.Handle(e);<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
Like MultipleDispatchEventHandler, this class is part of my Composition Root. It is registered as a Singleton and constructor-injected into my CommandHandlers.<br />
<br />
Is this the approach you'd recommend within the context of the patterns you've presented within this blog?<br /><small><b>Eric</b>   - 19 06 13 - 02:20 </small></p>
<a id="lastcomment"></a><p>I would say that IDomainEvents is a useless abstraction. You can simply inject an IEventHandler&lt;TEvent&gt; into your consumers (such as your command handlers) directly.<br />
<br />
But if you want this extra layer of indirection, let the DomainEvents.Raise method simply request an IEventHandler&lt;TEvent&gt; instead of a specific MultipleDispatchEventHandler&lt;TEvent&gt;.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=90'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=90'>URL</a>) - 19 06 13 - 12:04 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>