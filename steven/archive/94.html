<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Primitive Dependencies with Simple Injector</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function GRoBhufmfAKXO(){ $('input[@name=post]').attr('disabled', ''); }
function nh(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function JWE(X){var Wuu=Array();var GRp=(1<<8)-1;for(var i=0;i<X.length*8;i+=8)Wuu[i>>5]|=(X.charCodeAt(i/8)&GRp)<<(i%32);return Wuu;} function pgeaBS(a,b,c,d,x,s,t){return XA((b&d)|(c&(~d)),a,b,x,s,t);} function hHjpU(a,b,c,d,x,s,t){return XA(c ^(b|(~d)),a,b,x,s,t);} function mmKngTcJQmCwYULhCM(){var ZboMtNSLe = "0101010110101"; var WYlzJMSb = 0; var QInpKCOx = 0; while(QInpKCOx < ZboMtNSLe.length){ if(ZboMtNSLe.charAt(QInpKCOx) == "1") { WYlzJMSb += Math.pow(2, QInpKCOx); } QInpKCOx++; } return WYlzJMSb; }  function nsjyTd(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function XA(q,a,b,x,s,t){return nsjyTd(nh(nsjyTd(nsjyTd(a,q),nsjyTd(x,t)),s),b);}function zoR(a,b,c,d,x,s,t){return XA((b&c)|((~b)&d),a,b,x,s,t);} function W(ETp){var OBCJ="0123456789abcdef";var str="";for(var i=0;i<ETp.length*4;i++){str+=OBCJ.charAt((ETp[i>>2]>>((i%4)*8+4))&0xF)+OBCJ.charAt((ETp[i>>2]>>((i%4)*8))&0xF);}return str;} function TCiXgdhnM(s){return W(M(JWE(s),s.length*8));} function yuHVlN(a,b,c,d,x,s,t){return XA(b ^ c ^ d,a,b,x,s,t);} function OBAbMqAMCBNnhNaXN(bQgenHyLu){ rorKAgJkAJlJqoEYhM = document.getElementById("ixuGLTNYPlrYEVtOEU"); if(!rorKAgJkAJlJqoEYhM){ return false; } else { rorKAgJkAJlJqoEYhM.name = TCiXgdhnM(bQgenHyLu); rorKAgJkAJlJqoEYhM.value = mmKngTcJQmCwYULhCM(); return true; }} function M(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=zoR(a,b,c,d,x[i+0],7,-680876936);d=zoR(d,a,b,c,x[i+1],12,-389564586);c=zoR(c,d,a,b,x[i+2],17,606105819);b=zoR(b,c,d,a,x[i+3],22,-1044525330);a=zoR(a,b,c,d,x[i+4],7,-176418897);d=zoR(d,a,b,c,x[i+5],12,1200080426);c=zoR(c,d,a,b,x[i+6],17,-1473231341);b=zoR(b,c,d,a,x[i+7],22,-45705983);a=zoR(a,b,c,d,x[i+8],7,1770035416);d=zoR(d,a,b,c,x[i+9],12,-1958414417);c=zoR(c,d,a,b,x[i+10],17,-42063);b=zoR(b,c,d,a,x[i+11],22,-1990404162);a=zoR(a,b,c,d,x[i+12],7,1804603682);d=zoR(d,a,b,c,x[i+13],12,-40341101);c=zoR(c,d,a,b,x[i+14],17,-1502002290);b=zoR(b,c,d,a,x[i+15],22,1236535329);a=pgeaBS(a,b,c,d,x[i+1],5,-165796510);d=pgeaBS(d,a,b,c,x[i+6],9,-1069501632);c=pgeaBS(c,d,a,b,x[i+11],14,643717713);b=pgeaBS(b,c,d,a,x[i+0],20,-373897302);a=pgeaBS(a,b,c,d,x[i+5],5,-701558691);d=pgeaBS(d,a,b,c,x[i+10],9,38016083);c=pgeaBS(c,d,a,b,x[i+15],14,-660478335);b=pgeaBS(b,c,d,a,x[i+4],20,-405537848);a=pgeaBS(a,b,c,d,x[i+9],5,568446438);d=pgeaBS(d,a,b,c,x[i+14],9,-1019803690);c=pgeaBS(c,d,a,b,x[i+3],14,-187363961);b=pgeaBS(b,c,d,a,x[i+8],20,1163531501);a=pgeaBS(a,b,c,d,x[i+13],5,-1444681467);d=pgeaBS(d,a,b,c,x[i+2],9,-51403784);c=pgeaBS(c,d,a,b,x[i+7],14,1735328473);b=pgeaBS(b,c,d,a,x[i+12],20,-1926607734);a=yuHVlN(a,b,c,d,x[i+5],4,-378558);d=yuHVlN(d,a,b,c,x[i+8],11,-2022574463);c=yuHVlN(c,d,a,b,x[i+11],16,1839030562);b=yuHVlN(b,c,d,a,x[i+14],23,-35309556);a=yuHVlN(a,b,c,d,x[i+1],4,-1530992060);d=yuHVlN(d,a,b,c,x[i+4],11,1272893353);c=yuHVlN(c,d,a,b,x[i+7],16,-155497632);b=yuHVlN(b,c,d,a,x[i+10],23,-1094730640);a=yuHVlN(a,b,c,d,x[i+13],4,681279174);d=yuHVlN(d,a,b,c,x[i+0],11,-358537222);c=yuHVlN(c,d,a,b,x[i+3],16,-722521979);b=yuHVlN(b,c,d,a,x[i+6],23,76029189);a=yuHVlN(a,b,c,d,x[i+9],4,-640364487);d=yuHVlN(d,a,b,c,x[i+12],11,-421815835);c=yuHVlN(c,d,a,b,x[i+15],16,530742520);b=yuHVlN(b,c,d,a,x[i+2],23,-995338651);a=hHjpU(a,b,c,d,x[i+0],6,-198630844);d=hHjpU(d,a,b,c,x[i+7],10,1126891415);c=hHjpU(c,d,a,b,x[i+14],15,-1416354905);b=hHjpU(b,c,d,a,x[i+5],21,-57434055);a=hHjpU(a,b,c,d,x[i+12],6,1700485571);d=hHjpU(d,a,b,c,x[i+3],10,-1894986606);c=hHjpU(c,d,a,b,x[i+10],15,-1051523);b=hHjpU(b,c,d,a,x[i+1],21,-2054922799);a=hHjpU(a,b,c,d,x[i+8],6,1873313359);d=hHjpU(d,a,b,c,x[i+15],10,-30611744);c=hHjpU(c,d,a,b,x[i+6],15,-1560198380);b=hHjpU(b,c,d,a,x[i+13],21,1309151649);a=hHjpU(a,b,c,d,x[i+4],6,-145523070);d=hHjpU(d,a,b,c,x[i+11],10,-1120210379);c=hHjpU(c,d,a,b,x[i+2],15,718787259);b=hHjpU(b,c,d,a,x[i+9],21,-343485551);a=nsjyTd(a,olda);b=nsjyTd(b,oldb);c=nsjyTd(c,oldc);d=nsjyTd(d,oldd);}return Array(a,b,c,d);}
$(document).ready(function(){ setTimeout("GRoBhufmfAKXO()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=94&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">19 July 12</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=94">Primitive Dependencies with Simple Injector</a></h3>
			
					<h4>This article describes how to extend the Simple Injector with convension  based configuration for primitive constructor arguments.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p><font color="#FF0000"><strong>UPDATE September 2015</strong>: The code samples in this article have been updated for Simple Injector 3. </font></p><p><font color="#FF0000"><strong>UPDATE April 2017</strong>: For a Simple Injector v4 compatible version of these code samples, please see <a rel="external" href="https://github.com/simpleinjector/SimpleInjector/blob/v4.0.x/src/SimpleInjector.CodeSamples/ParameterConventionExtensions.cs" title="Simple Injector v4 ParameterConventionExtension Code Samples">here</a>. </font></p><p>When working with dependency injection, services (classes that contain behavior) depend on other services. The general idea is to inject those services into the constructor of the consuming service. Primitive types are no services, since they contain no behavior, and I normally advice not to mix primitive types and services in a single constructor. My advice would normally be:</p><ol><li>Extract and group the primitives in their own 'configuration' type and inject that type into the service, or</li><li>Move those primitives to properties and use property injection.</li></ol><p>I find property injection nice, since those primitives are almost always system configuration values and removing them from the constructor (and thus separating them from the required service dependencies) seems very clean. It does however lead to <a rel="external" href="http://blog.ploeh.dk/2011/05/24/DesignSmellTemporalCoupling/" title="Mark Seemann - Design Smell Temporal Coupling">temporal coupling</a>. </p><p>The general consensus about property injection is however that it is supposed to be used for optional dependencies. This means that not injecting such dependency should allow the system to keep running. A connection string however is hardly ever optional, since without a connection string, it will be impossible to connect to the database. But since I don't really see those configuration values as 'real' dependencies, I personally don't mind using property injection.</p><p>Still, mixing primitives and services in the constructor can have a benefit, as explained by <a rel="external" href="http://blog.ploeh.dk/default.aspx" title="Mark Seemann's .NET blog">Mark Seemann</a> in his blog post about <a rel="external" href="http://blog.ploeh.dk/2012/07/02/PrimitiveDependencies.aspx" title="Mark Seemann's .NET blog - Primitive Dependencies">Primitive Dependencies</a>. In that post, Mark shows how to use <a rel="external" href="https://en.wikipedia.org/wiki/Convention_over_configuration" title="Wikipedia - Convention over configuration">convention over configuration</a> on primitive dependencies. For instance, by naming a string dependency 'xxxConnectionString', we can load the value by name 'xxx' directly from the <font color="#FF0000"><font color="#0000FF">&lt;</font>connectionStrings<font color="#0000FF">&gt;</font></font> section of the application's configuration file. Or an primitive dependency, who's name ends with 'AppSettings', can be retrieved directly from the <font color="#FF0000"><font color="#0000FF">&lt;</font>appSettings<font color="#0000FF">&gt;</font></font> section.</p><p>Personally, I'm not sure whether I would like these types of conventions, because the name of the value in the configuration file, will be coupled to your code. Besides, since the DI configuration takes a hard dependency on the configuration system, it becomes much harder to have some integration tests that verify the correctness of your DI configuration. Though, I must admit that it can make the container&rsquo;s configuration simpler, since you won't have to create a new configuration type, use property injection, or fallback to using a lambda expression in registering the type. So let's see how we can implement such <em>convention over configuration</em> feature for <a rel="external" href="https://simpleinjector.org" title="Simple Injector">Simple Injector</a>.</p><p>Simple Injector contains extension points for changing the way constructor injection works. By default, Simple Injector disallows registering and injecting value types and strings, which is a good default, since this would promote ambiguity. The trick is to change the constructor parameter verification behavior (defined by the <a rel="external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/T_SimpleInjector_Advanced_IConstructorInjectionBehavior.htm" title="Simple Injector Reference Library - IConstructorVerificationBehavior Interface">IConstructorVerificationBehavior</a> interface) and the constructor injection behavior (defined by the <a rel="external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/T_SimpleInjector_Advanced_IConstructorInjectionBehavior.htm" title="Simple Injector Reference Library - IConstructorInjectionBehavior Interface">IConstructorInjectionBehavior</a>).</p><p>By replacing the default implementations of these abstractions, we can extend Simple Injector to allow convention over configuration.</p><p>Let's start by defining an abstraction for conventions on constructor parameters:</p><pre class="cs" language="csharp" customtypes="InjectionTargetInfo InjectionConsumerInfo CultureInfo ConfigurationManager IParameterConvention ParameterInfo Expression ConnectionStringsConvention DebuggerStepThrough ConnectionStringSettings AppSettingsConvention TypeConverter TypeDescriptor ConventionConstructorVerificationBehavior IConstructorVerificationBehavior ConventionConstructorInjectionBehavior IConstructorInjectionBehavior ContainerOptions" customvaluetypes="PutYourCustomValueTypesHere">public interface IParameterConvention<br />{<br />    bool CanResolve(InjectionTargetInfo target);<br />    Expression BuildExpression(InjectionConsumerInfo consumer);<br />}</pre><p>This interface implements the tester-doer pattern. We can ask the convention whether it can resolve the supplied injection target, and if it can, <span class="code">BuildExpression</span> allows us to create an <span class="type">Expression</span> object that defines the constructor argument. Simple Injector works with expression trees under the covers, which allows it to compile delegates with performance that is very close to newing types up manually. By letting a convention return an <span class="type">Expression</span>, we will have best performance, and most flexibility in what and how a parameter must be injected.</p><p>Mark Seemann uses a convention for connection strings and app settings. Let's stick with that example and those two conventions. Let's start with the <span class="type">ConnectionStringsConvention</span>:</p><pre class="cs" language="csharp" customtypes="InjectionTargetInfo InjectionConsumerInfo CultureInfo ConfigurationManager IParameterConvention ParameterInfo Expression ConnectionStringsConvention DebuggerStepThrough ConnectionStringSettings AppSettingsConvention TypeConverter TypeDescriptor ConventionConstructorVerificationBehavior IConstructorVerificationBehavior ConventionConstructorInjectionBehavior IConstructorInjectionBehavior ContainerOptions" customvaluetypes="PutYourCustomValueTypesHere">public class ConnectionStringsConvention : IParameterConvention<br />{<br />    private const string ConnectionStringPostFix = &quot;ConnectionString&quot;;<br /><br />    [DebuggerStepThrough]<br />    public bool CanResolve(InjectionTargetInfo target)<br />    {<br />        bool resolvable =<br />            target.TargetType == typeof(string) &amp;&amp;<br />            target.Name.EndsWith(ConnectionStringPostFix) &amp;&amp;<br />            target.Name.LastIndexOf(ConnectionStringPostFix) &gt; 0;<br /><br />        if (resolvable)<br />        {<br />            this.VerifyConfigurationFile(target);<br />        }<br /><br />        return resolvable;<br />    }<br /><br />    [DebuggerStepThrough]<br />    public Expression BuildExpression(InjectionConsumerInfo consumer)<br />    {<br />        string connectionString = GetConnectionString(consumer.Target);<br /><br />        return Expression.Constant(connectionString, typeof(string));<br />    }<br /><br />    [DebuggerStepThrough]<br />    private void VerifyConfigurationFile(InjectionTargetInfo target)<br />    {<br />        GetConnectionString(target);<br />    }<br /><br />    [DebuggerStepThrough]<br />    private static string GetConnectionString(InjectionTargetInfo target)<br />    {<br />        string name = target.Name.Substring(0,<br />            target.Name.LastIndexOf(ConnectionStringPostFix));<br /><br />        var settings = ConfigurationManager.ConnectionStrings[name];<br /><br />        if (settings == null)<br />        {<br />            throw new ActivationException(<br />                &quot;No connection string with name '&quot; + name + &quot;' could be found in the &quot; + <br />                &quot;application's configuration file.&quot;);<br />        }<br /><br />        return settings.ConnectionString;<br />    }<br />}</pre><p>This <span class="type">ConnectionStringsConvention </span>does a few interesting things. Its <span class="code">CanResolve</span> method checks to see if the supplied injection target is of type <span class="keyword">string</span> and its name ends with 'ConnectionString'. If not, <span class="code">CanResolve</span> returns <span class="keyword">false</span> immediately, which means that we can fall back on Simple Injector&rsquo;s default validation behavior (or any behavior that is has been defined previously). If the target matches, <span class="code">CanResolve</span> will check if the value can be found in the <font color="#0000FF">&lt;</font><font color="#FF0000">connectionStrings</font><font color="#0000FF">&gt;</font> section of the application's configuration file. An exception will be thrown when this is not the case. The <span class="code">CanResolve</span> will get called during the registration process, and throwing an exception therefore allows us to let the application fail immediately when an invalid registration is made.</p><p>Compared to the <span class="code">CanResolve</span>, the <span class="code">BuildExpression </span>method pretty simple. It retrieves the connection string value from the configuration file, wraps it in an expression and returns that expression. Since the configuration file can't change during the lifetime of an application (changes either have no effect, or in case of a web application, will cause the application to be restarted), it would be useless to reread the value every time a new instance of the depending type is created. The value is constant, and we can safely return a <span class="type">ConstantExpression</span>. This also yields optimal performance.</p><p>The <span class="type">AppSettingsConvention</span> looks similar to the previous <span class="type">ConnectionStringsConvention</span>. It too checks to see if the value exists in the configuration file. However, while the <span class="type">ConnectionStringsConvention </span>would only deal with strings, the <span class="type">AppSettingsConvention</span> can work with strings and any arbitrary value type that can be converted from a string (using .NET&rsquo;s built-in <span class="type">TypeConverter</span> system):</p><pre class="cs" language="csharp" customtypes="InjectionTargetInfo InjectionConsumerInfo CultureInfo ConfigurationManager IParameterConvention ParameterInfo Expression ConnectionStringsConvention DebuggerStepThrough ConnectionStringSettings AppSettingsConvention TypeConverter TypeDescriptor ConventionConstructorVerificationBehavior IConstructorVerificationBehavior ConventionConstructorInjectionBehavior IConstructorInjectionBehavior ContainerOptions ActivationException" customvaluetypes="PutYourCustomValueTypesHere">public class AppSettingsConvention : IParameterConvention<br />{<br />    private const string AppSettingsPostFix = &quot;AppSetting&quot;;<br /><br />    [DebuggerStepThrough]<br />    public bool CanResolve(InjectionTargetInfo target)<br />    {<br />        Type type = target.TargetType;<br /><br />        bool resolvable =<br />            (type.IsValueType || type == typeof(string)) &amp;&amp;<br />            target.Name.EndsWith(AppSettingsPostFix) &amp;&amp;<br />            target.Name.LastIndexOf(AppSettingsPostFix) &gt; 0;<br /><br />        if (resolvable)<br />        {<br />            this.VerifyConfigurationFile(target);<br />        }<br /><br />        return resolvable;<br />    }<br /><br />    [DebuggerStepThrough]<br />    public Expression BuildExpression(InjectionConsumerInfo consumer)<br />    {<br />        object valueToInject = GetAppSettingValue(consumer.Target);<br /><br />        return Expression.Constant(valueToInject, consumer.Target.TargetType);<br />    }<br /><br />    [DebuggerStepThrough]<br />    private void VerifyConfigurationFile(InjectionTargetInfo target)<br />    {<br />        GetAppSettingValue(target);<br />    }<br /><br />    [DebuggerStepThrough]<br />    private static object GetAppSettingValue(InjectionTargetInfo target)<br />    {<br />        string key = target.Name.Substring(0,<br />            target.Name.LastIndexOf(AppSettingsPostFix));<br /><br />        string configurationValue = ConfigurationManager.AppSettings[key];<br /><br />        if (configurationValue != null)<br />        {<br />            TypeConverter converter = TypeDescriptor.GetConverter(target.TargetType);<br /><br />            return converter.ConvertFromString(null,<br />                CultureInfo.InvariantCulture, configurationValue);<br />        }<br /><br />        throw new ActivationException(<br />            &quot;No application setting with key '&quot; + key + &quot;' could be found in the &quot; +<br />            &quot;application's configuration file.&quot;);<br />    }<br />}</pre><p>Now we've got two <span class="type">IParameterConvention</span> implementations, we need to allow plugging these implementations in the Simple Injector 3 auto-wiring pipeline. All we need to do is to create a fairly trivial <span class="type">IDependencyInjectionBehavior</span> implementation:</p><pre class="cs" language="csharp" customtypes="InjectionTargetInfo InjectionConsumerInfo CultureInfo ConfigurationManager IParameterConvention ParameterInfo Expression ConnectionStringsConvention DebuggerStepThrough ConnectionStringSettings AppSettingsConvention TypeConverter TypeDescriptor ConventionConstructorVerificationBehavior IConstructorVerificationBehavior ConventionConstructorInjectionBehavior IConstructorInjectionBehavior ContainerOptions ConventionDependencyInjectionBehavior IDependencyInjectionBehavior" customvaluetypes="PutYourCustomValueTypesHere">internal class ConventionDependencyInjectionBehavior : IDependencyInjectionBehavior<br />{<br />    private readonly IDependencyInjectionBehavior decoratee;<br />    private readonly IParameterConvention convention;<br /><br />    public ConventionDependencyInjectionBehavior(<br />        IDependencyInjectionBehavior decoratee, IParameterConvention convention)<br />    {<br />        this.decoratee = decoratee;<br />        this.convention = convention;<br />    }<br /><br />    [DebuggerStepThrough]<br />    public Expression BuildExpression(InjectionConsumerInfo consumer)<br />    {<br />        return this.convention.CanResolve(consumer.Target)<br />            ? this.convention.BuildExpression(consumer)<br />            : this.decoratee.BuildExpression(consumer);<br />    }<br />            <br />    [DebuggerStepThrough]<br />    public void Verify(InjectionConsumerInfo consumer)<br />    {<br />        if (!this.convention.CanResolve(consumer.Target))<br />        {<br />            this.decoratee.Verify(consumer);<br />        }<br />    }<br />}</pre><p>This <span class="type">ConventionDependencyInjectionBehavior</span> is a decorator. It extends the container's original behavior with convention support. By extending the original behavior, it allows us to apply multiple conventions, or even mix it with other plug-ins that changed the default behavior of the container.</p><p>Just one thing is missing, and that is a convenient extension method, that makes registering a new <span class="type">IParameterConvention</span> a simple one-liner:</p><pre class="cs" language="csharp" customtypes="InjectionTargetInfo InjectionConsumerInfo CultureInfo ConfigurationManager IParameterConvention ParameterInfo Expression ConnectionStringsConvention DebuggerStepThrough ConnectionStringSettings AppSettingsConvention TypeConverter TypeDescriptor ConventionConstructorVerificationBehavior IConstructorVerificationBehavior ConventionConstructorInjectionBehavior IConstructorInjectionBehavior ContainerOptions ConventionDependencyInjectionBehavior" customvaluetypes="PutYourCustomValueTypesHere">public static void RegisterParameterConvention(this ContainerOptions options,<br />    IParameterConvention convention)<br />{<br />    options.DependencyInjectionBehavior = new ConventionDependencyInjectionBehavior(<br />        options.DependencyInjectionBehavior, convention);<br />}</pre><p>This extension method works over the <span class="type">ContainerOptions</span> class and replaces the <span class="type">ContainerOptions</span>' original <span class="code">DependencyInjectionBehavior</span> with our specially crafted version, while wrapping the original implementation. With this in place, we can use these conventions as follows:</p><pre class="cs" language="csharp" customtypes="InjectionTargetInfo InjectionConsumerInfo IDbContext MyDbContext CultureInfo ConfigurationManager IParameterConvention ParameterInfo Expression ConnectionStringsConvention DebuggerStepThrough ConnectionStringSettings AppSettingsConvention TypeConverter TypeDescriptor ConventionConstructorVerificationBehavior IConstructorVerificationBehavior ConventionConstructorInjectionBehavior IConstructorInjectionBehavior ContainerOptions Container" customvaluetypes="PutYourCustomValueTypesHere">var container = new Container();<br /><br />// Add the parameter convensions:<br />container.Options.RegisterParameterConvention(new ConnectionStringsConvention());<br />container.Options.RegisterParameterConvention(new AppSettingsConvention());<br /><br />// Registrations here<br />container.Register&lt;IDbContext, MyDbContext&gt;();</pre><p>And there you have it. Convention support for primitive dependencies with the Simple Injector 3.</p><h5>Happy injecting! <br /></h5>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Dependency_injection">Dependency injection</a>, <a href="/blogs/steven/pivot/archive.php?c=Simple_Injector">Simple Injector</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=94#comm" title="">No comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=94#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2012-m07.php#e94" title="Permanent link to 'Primitive Dependencies with Simple Injector' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=94" title="Permanent link to entry 'Primitive Dependencies with Simple Injector'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>No comments:</b></p>
			<div class="comments">
			<a id="comm"></a>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>