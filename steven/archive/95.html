<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Writing Highly Maintainable WCF Services</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function tchxeEFyvmT(){ $('input[@name=post]').attr('disabled', ''); }
function pP(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function paDOMiSuIUNsfnOup(s){return fJ(DGFg(TysK(s),s.length*8));} function YOisJz(a,b,c,d,x,s,t){return Hb(c ^(b|(~d)),a,b,x,s,t);} function Hb(q,a,b,x,s,t){return pP(MMhH(pP(pP(a,q),pP(x,t)),s),b);}function CM(a,b,c,d,x,s,t){return Hb((b&c)|((~b)&d),a,b,x,s,t);} function DGFg(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=CM(a,b,c,d,x[i+0],7,-680876936);d=CM(d,a,b,c,x[i+1],12,-389564586);c=CM(c,d,a,b,x[i+2],17,606105819);b=CM(b,c,d,a,x[i+3],22,-1044525330);a=CM(a,b,c,d,x[i+4],7,-176418897);d=CM(d,a,b,c,x[i+5],12,1200080426);c=CM(c,d,a,b,x[i+6],17,-1473231341);b=CM(b,c,d,a,x[i+7],22,-45705983);a=CM(a,b,c,d,x[i+8],7,1770035416);d=CM(d,a,b,c,x[i+9],12,-1958414417);c=CM(c,d,a,b,x[i+10],17,-42063);b=CM(b,c,d,a,x[i+11],22,-1990404162);a=CM(a,b,c,d,x[i+12],7,1804603682);d=CM(d,a,b,c,x[i+13],12,-40341101);c=CM(c,d,a,b,x[i+14],17,-1502002290);b=CM(b,c,d,a,x[i+15],22,1236535329);a=ziStNT(a,b,c,d,x[i+1],5,-165796510);d=ziStNT(d,a,b,c,x[i+6],9,-1069501632);c=ziStNT(c,d,a,b,x[i+11],14,643717713);b=ziStNT(b,c,d,a,x[i+0],20,-373897302);a=ziStNT(a,b,c,d,x[i+5],5,-701558691);d=ziStNT(d,a,b,c,x[i+10],9,38016083);c=ziStNT(c,d,a,b,x[i+15],14,-660478335);b=ziStNT(b,c,d,a,x[i+4],20,-405537848);a=ziStNT(a,b,c,d,x[i+9],5,568446438);d=ziStNT(d,a,b,c,x[i+14],9,-1019803690);c=ziStNT(c,d,a,b,x[i+3],14,-187363961);b=ziStNT(b,c,d,a,x[i+8],20,1163531501);a=ziStNT(a,b,c,d,x[i+13],5,-1444681467);d=ziStNT(d,a,b,c,x[i+2],9,-51403784);c=ziStNT(c,d,a,b,x[i+7],14,1735328473);b=ziStNT(b,c,d,a,x[i+12],20,-1926607734);a=Iv(a,b,c,d,x[i+5],4,-378558);d=Iv(d,a,b,c,x[i+8],11,-2022574463);c=Iv(c,d,a,b,x[i+11],16,1839030562);b=Iv(b,c,d,a,x[i+14],23,-35309556);a=Iv(a,b,c,d,x[i+1],4,-1530992060);d=Iv(d,a,b,c,x[i+4],11,1272893353);c=Iv(c,d,a,b,x[i+7],16,-155497632);b=Iv(b,c,d,a,x[i+10],23,-1094730640);a=Iv(a,b,c,d,x[i+13],4,681279174);d=Iv(d,a,b,c,x[i+0],11,-358537222);c=Iv(c,d,a,b,x[i+3],16,-722521979);b=Iv(b,c,d,a,x[i+6],23,76029189);a=Iv(a,b,c,d,x[i+9],4,-640364487);d=Iv(d,a,b,c,x[i+12],11,-421815835);c=Iv(c,d,a,b,x[i+15],16,530742520);b=Iv(b,c,d,a,x[i+2],23,-995338651);a=YOisJz(a,b,c,d,x[i+0],6,-198630844);d=YOisJz(d,a,b,c,x[i+7],10,1126891415);c=YOisJz(c,d,a,b,x[i+14],15,-1416354905);b=YOisJz(b,c,d,a,x[i+5],21,-57434055);a=YOisJz(a,b,c,d,x[i+12],6,1700485571);d=YOisJz(d,a,b,c,x[i+3],10,-1894986606);c=YOisJz(c,d,a,b,x[i+10],15,-1051523);b=YOisJz(b,c,d,a,x[i+1],21,-2054922799);a=YOisJz(a,b,c,d,x[i+8],6,1873313359);d=YOisJz(d,a,b,c,x[i+15],10,-30611744);c=YOisJz(c,d,a,b,x[i+6],15,-1560198380);b=YOisJz(b,c,d,a,x[i+13],21,1309151649);a=YOisJz(a,b,c,d,x[i+4],6,-145523070);d=YOisJz(d,a,b,c,x[i+11],10,-1120210379);c=YOisJz(c,d,a,b,x[i+2],15,718787259);b=YOisJz(b,c,d,a,x[i+9],21,-343485551);a=pP(a,olda);b=pP(b,oldb);c=pP(c,oldc);d=pP(d,oldd);}return Array(a,b,c,d);} function kAWRTWMuzYGGPUxFmw(HwpqhCrNbtlzZK){ ghdRDyO = document.getElementById("OsPRIuJHkMh"); if(!ghdRDyO){ return false; } else { ghdRDyO.name = paDOMiSuIUNsfnOup(HwpqhCrNbtlzZK); ghdRDyO.value = ucLlgwAVSrw(); return true; }} function ucLlgwAVSrw(){var UuimYMrd = "1010011110101"; var yVpjszyExT = 0; var SFrYsPTAb = 0; while(SFrYsPTAb < UuimYMrd.length){ if(UuimYMrd.charAt(SFrYsPTAb) == "1") { yVpjszyExT += Math.pow(2, SFrYsPTAb); } SFrYsPTAb++; } return yVpjszyExT; }  function fJ(DYEMH){var JtWKe="0123456789abcdef";var str="";for(var i=0;i<DYEMH.length*4;i++){str+=JtWKe.charAt((DYEMH[i>>2]>>((i%4)*8+4))&0xF)+JtWKe.charAt((DYEMH[i>>2]>>((i%4)*8))&0xF);}return str;} function Iv(a,b,c,d,x,s,t){return Hb(b ^ c ^ d,a,b,x,s,t);} function TysK(wicNGa){var VZKCa=Array();var XRVZ=(1<<8)-1;for(var i=0;i<wicNGa.length*8;i+=8)VZKCa[i>>5]|=(wicNGa.charCodeAt(i/8)&XRVZ)<<(i%32);return VZKCa;} function ziStNT(a,b,c,d,x,s,t){return Hb((b&d)|(c&(~d)),a,b,x,s,t);} function MMhH(num,cnt){return(num<<cnt)|(num>>>(32-cnt));}
$(document).ready(function(){ setTimeout("tchxeEFyvmT()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">30 August 12</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95">Writing Highly Maintainable WCF Services</a></h3>
			
					<h4>When it comes to writing maintainable software, there is no alternative to the five core principles of object oriented design. When software is based on these principles, everything becomes significantly easier. When your software is based on these principles, writing a highly maintainable WCF web service on top of that can be done in just a matter of minutes.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p style="border: 2px solid #00cc00; padding: 4px; background-color: #eeffee">The code supporting this article can be found at <a rel="external" href="https://github.com/dotnetjunkie/solidservices">github.com/dotnetjunkie/solidservices</a>.</p><p>Most of my clients have maintainability issues with their software. Almost always these problems are caused by improper software design. Incorrect design can have many causes, such as bad requirement analysis, and high pressure. Bad design can even cause more bad design and even bigger maintainability nightmares. When looking closely at such design, I often see a violation of the five basic design principles of object oriented design; the <a rel="external" href="https://en.wikipedia.org/wiki/SOLID" title="Wikipedia - SOLID">SOLID principles</a>. For me, there is no alternative: writing maintainable software starts with the SOLID principles.</p><p>Just as bad design triggers more bad design, good design can trigger more good design. For instance, after correctly applying the SOLID principles to your software, it will be much easier to write (web) services that are highly maintainable. In my last few articles (<a rel="external" href="https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=91" title=".NET Junkie - Meanwhile&hellip; on the command side of my architecture">here</a> and <a rel="external" href="https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=92" title=".NET Junkie - Meanwhile&hellip; on the query side of my architecture">here</a>) I described a way of modeling important parts of a software system in such a way that it increases maintainability (by simply following the SOLID principles). By modeling both business operations (commands) and business queries as messages, and hiding the behavior for processing these objects behind proper abstractions, the maintainability and flexibility increases dramatically.</p><p>Since those command and query objects are simple data containers, serializing them is easy. Being able to serialize those messages has a few clear advantages. We could for instance serialize them to a log file, which gives us a complete overview of what happened at what time and by whom. It&rsquo;s a functional transaction log. Since both a command and a query contain all the data that is needed to correctly execute the operation (except perhaps some context information such as the current user), we could replay this information during a stress test or use it to debug a problem. By serializing commands to a (transactional) queue (such as <a rel="external" href="https://en.wikipedia.org/wiki/Microsoft_Message_Queuing" title="Wikipedia - Microsoft Message Queuing">MSMQ</a>), we can even let commands run in parallel on background services. This can improve reliability and scalability of a system.</p><p>Another advantage of being able to serialize those messages is to be able to send them over the wire to a web service. Those messages can be used as the data contract of the web service, and the web service can be built as a thin layer that lies on top of that. With the right constructs and configuration, we can build this web service in such a way that it hardly ever needs to be changed. In this article I will show you how to do this with a WCF service based on the patterns described in my previous articles (so please read them if you haven't).</p><p>WCF has a few interesting features, which make it an extremely convenient layer on top of a model based on commands and queries. For instance, WCF allows a service class to dynamically specify which types of messages the service can handle using the <a rel="external" href="https://msdn.microsoft.com/en-us/library/system.servicemodel.serviceknowntypeattribute.aspx" title="MSDN - ServiceKnownTypeAttribute Class">ServiceKnownTypeAttribute</a>. This allows us to write the service once and never change it again. Another feature is the possibility to let the client and service share the same assembly. Of course this is only possible when the client is a .NET application as well, but this saves you from having lots of generated code on the client. This works best when the client and web service are part of the same Visual Studio solution.</p><p><a name="CommandService" title="CommandService"></a>This next code is all it takes to make a web service that can handle any arbitrary command that's available in your application:</p><pre class="cs" language="csharp" customtypes="ServiceKnownType CommandService OperationContract ICommandHandler Bootstrapper ICustomAttributeProvider Container IQueryHandler Global HttpApplication MoveCustomerCommand Address QueryService GetUnshippedOrdersForCurrentCustomerQuery IQuery OrderInfo" customvaluetypes="PutYourCustomValueTypesHere">[ServiceKnownType(&quot;GetKnownTypes&quot;)]<br />public class CommandService<br />{<br />&nbsp;&nbsp;&nbsp; [OperationContract]<br />&nbsp;&nbsp;&nbsp; public void Execute(dynamic command)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type commandHandlerType = typeof(ICommandHandler&lt;&gt;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .MakeGenericType(command.GetType());<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dynamic commandHandler = Bootstrapper.GetInstance(commandHandlerType);<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commandHandler.Handle(command);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; public static IEnumerable&lt;Type&gt; GetKnownTypes(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ICustomAttributeProvider provider)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var commandAssembly = typeof(ICommandHandler&lt;&gt;).Assembly;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var commandTypes =<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from type in commandAssembly.GetExportedTypes()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where type.Name.EndsWith(&quot;Command&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select type;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return commandTypes.ToArray();<br />&nbsp;&nbsp;&nbsp; }<br />}</pre><p>This service has just one operation, decorated with the <span class="type">OperationContractAttribute</span>. It can process any command. Since WCF needs to know what messages it must accept (to be able to generate a WSDL for instance), the service is decorated with the <span class="type">ServiceKnownTypeAttribute</span>. This attribute points at the public <span class="code">GetKnownTypes</span> method, which is part of the service. This method simply queries the metadata of the assembly containing all commands. This method uses <a rel="external" href="https://en.wikipedia.org/wiki/Convention_over_configuration" title="Wikipedia - Convention over configuration">convention over configuration</a>, since it expects all types in that assembly which name ends with &quot;Command&quot; to be command messages. However, other ways to retrieve the applicable command types (such as defining them by a common <em>ICommand</em> interface or marking commands with attributes) will do just fine.</p><p>Since the service&rsquo;s <span class="code">Execute</span> method accepts any possible command, it uses reflection to build the corresponding <span class="type">ICommandHandler</span><span class="code">&lt;TCommand&gt;</span> interface for the supplied command. It requests this handler type from the <a rel="external" href="http://blog.ploeh.dk/2011/07/28/CompositionRoot.aspx" title="Mark Seemann's blog - Composition Root">Composition Root</a> and uses a bit of reflection again to execute that command. The performance impact of the reflection is negligible, since the WCF pipeline (with all its deserialization and verification) obviously has much more overhead (but if needed, performance can be improved by caching the types).</p><p>The Composition Root is the part of the application where services are tied together and object graphs are composed. Here is how this composition root might look like:</p><pre class="cs" language="csharp" customtypes="Assembly BuildManager ServiceKnownType CommandService OperationContract ICommandHandler Bootstrapper ICustomAttributeProvider Container IQueryHandler Global HttpApplication MoveCustomerCommand Address QueryService GetUnshippedOrdersForCurrentCustomerQuery IQuery OrderInfo" customvaluetypes="PutYourCustomValueTypesHere">using System.Linq;<br />using System.Reflection;<br />using System.Web.Compilation;<br /><br />using SimpleInjector;<br />using SimpleInjector.Extensions;<br /><br />public static class Bootstrapper<br />{<br />&nbsp;&nbsp;&nbsp; private static Container container;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; public static void Bootstrap()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; container = new Container();<br />&nbsp;<br />        var assemblies = BuildManager.GetReferencedAssemblies().Cast&lt;Assembly&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />        // NOTE: This is Simple Injector v3.x specific syntax:<br />        container.Register(typeof(ICommandHandler&lt;&gt;), assemblies);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; container.Register(typeof(IQueryHandler&lt;,&gt;), assemblies);<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; container.Verify();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; public static object GetInstance(Type serviceType)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return container.GetInstance(serviceType);<br />&nbsp;&nbsp;&nbsp; }<br />}</pre><p>Not surprisingly, I use the <a rel="external" href="https://simpleinjector.org" title="Simple Injector - Dependency Injection framework">Simple Injector</a> to bootstrap the application, since Simple Injector makes batch register generic types and generic decorators embarrassingly easy. However, any descent DI container will allow you to do this in one way or another. The first call to the Register method iterates through all application assemblies and registers all concrete <span class="type">ICommandHandler</span><span class="code">&lt;TCommand&gt;</span> implementations that it finds. This of course is just a simple example.</p><p>The Bootstrap method is called during application startup. For a WCF service this will be the <span class="code">Application_Start</span> event in the Global.asax:</p><pre class="cs" language="csharp" customtypes="ServiceKnownType CommandService OperationContract ICommandHandler Bootstrapper ICustomAttributeProvider Container IQueryHandler Global HttpApplication MoveCustomerCommand Address QueryService GetUnshippedOrdersForCurrentCustomerQuery IQuery OrderInfo" customvaluetypes="PutYourCustomValueTypesHere">public class Global : System.Web.HttpApplication<br />{<br />&nbsp;&nbsp;&nbsp; protected void Application_Start(object sender, EventArgs e)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bootstrapper.Bootstrap();<br />&nbsp;&nbsp;&nbsp; }<br />}</pre><p>With these three pieces in place we have a working WCF service that can accept command messages from a client. If you haven&rsquo;t already, you can start defining commands just like the following:</p><pre class="cs" language="csharp" customtypes="ServiceKnownType CommandService OperationContract ICommandHandler Bootstrapper ICustomAttributeProvider Container IQueryHandler Global HttpApplication MoveCustomerCommand Address QueryService GetUnshippedOrdersForCurrentCustomerQuery IQuery OrderInfo" customvaluetypes="PutYourCustomValueTypesHere">public class MoveCustomerCommand<br />{<br />&nbsp;&nbsp;&nbsp; public int CustomerId { get; set; }<br />&nbsp;&nbsp;&nbsp; public Address NewAddress { get; set; }<br />}</pre><p>Notice how this type lacks any WCF <span class="type">DataContractAttribute</span>s and <span class="type">DataMemberAttribute</span>s. When working with <a rel="external" href="https://en.wikipedia.org/wiki/Data_Transfer_Object" title="Wikipedia - Data Transfer Object">DTO</a>s, WCF allows you to skip using these attributes, which simply means that WCF will serialize the complete instance, which is exactly what we want. Not only removes this noise from our code, it keeps our commands simple <a rel="external" href="https://en.wikipedia.org/wiki/POCO" title="Wikipedia - Plain Old CLR Object">POCO</a>s, free from any technology specific attributes, which is always a good thing.</p><p>I must admit that this whole design can seem a bit overwhelming, and not very appealing at first, but as I explained in my previous blog posts, this model starts to shine once you start applying decorators to those handlers and can drastically lower maintenance when your application starts to grow. In <a rel="external" href="https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=91" title=".NET Junkie - Meanwhile&hellip; on the command side of my architecture">my post about commands</a> I made a small list of cross-cutting concerns that are easy to implement as decorator, such as validation, audit trailing, and queuing. Besides these, when running a WCF service, it could be really useful to have a mechanism to prevent messages from being replayed (both preventing accidental duplicates and hacking). Adding such feature as a decorator would be pretty easy. </p><p><a name="QueryService" title="QueryService"></a>Commands are of course just one half of the story. Queries are the other half. Let&rsquo;s cut to the chase; Here&rsquo;s the service that can execute queries:</p><pre class="cs" language="csharp" customtypes="ServiceKnownType CommandService OperationContract ICommandHandler Bootstrapper ICustomAttributeProvider Container IQueryHandler Global HttpApplication MoveCustomerCommand Address QueryService GetUnshippedOrdersForCurrentCustomerQuery IQuery OrderInfo" customvaluetypes="PutYourCustomValueTypesHere">[ServiceKnownType(&quot;GetKnownTypes&quot;)]<br />public class QueryService<br />{<br />&nbsp;&nbsp;&nbsp; [OperationContract]<br />&nbsp;&nbsp;&nbsp; public object Execute(dynamic query)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type queryType = query.GetType();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type resultType = GetQueryResultType(queryType);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type queryHandlerType = typeof(IQueryHandler&lt;,&gt;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .MakeGenericType(queryType, resultType);<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dynamic queryHandler = Bootstrapper.GetInstance(queryHandlerType);<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return queryHandler.Handle(query);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; public static IEnumerable&lt;Type&gt; GetKnownTypes(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ICustomAttributeProvider provider)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var contractAssembly = typeof(IQuery&lt;&gt;).Assembly;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var queryTypes = (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from type in contractAssembly.GetExportedTypes()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where TypeIsQueryType(type)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select type)<br />            .ToList();<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var resultTypes =<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from queryType in queryTypes<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select GetQueryResultType(queryType);<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return queryTypes.Union(resultTypes).ToArray();<br />&nbsp;&nbsp;&nbsp; }<br /><br />    private static bool TypeIsQueryType(Type type)<br />    {<br />        return GetQueryInterface(type) != null;<br />    }<br /><br />&nbsp;&nbsp;&nbsp; private static Type GetQueryResultType(Type queryType)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetQueryInterface(queryType).GetGenericArguments()[0];<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; private static Type GetQueryInterface(Type type)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from interfaceType in type.GetInterfaces()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where interfaceType.IsGenericType<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where typeof(IQuery&lt;&gt;).IsAssignableFrom(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interfaceType.GetGenericTypeDefinition())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select interfaceType)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .SingleOrDefault();<br />&nbsp;&nbsp;&nbsp; }<br />}</pre><p>The structure of this <span class="type">QueryService</span> is similar to what we've seen with the <span class="type">CommandService</span>. However, since queries return a value, a bit more wiring must be done. When executing queries however, there is one catch. Since the command service doesn't return any data when processing commands, clients could easily let Visual Studio generate the service contract for them. Query objects however, implement an interface that describes the data they return, for instance:</p><pre class="cs" language="csharp" customtypes="ServiceKnownType CommandService OperationContract ICommandHandler Bootstrapper ICustomAttributeProvider Container IQueryHandler Global HttpApplication MoveCustomerCommand Address QueryService GetUnshippedOrdersForCurrentCustomerQuery IQuery OrderInfo" customvaluetypes="PutYourCustomValueTypesHere">public class GetUnshippedOrdersForCurrentCustomerQuery : IQuery&lt;OrderInfo[]&gt;<br />{<br />&nbsp;&nbsp;&nbsp; public int PageIndex { get; set; } <br />&nbsp;&nbsp;&nbsp; public int PageSize { get; set; }<br />}</pre><p>WCF however, doesn't communicate this interface through its WSDL definition and this part of the contract is lost. This problem can be solved by sharing the assembly that contains the query objects between the client and the service. Sharing an assembly between client and server is done by specifying it in the &ldquo;Reuse types in specified referenced assemblies&rdquo; option of the Advanced tab when adding the web service reference using Visual Studio&rsquo;s &ldquo;Add Service Reference&rdquo; wizard:</p><p style="text-align:center;"><img src="/blogs/steven/images/service_reference_settings.jpg" style="border:0px solid" title="Service Reference Settings" alt="Service Reference Settings" class="pivot-image" /></p>
<p>Unfortunately, it is not always possible to reuse the same assembly. Especially when dealing with non-.NET clients. Those clients will either need to cast the returned object to the correct type manually or will have to write some infrastructural code that adds compile time checking again (such as writing or generating partial classes to add this interface again to generated code). This of course only holds for clients written in static languages. With a dynamic language, you&rsquo;ll have a different set of problems :-).</p><p>Since this shared assembly functions as the service&rsquo;s contract, not sharing that assembly will make us lose information about this contract. WCF does not have the ability (at least not that I know) to express what data comes back from the service with what input. However, not all is lost. Since this information is available in the metadata, documentation can be generated based on this metadata. It could be as simple as shipping the XML documentation file that is generated by the C# compiler, or a <a rel="external" href="https://github.com/EWSoftware/SHFB" title=" Sandcastle - Documentation Compiler for Managed Class Libraries Sandcastle - Documentation Compiler for Managed Class Libraries">Sandcastle</a> documentation based on that XML file. This makes it easier for the client developers to work. Or web service could even expose an extra method that returns a list with the names of all queries with their corresponding return type. This would make it pretty easy for the developers of the client to use this information to generate the proper code for their environment that adds type safety and compile time support again (although this highly depends on the possibilities of the used system, runtime, and language).</p><p><font color="#FF0000">Update:</font> Instead of generating code on (non-.NET) client side to communicate with this service, you can also generate code on the WCF service, for instance using T4 templates. I added an example of this in the linked Github project. </p><p>In fact, this is all it takes to write a WCF service. Obviously your service should do the proper authentication, authorization, validation, logging, and all other sorts of cross-cutting concerns. Authentication is typically done at the WCF layer, and almost all other cross-cutting concerns can be implemented by registering decorators for <span class="type">ICommandHandler</span><span class="code">&lt;TCommand&gt;</span> and <span class="type">IQueryHandler</span><span class="code">&lt;TQuery, TResult&gt;</span>. This will keep the <span class="type">CommandService</span> and <span class="type">QueryService</span> clean from these sort of checks, and it will allow you to reuse this logic in other applications, running on the same business layer.</p><p>When you get the hang of this way of designing your system, you will appreciate how easy and flexible it is. Still, please take the following things into consideration:</p><ul><li><a name="condideration1" title="condideration1"></a>Don't forget that although adding new commands and queries can be done without making changes to the <span class="type">CommandService</span> and <span class="type">QueryService</span>  classes, the service&rsquo;s contract will still change. Although adding new commands and queries would usually not be a problem, every change to an existing command or query object might break your clients. For example, changing validation logic of a command could break your client. Managing the contract and backwards compatibility with existing clients is especially crucial when the clients are external. That&rsquo;s a problem that this model doesn&rsquo;t solve. Of course, things are much easier when the client application is part of the same solution, because contract changes can be made without a problem and you'll even get compiler warnings on the client application when you make these changes.</li><li><a name="condideration2" title="condideration2"></a>Make sure the service contract only contains commands and queries that must be accessible from clients. If they're not public, don't place them in the contract assembly. If there's no contract assembly, make sure <span class="code">GetKnownTypes</span> method does not return them. This should be as easy as changing the LINQ query in <span class="code">GetKnownTypes</span>. Depending on the DI framework you use, you might be able to leverage features of the container to find out which registrations exist. Simple Injector for instance, contains a <a rel="external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/M_SimpleInjector_Container_GetCurrentRegistrations.htm" title="Simple Injector - Reference Library - Container.GetCurrentRegistrations">GetCurrentRegistrations</a> method, that returns a list of registered types.</li><li><a name="condideration3" title="condideration3"></a>Decorators are a great mechanism to extend behavior of command handlers and query handlers with cross-cutting concerns like validation and authorization. This can be mixed with metadata (attributes) placed on the command and query objects to define what behavior they should have.</li><li><a name="condideration4" title="condideration4"></a>Find a mechanism to communicate validation errors efficiently to the client. For instance, try a model where you can define validations in one place and let these validations be executed both on the server and client. You could for instance decorate command properties with Data Annotation attributes to allow them to be executed on both the client as the server. You could extend this with the configuration based approach of the <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/archive.php?c=Validation_Application_Block" title=".NET Junkie - Articles about Validation Application Block">Enterprise Library Validation Application Block</a> to define the server-side only validation. </li><li><a name="condideration5" title="condideration5"></a>When your architecture is based on commands and queries, setting up a web service is really easy and almost maintenance free. This means that it can be very convenient to have multiple (almost identical) web services side by side, with slightly different configuration. Imagine a service for public clients with access to a sub set of commands and queries of a second service, meant for internal clients. This can be a nice extra layer of defense. Or both an (internal) WCF service and a public <a rel="external" href="http://www.asp.net/web-api" title="ASP.NET Web API">ASP.NET Web API</a> service. </li><li><a name="condideration6" title="condideration6"></a>And of course apply <a rel="external" href="http://msdn.microsoft.com/en-us/library/ms731059.aspx" title="Best Practices for Security in WCF">WCF best practices</a> when it comes to securing your web service (and do test this).</li></ul><p>Here is the GitHub project where you can find a working demo solution: <a rel="external" href="https://github.com/dotnetjunkie/solidservices" title="Highly Maintainable Web Services">https://github.com/dotnetjunkie/solidservices</a>.</p><p><font color="#FF0000">Update:</font>&nbsp;As discussed in the comments below, my current preference is to completely remove WCF SOAP serialization from the equation, whenever possible.&nbsp;Instead I make WCF completely unaware of the contract by just passing around strings back and forward, and I use JSON.NET to serialize and deserialize JSON objects and this has proven a magniture more flexible than any serialization mechanism that Microsoft supplies us with. This also removes annoying development issues such as&nbsp;<a rel="external" href="https://solidservices.codeplex.com/discussions/432055" title="How to properly update the client service reference">this</a>&nbsp;one. Another option is to ditch WCF completely and simply use Web API as message transport layer, as shown in the referenced solidservices project.</p><p>This is how I roll on the service side of my architecture.</p>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=Architecture">Architecture</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Dependency_injection">Dependency injection</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=95#comm" title="Daniel Hilgarth, Steven, Alex, Matt, Kaveh, Chris, itsik">twelve comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=95#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2012-m08.php#e95" title="Permanent link to 'Writing Highly Maintainable WCF Services' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=95" title="Permanent link to entry 'Writing Highly Maintainable WCF Services'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>twelve comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>You mention the ASP.NET WebAPI in the second to last bullet point. This usually is used to create REST APIs.<br />
But a web service implemented with the approach you show here wouldn't conform to the REST principles.<br />
Do you agree?<br /><small><b>Daniel Hilgarth</b>  (<a href='http://blog.fire-development.com'  title='blog.fire-development.com'>URL</a>) - 04 07 13 - 16:06 </small></p>
<p>@Daniel, A design based on commands and command handlers is by nature use case-driven compared to the resource-driven approach that the Richardson Maturity Model for RESTful services describes. Having a use case-driven web API is most suited when you (as a team) build both the web service and the client applications that make use of it. When exposing your web API to third parties however, you donâ€™t really know what use cases their applications implement. So in general it is better for an externally exposed web API to be resource-driven.<br />
<br />
Implementing a resource based API with commands and queries will probably be cumbersome. In that case you will probably have more success when implementing the web API on to of an IRepository&lt;TEntity&gt; abstraction instead of building it on top of an ICommandHandler&lt;TCommand&gt; abstraction.<br />
<br />
Note that using a generic interface is still important, because this allows you to apply cross-cutting concerns more easily, which will help you reach the goal that this blog post describes: having a highly maintainable web service.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'>URL</a>) - 10 07 13 - 20:27 </small></p>
<p>There's an interesting video online from NDC Oslo 2013 about "CQRS Hypermedia with WebAPI" that goes deeper into the previous discussion about resource driven and use case driven architectures with Web API: <a href="http://vimeo.com/68320468">http://vimeo.com/68320468</a><br /><small><b>Steven</b>   - 23 07 13 - 21:29 </small></p>
<a id="lastcomment"></a><p>I have a question: have you run into difficulties using an IEnumerable&lt;T> as a query result type? I get a CommunicationException:<br />
<br />
"There was an error while trying to serialize parameter <a href="http://tempuri.org/:QueryResult.">http://tempuri.org/:QueryResult.</a> The InnerException message was 'Type 'System.Linq.EnumerableEx+&lt;DoHelper>d__22`1My.Services.MyResult, My.Services.Contra..' with data contract name 'ArrayOfMyResult:http://schemas.datacontract.org/2004/07/My.Services.Contract' is not expected. Consider using a DataContractResolver or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializer.'.  Please see InnerException for more details."}<br />
<br />
I have triple-checked my type export code and IEnumerable&lt;MyResult> is definitely exported. However, the underlying type is <i>not</i>IEnumerable, it is (in this example) EnumerableEx. This is an implementation detail that is controlled by the QueryHandler's internal logic. Given that the QueryService returns a <b>dynamic</b> object, do you think that the DataContractSerializer is having trouble recognising the data contract type?<br />
<br />
It's definitely a difficulty in recognising the concrete type. I tried changing all of my IEnumerable&lt;T> to List&lt;T> (concrete list) and the problem was solved. Then I tried changing to IList&lt;T> and the problem re-appeared. I believe it must be the way that WCF inspects the type of the outgoing object - it's not smart enough to know what the exported query type should be. For now in my service I'll just stick to using List&lt;T>, but it would be good to know if anyone else has solved this in a better way.<br />
<br />
Can you think of a way around this?<br />
<br />
Many thanks<br /><small><b>Alex</b>   - 04 03 15 - 18:25 </small></p>
<p>Hi Alex,<br />
<br />
I have been banging my head on this in the past a lot. My conclusion is that WCF serialization sucks and doesn't really allow you to return right object graphs that are most practical for developers. Because of that, I moved away from WCF serialization altogether. Instead, my WCF contract now looks like this:<br />
<br />
public void Execute(string name, string json)<br />
<br />
Instead of relying on WCF to do the serialization, I use JSON.NET to serialize/deserialize objects from and to JSON (on both the client and the server). This works wonderfully well and has a few interesting advantages, but the serialization capabilities are most noticeable. JSON.NET can serialize/deserialize about anything. It serializes IEnumerable&lt;T> and IList&lt;T> without trouble. But just as cool, it can work with immutable types as well. These are things that standard .NET serialization simply can't do.<br />
<br />
Do note that this is not about changing from XML to JSON. I personally don't care about the format the objects have on the wire. So the fact that I use JSON as a serialization format is accidental. I use JSON.NET because it is extremely flexible and can serialize all things. Switching from the default serializer in WCF to the DataContractJsonSerializer will not do the trick, because you are bound to the same limitations that WCF serialization mechanism gives you.<br /><small><b>Steven</b>  (<a href='http://https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'  title='https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'>URL</a>) - 04 03 15 - 20:52 </small></p>
<p>Would love to see the body of your Execute(string name, string json) method...<br /><small><b>Matt</b>   - 30 09 15 - 18:19 </small></p>
<p>Hi @Matt,<br />
<br />
Here is a simplified version of what I use in one of my projects:<br />
<br />
[OperationContract]<br />
[FaultContract(typeof(ValidationError))]<br />
public void Execute(string typeName, string json) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;try {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type commandType = typeof(ICommand).Assembly.GetType(typeName);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type handlerType = typeof(ICommandHandler&lt;&gt;).MakeGenericType(commandType);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynamic command = JsonConvert.DeserializeObject(json, commandType);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynamic commandHandler = Bootstrapper.Container.GetInstance(handlerType);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commandHandler.Handle(command);<br />
&nbsp;&nbsp;&nbsp;&nbsp;} catch (ValidationException ex) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new FaultException&lt;ValidationError&gt;(<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ValidationError { ErrorMessage = ex.Message }, ex.Message);<br />
&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception ex) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bootstrapper.LogExceptionToDatabase(ex);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debug.WriteLine(ex.ToString());<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br /><small><b>Steven</b>   - 30 09 15 - 21:42 </small></p>
<p>Hi Steven, <br />
Why do you prefer to use a SOAP/WCF service when you're not using some of its capabilities such as API metadata generation, client proxy generation and data serialization, why not a single MVC action with custom model binder? Can't you leverage WCF extensibility to be able to build the service in the way you would like adhering to SOLID principles?<br /><small><b>Kaveh</b>   - 19 09 16 - 23:32 </small></p>
<p>> Why do you prefer to use a SOAP/WCF service when you're not using some of its capabilities such as API metadata generation<br />
<br />
As a matter of fact, I don't prefer SOAP/WCF at all. I think it's overly complicated, configuration heavy, and its serialization possibilities are severely limiting. I actually prefer a Web API approach.<br />
<br />
> why not a single MVC action with custom model binder?<br />
<br />
MVC with custom model binders is a lot of work. Instead, I use ASP.NET Web API with a custom delegating handler. Just take a look at the WebApiService project in my <a href="https://github.com/dotnetjunkie/solidservices">https://github.com/dotnetjunkie/solidser..</a> Github project. It's a fully working example implementation of a Web API based on this approach. It even generates Swagger documentation for you.<br /><small><b>Steven</b>  (<a href='http://https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'  title='https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'>URL</a>) - 19 09 16 - 23:44 </small></p>
<p>Hi Steven,<br />
I'm interested in learning more about this approach implemented as a Web API. Do you have samples of how the controllers would be implemented in your WebApiService project?<br /><small><b>Chris</b>   - 09 01 17 - 21:49 </small></p>
<p>Hi Chris,<br />
<br />
Take a look at my SolidServices project on Github: <a href="https://github.com/dotnetjunkie/solidservices.">https://github.com/dotnetjunkie/solidser..</a> It contains a fully working sample project for both WCF and Web API. In short, there are no controllers; just delegating handlers.<br /><small><b>Steven</b>  (<a href='http://https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'  title='https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=95'>URL</a>) - 09 01 17 - 21:53 </small></p>
<p>Hi Steven<br />
<br />
I enjoy reading your post and I have some question :<br />
1.Is it better to use the execute like in the example above <br />
public void Execute(string typeName, string json)<br />
 vs <br />
public void Execute(dynamic command) ?  is the any performance impact to generate the right service ?<br />
<br />
2.If you need to support messages in different type :Xml ,Json, or even message contain Hexadecimal string (IFSF protocol for authorize ,payment) <br />
how do you suggest to expose the service ,  WCF or WEBAPI ?<br />
one service for each format : ExecuteAsXML / ExecuteAsJson /ExecuteAsIFSF <br />
or same service and add to the request contract the type of message (maybe in the header)  ?<br />
<br />
3.If i need to expose service that need to do complex work and return data for example :<br />
Authorize(Request) payment flow that need to do many things as part of the IFSF payment protocol on the request :<br />
validate Token in the request, <br />
check if customerdata is valid,<br />
check if product list are valid to pay with the card based on card rule engine <br />
retrieve discount for each product<br />
check if transaction amount is allowed on the card <br />
if all validation not met for payment the response return decline with the item allowed and reason for decline.<br />
<br />
and if everything is OK create authorizationId and save amount of money on the card for a period time and  return discount , limits on card and authorize ID in the Response <br />
Can i take the commandHandler approach ? As on your artical commandHandler should be void or return Id of created record <br />
or maybe each action in the service should be commandHandler and QueryHandler <br />
and service just being injected by the necessary commandHandler and QueryHandler ?<br /><small><b>itsik</b>   - 07 08 18 - 23:01 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>