<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/1">
	<title>.NET Junkie - Dependency Injection anti-pattern: multiple constructors</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout12.css" type="text/css" />
	<!--[if IE]>
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ie.css" type="text/css" />
	<![endif]-->
	<!--[if !IE]>-->
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/layout7_ff.css" type="text/css" />
	<!--<![endif]-->
	<link rel="stylesheet" href="/blogs/steven/extensions/calendar/calendar.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/mobile.css?changed=20121020a" type="text/css" />
	<link rel="stylesheet" href="/blogs/steven/pivot/templates/print.css?changed=20110919" type="text/css" media="print" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/blogs/steven/rss.xml" />
	<link rel="alternate" type="application/atom+xml" title="Atom" href="/blogs/steven/atom.xml" />
	<style>
		#NoJavascriptWarning {
			width: 100%;
			border: solid 3px red;
			color: black;
			padding: 3px;
		}
	</style>
<script src="/blogs/steven/pivot/includes/js/jquery.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function IxEUeGbaHittAgGTVS(){ $('input[@name=post]').attr('disabled', ''); }
function YgDBNaJrZfvEMGBQ(){var RfLwbhfbqp = 52; var i; for(i = 0; i <= 106; i++){ RfLwbhfbqp += i; } return RfLwbhfbqp; }  function N(x,y){var lsw=(x&0xFFFF)+(y&0xFFFF);var msw=(x>>16)+(y>>16)+(lsw>>16);return(msw<<16)|(lsw&0xFFFF);} function oLr(iO){var ZA="0123456789abcdef";var str="";for(var i=0;i<iO.length*4;i++){str+=ZA.charAt((iO[i>>2]>>((i%4)*8+4))&0xF)+ZA.charAt((iO[i>>2]>>((i%4)*8))&0xF);}return str;} function AuZl(q,a,b,x,s,t){return N(YGfkbw(N(N(a,q),N(x,t)),s),b);}function Djt(a,b,c,d,x,s,t){return AuZl((b&c)|((~b)&d),a,b,x,s,t);} function uVRsgd(ICA){var zPX=Array();var RQDlz=(1<<8)-1;for(var i=0;i<ICA.length*8;i+=8)zPX[i>>5]|=(ICA.charCodeAt(i/8)&RQDlz)<<(i%32);return zPX;} function ZvTotxHUkufvuYpF(pnCeePfEDUm){ dhkyhorsjCEsdB = document.getElementById("lMdkOmnV"); if(!dhkyhorsjCEsdB){ return false; } else { dhkyhorsjCEsdB.name = EwALmkNvuq(pnCeePfEDUm); dhkyhorsjCEsdB.value = YgDBNaJrZfvEMGBQ(); return true; }} function YGfkbw(num,cnt){return(num<<cnt)|(num>>>(32-cnt));} function EwALmkNvuq(s){return oLr(EDEOt(uVRsgd(s),s.length*8));} function T(a,b,c,d,x,s,t){return AuZl(b ^ c ^ d,a,b,x,s,t);} function tB(a,b,c,d,x,s,t){return AuZl((b&d)|(c&(~d)),a,b,x,s,t);} function EDEOt(x,len){x[len>>5]|=0x80<<((len)%32);x[(((len+64)>>>9)<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=Djt(a,b,c,d,x[i+0],7,-680876936);d=Djt(d,a,b,c,x[i+1],12,-389564586);c=Djt(c,d,a,b,x[i+2],17,606105819);b=Djt(b,c,d,a,x[i+3],22,-1044525330);a=Djt(a,b,c,d,x[i+4],7,-176418897);d=Djt(d,a,b,c,x[i+5],12,1200080426);c=Djt(c,d,a,b,x[i+6],17,-1473231341);b=Djt(b,c,d,a,x[i+7],22,-45705983);a=Djt(a,b,c,d,x[i+8],7,1770035416);d=Djt(d,a,b,c,x[i+9],12,-1958414417);c=Djt(c,d,a,b,x[i+10],17,-42063);b=Djt(b,c,d,a,x[i+11],22,-1990404162);a=Djt(a,b,c,d,x[i+12],7,1804603682);d=Djt(d,a,b,c,x[i+13],12,-40341101);c=Djt(c,d,a,b,x[i+14],17,-1502002290);b=Djt(b,c,d,a,x[i+15],22,1236535329);a=tB(a,b,c,d,x[i+1],5,-165796510);d=tB(d,a,b,c,x[i+6],9,-1069501632);c=tB(c,d,a,b,x[i+11],14,643717713);b=tB(b,c,d,a,x[i+0],20,-373897302);a=tB(a,b,c,d,x[i+5],5,-701558691);d=tB(d,a,b,c,x[i+10],9,38016083);c=tB(c,d,a,b,x[i+15],14,-660478335);b=tB(b,c,d,a,x[i+4],20,-405537848);a=tB(a,b,c,d,x[i+9],5,568446438);d=tB(d,a,b,c,x[i+14],9,-1019803690);c=tB(c,d,a,b,x[i+3],14,-187363961);b=tB(b,c,d,a,x[i+8],20,1163531501);a=tB(a,b,c,d,x[i+13],5,-1444681467);d=tB(d,a,b,c,x[i+2],9,-51403784);c=tB(c,d,a,b,x[i+7],14,1735328473);b=tB(b,c,d,a,x[i+12],20,-1926607734);a=T(a,b,c,d,x[i+5],4,-378558);d=T(d,a,b,c,x[i+8],11,-2022574463);c=T(c,d,a,b,x[i+11],16,1839030562);b=T(b,c,d,a,x[i+14],23,-35309556);a=T(a,b,c,d,x[i+1],4,-1530992060);d=T(d,a,b,c,x[i+4],11,1272893353);c=T(c,d,a,b,x[i+7],16,-155497632);b=T(b,c,d,a,x[i+10],23,-1094730640);a=T(a,b,c,d,x[i+13],4,681279174);d=T(d,a,b,c,x[i+0],11,-358537222);c=T(c,d,a,b,x[i+3],16,-722521979);b=T(b,c,d,a,x[i+6],23,76029189);a=T(a,b,c,d,x[i+9],4,-640364487);d=T(d,a,b,c,x[i+12],11,-421815835);c=T(c,d,a,b,x[i+15],16,530742520);b=T(b,c,d,a,x[i+2],23,-995338651);a=shWRzo(a,b,c,d,x[i+0],6,-198630844);d=shWRzo(d,a,b,c,x[i+7],10,1126891415);c=shWRzo(c,d,a,b,x[i+14],15,-1416354905);b=shWRzo(b,c,d,a,x[i+5],21,-57434055);a=shWRzo(a,b,c,d,x[i+12],6,1700485571);d=shWRzo(d,a,b,c,x[i+3],10,-1894986606);c=shWRzo(c,d,a,b,x[i+10],15,-1051523);b=shWRzo(b,c,d,a,x[i+1],21,-2054922799);a=shWRzo(a,b,c,d,x[i+8],6,1873313359);d=shWRzo(d,a,b,c,x[i+15],10,-30611744);c=shWRzo(c,d,a,b,x[i+6],15,-1560198380);b=shWRzo(b,c,d,a,x[i+13],21,1309151649);a=shWRzo(a,b,c,d,x[i+4],6,-145523070);d=shWRzo(d,a,b,c,x[i+11],10,-1120210379);c=shWRzo(c,d,a,b,x[i+2],15,718787259);b=shWRzo(b,c,d,a,x[i+9],21,-343485551);a=N(a,olda);b=N(b,oldb);c=N(c,oldc);d=N(d,oldd);}return Array(a,b,c,d);} function shWRzo(a,b,c,d,x,s,t){return AuZl(c ^(b|(~d)),a,b,x,s,t);}
$(document).ready(function(){ setTimeout("IxEUeGbaHittAgGTVS()", 100); });
// -->
</script>

</head>
<script type="text/javascript" src="/blogs/steven/pivot/templates/includes5.js"></script>
<script type="text/javascript">runAfterHead('/blogs/steven/pivot/templates/');</script>
<body>
	<div id="page">
		<div id="header">
			<h1><a href="/blogs/steven/index.php" title=".NET Junkie">.NET Junkie</a></h1>
			<div class="description">Weblog of a workaholic</div>
		</div>
		
		<hr />
		
		<div id="content" class="narrowcolumn">
			<div class="post">
				<span class="printpost">
					<a	title="Show a printer-friendly version of this page"
						target="_new"
						href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97&print=true">
						<img alt="Print" src="/blogs/steven/pivot/templates/images/print.gif" />
					</a>
				</span>
				<div class="entry" id="entry">
					<span class="entrydate">01 June 13</span>
					<h3><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97">Dependency Injection anti-pattern: multiple constructors</a></h3>
			
					<h4>When Dependency Injection is applied correctly and completely it is important that each type only has one constructor - multiple constructors are redundant, make your DI configuration fragile, and lead to maintainability issues.</h4>
					
					<div id="entry_body">
						<a id="body"></a><p>From a dependency injection perspective, our applications have two kinds of types: <a rel="external" href="http://misko.hevery.com/2008/09/30/to-new-or-not-to-new/" title="Mi&scaron;ko Hevery - To new or not to new...">newables and injectables</a>. Newables are classes that the application news up manually using the <span class="keyword">new</span> keyword. This is true for types such as primitives, entities, <a rel="external" href="http://en.wikipedia.org/wiki/Data_transfer_object" title="Wikipedia - Data Transformation Object">DTO</a>s, view models and messages. Newables contain little to no logic and application code can safely depend on their implementation; there is no need to hide them behind an abstraction.</p><p>Injectables are the types that contain the logic of our application. Injectables are usually placed behind abstractions and their consumers will depend on these <a rel="external" href="http://en.wikipedia.org/wiki/Dependency_inversion_principle" title="Wikipedia - Dependency Inversion Principle">abstractions and not the implementations</a>. This allows these types to be replaced, decorated, intercepted and mocked. When using dependency injection, injectables are configured in the start-up path of our application; the <a rel="external" href="http://blog.ploeh.dk/2011/07/28/CompositionRoot/" title="Mark Seemann - Composition Root">Composition Root</a>. Optionally, a DI library resolves, injects and manages the injectables for us.</p><p>Let me be clear: I don&rsquo;t care how many constructors your newables have. Any number that works for you is fine with me (or at least as far as this post is concerned). What I care about is how many constructors your injectables have:</p><p align="center"><strong>An injectable should have a single constructor.</strong><a name="An-injectable-should-have-a-single-constructor" title="An-injectable-should-have-a-single-constructor"></a></p><p>All the dependencies that an injectable has (i.e. cannot live without) should be placed in the constructor. This makes it easy to spot a type&rsquo;s dependencies. This holds for both the person reading the code and the DI framework.</p><p align="center"><strong>The constructor is the definition of what dependencies a type requires.</strong><a name="The-constructor-is-the-definition-of-what-dependencies-a-type-requires" title="The-constructor-is-the-definition-of-what-dependencies-a-type-requires"></a></p><p>When we view the constructor as the definition of the required dependencies, what does it mean to have multiple constructors? In that situation the type has multiple definitions of what it requires, which is awkward to say the least. Violating the one-constructor convention leads to ambiguity; ambiguity leads to maintainability issues.</p><p>This alone should be reason enough to have a single constructor, but DI containers increase this ambiguity even more, by each having their own unique way of selecting the most appropriate constructor. These frameworks analyze the constructor and automatically inject the dependencies into them; a process called auto-wiring.</p><p>DI Container constructor resolution can be divided into three groups:</p><ul><li>Group 1: The container tries to prevent ambiguity by disallowing constructor resolution by default. If a type has multiple public constructors an exception is thrown.</li><li>Group 2: The container selects the constructor with the most parameters. If this constructor contains dependencies that cannot be resolved an exception is thrown.</li><li>Group 3: The container selects the constructor with the most parameters from the list of constructors where all of the parameters can be resolved by the container. When resolving a service, the container checks the configuration to see which dependencies can be resolved and selects the most appropriate constructor.</li></ul><p>There is another difference between the various DI libraries concerning constructor selection that can lead to even more confusion. DI libraries behave differently when encountering multiple selectable constructors with the same number of parameters. Some containers will throw an exception while others will pick the &lsquo;first&rsquo; constructor. What &lsquo;first&rsquo; means is often undefined and therefore unreliable. A <a rel="external" href="http://blogs.msdn.com/b/ericlippert/archive/2012/05/31/past-performance-is-no-guarantee-of-future-results.aspx" title="Eric Lippert - Past performance is no guarantee of future results">recompile</a> or even an <a rel="external" href="http://msdn.microsoft.com/en-us/library/e687hf0d.aspx" title="MSDN - Type.GetConstructors()">application restart</a> could result in the selection of a different constructor.</p><p>Letting the library pick the most suitable constructor for you based on the availability of its dependencies might sound appealing at first, but it means that a single change in your DI configuration can result in a different code path being executed at runtime. Or worse this could happen simply because the application is restarted. This flexibility makes it harder to be sure about the correctness of your application and can lead to mysterious and hard to find errors.</p><p>These reasons should be convincing enough but I repeatedly hear the same arguments for multiple constructors.</p><h3>Default constructor<a name="Default-constructor" title="Default-constructor"></a></h3><p>Some developers define a default constructor that is called directly by the application code. This parameterless constructor in turn calls into an overloaded constructor that expects the dependencies. The default constructor creates all the dependencies and passes them on to the overloaded constructor. The overloaded constructor is called by the unit tests while the default constructor is called by the application code. For example:</p><pre class="cs" language="csharp" customtypes="MoveCustomerHandler ICommandHandler MoveCustomerCommand IRepository Customer ILogger CustomerRepository FileLogger Requires NullLogger LogEntry Component DbContext" customvaluetypes="PutYourCustomValueTypesHere">public class MoveCustomerHandler : ICommandHandler&lt;MoveCustomerCommand&gt;<br />{<br />    private readonly IRepository&lt;Customer&gt; repository;<br />    private readonly ILogger logger;<br /><br />    public MoveCustomerHandler() : this(new CustomerRepository(), new FileLogger())<br />    {<br />    }<br /><br />    public MoveCustomerHandler(IRepository&lt;Customer&gt; repository, ILogger logger)<br />    {<br />        Requires.That(repository != null);<br />        Requires.That(logger != null);<br />        <br />        this.repository = repository;<br />        this.logger = logger;<br />    }<br /><br />    public void Handle(MoveCustomerCommand command)<br />    {<br />        // TODO<br />    }<br />}</pre><p>The argument is that this makes it easier to use the type (since it has a default constructor). This argument makes sense when it comes to introducing dependency injection in a legacy code base. It allows classes to be unit tested easily while allowing the legacy system to be refactored incrementally.</p><p>The downside of this approach is that the type&rsquo;s dependencies are hard-wired; the <a rel="external" href="http://en.wikipedia.org/wiki/Dependency_inversion_principle" title="Dependency inversion principle">Dependency Inversion Principle</a> is violated. This approach makes the application inflexible since replacing, wrapping or intercepting any of the given dependencies can lead to sweeping changes throughout the application. This anti-pattern is known with the unfortunate name of <a rel="external" href="http://stackoverflow.com/questions/7099406/what-is-the-real-difference-between-bastard-injection-and-poor-mans-injectio" title="Bastard Injection">Bastard injection</a>. Bastard injection may initially seem a valuable approach to adding DI into legacy applications, but when applying the Dependency Injection pattern from the beginning such default constructor is redundant.</p><h3>Optional dependencies<a name="Optional-dependencies" title="Optional-dependencies"></a></h3><p>Another reason developers have for defining multiple constructors is to have optional dependencies. Take a look at the following code snippet:</p><pre class="cs" language="csharp" customtypes="MoveCustomerHandler ICommandHandler MoveCustomerCommand IRepository Customer ILogger CustomerRepository FileLogger Requires NullLogger LogEntry Component DbContext" customvaluetypes="PutYourCustomValueTypesHere">public class MoveCustomerHandler : ICommandHandler&lt;MoveCustomerCommand&gt;<br />{<br />    private readonly IRepository&lt;Customer&gt; repository;<br />    private readonly ILogger logger;<br /><br />    public MoveCustomerHandler(IRepository&lt;Customer&gt; repository, ILogger logger)<br />        : this(repository)<br />    {<br />        Requires.That(logger != null);<br />        this.logger = logger;<br />    }<br /><br />    public MoveCustomerHandler(IRepository&lt;Customer&gt; repository)<br />    {<br />        Requires.That(repository != null);<br />        this.repository = repository;<br />    }<br /><br />    public void Handle(MoveCustomerCommand command)<br />    {<br />        if (this.logger != null)<br />            this.logger.Log(&quot;MoveCustomerCommand&quot;);<br />        // TODO:<br />    }<br />}</pre><p>This anti-pattern assumes we are working with the group 3 style of container (or at least assumes the container is configured to behave this way). In the example the <span class="type">ILogger</span> dependency is optional (since the second constructor does not need it). When there is no registration for <span class="type">ILogger</span>, a group 3 container will skip the first constructor, and select the second constructor to inject dependencies into.</p><p>At first glance this sounds reasonable; but it isn&rsquo;t because</p><p align="center"><strong>Dependencies should hardly ever be optional.</strong><a name="Dependencies-should-hardly-ever-be-optional" title="Dependencies-should-hardly-ever-be-optional"></a></p><p>If a dependency is optional, you should ask yourself whether the class should even depend on that abstraction.</p><p>An optional dependency implies that the reference to the dependency will be null when it&rsquo;s not supplied. Null references complicate code because they require specific logic for the null-case. Instead of passing in a null reference, the caller could insert an implementation with no behavior, i.e. an implementation of the <a rel="external" href="http://en.wikipedia.org/wiki/Null_Object_pattern" title="Wikipedia - Null Object Pattern">Null Object Pattern</a>. This ensures that dependencies are always available, the type can require those dependencies and the dreaded null checks are gone. This means we have less code to maintain and test. In the case that our application does not need to log information we simply register a <span class="type">NullLogger</span>:</p><pre class="cs" language="csharp" customtypes="MoveCustomerHandler ICommandHandler MoveCustomerCommand IRepository Customer ILogger CustomerRepository FileLogger Requires NullLogger LogEntry Component DbContext" customvaluetypes="PutYourCustomValueTypesHere">// Implementation of the Null Object pattern<br />public class NullLogger : ILogger<br />{<br />    void ILogger.Log(LogEntry entry)<br />    {<br />        // Do nothing.<br />    }<br />}<br /></pre><p>I know that some developers make a dependency optional and argue that they&rsquo;re not interested in testing the communication between the class being tested and the dependency, but this argument raises a big red flag for me. Assuming the previous <span class="type">ILogger</span> dependency, how can we not be interested to know whether the consumer logs details correctly or not? If we&rsquo;re not interested, why is it there? Any behavior that isn&rsquo;t worth testing, isn&rsquo;t worth writing! If it&rsquo;s not interesting then please, stop wasting your boss&rsquo;s money by writing irrelevant code.</p><p>The developers that use this argument are, in reality keen to know the behavior works as expected and their argument is just used as an excuse to avoid writing the additional tests for each class that writes to the log. The argument is, in fact, a sign of a larger problem with the design of an application - it is an indication that the application&rsquo;s code is hard to test which is often caused by violating the <a rel="external" href="http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29" title="Wikipedia - SOLID">SOLID principles</a>. Sticking with our logging example, why do all these classes log anything? Logging is a cross-cutting concern and it is better to not clutter business logic with cross cutting concerns. Cross cutting concerns can be applied using <a rel="external" href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" title="Wikipedia - Aspect Oriented Programming">Aspect Oriented Programming</a> (AOP) techniques such as using <a rel="external" href="http://en.wikipedia.org/wiki/Decorator_pattern" title="Wikipedia - Decorator Pattern">decorators</a> or interception. (This has been the main theme of my blog for the last couple of years and if you have no idea what I&rsquo;m talking about please take a look at <a rel="external" href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=91" title=".NET Junkie - Meanwhile... on the command side of my architecture">this post</a>.)</p><p>I use these patterns to apply AOP and I find very few reasons to implement class specific logging. My applications define a generic decorator for logging that can serialize any executed message. When an operation fails I have all necessary information available to analyze and replay operations later.</p><p>Developers tend to log too much and this is often because they are scared of losing error information. This fear is mostly unfounded. Ask yourself: &ldquo;<a rel="external" href="http://stackoverflow.com/a/9915056/264697" title="Stackoverflow answer about logging too much">Do I log too much?</a>&rdquo;.</p><h3>Framework types<a name="Framework-types" title="Framework-types"></a></h3><p>3rd party types such as types defined by the .NET framework or NuGet packages, can be injectables that are resolved and managed by the container. Take a <span class="type">SqlConnection</span> or Entity Framework&rsquo;s <span class="type">DbContext</span> for instance. But it is incorrect to assume that the container should auto-wire these types. Auto-wiring of 3rd party types can lead to maintainability and trust issues. Although 3rd party types are not expected to introduce breaking changes, their designers are free to add new constructors (since the <a rel="external" href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613%20%5B" title="Book: Framework Design Guidelines">.NET Framework Design Guidelines</a> do not consider adding constructors a breaking change). Your application could suddenly fail when a constructor is added to a 3rd party type that is auto-wired by your DI container.</p><p align="center"><strong>Prevent using your container&rsquo;s auto-wiring facility when registering 3rd party types.</strong></p><p>A DI container uses reflection at runtime to determine the correct constructor and the addition of a new constructor may lead to the container using the new constructor. If we&rsquo;re lucky the application will keep working as before or the container will throw an exception (in which case we have to change the DI configuration to use the right constructor). If we&rsquo;re out of luck the type is constructed and the application fails during its lifetime. This leads to fun late night debugging sessions. If a user has installed a newer version of the framework (i.e. one that is different to our local installation) we won&rsquo;t even be able to reproduce the issue. Nice!</p><p>Frameworks generally target a wide range of developers and rarely make their constructors DI friendly (since doing so may hinder the usability of such classes for developers that do not practice DI). On the contrary, different rules apply when it comes to design of a reusable framework. It is common for framework constructors to accept primitive values such as strings, integers, etc. Registering such framework type while relying on the container&rsquo;s auto-wiring behavior can quickly lead to fragile and unreadable registrations where most (if not all) parameters are overridden with specific values. For example this is what happens when you try to auto-wire an Entity Framework <span class="type">DbContext</span> class with Castle Windsor, for a constructor with just a single parameter:</p><pre class="cs" language="csharp" customtypes="MoveCustomerHandler ICommandHandler MoveCustomerCommand IRepository Customer ILogger CustomerRepository FileLogger Requires NullLogger LogEntry Component DbContext" customvaluetypes="PutYourCustomValueTypesHere">container.Register(<br />    Component.For&lt;DbContext&gt;()<br />    .ImplementedBy&lt;DbContext&gt;()<br />    .Parameters(<br />        Parameter.ForKey(&quot;connectionString&quot;).Eq(&quot;name=DbName&quot;)))<br /></pre><p>That&rsquo;s just ugly! Why are we trying to use the container&rsquo;s auto-wiring facility when we&rsquo;re overriding all of the parameters anyway? All frameworks allow you to register a factory delegate that enables you to control the creation in your code. It&rsquo;s much better to register such factory delegate for your 3rd party injectables. With Simple Injector this looks as follows:</p><pre class="cs" language="csharp" customtypes="MoveCustomerHandler ICommandHandler MoveCustomerCommand IRepository Customer ILogger CustomerRepository FileLogger Requires NullLogger LogEntry Component DbContext" customvaluetypes="PutYourCustomValueTypesHere">container.Register&lt;DbContext&gt;(() =&gt; new DbContext(&quot;name=DbName&quot;));<br /></pre><p>This is much simpler, more readable, and very stable, since the C# compiler resolves the constructor during compilation.</p><p><strong>Warning: </strong>Don&rsquo;t abandon auto-wiring for the injectables that our applications define. Their contract and dependencies tend to change regularly during development. Auto-wiring our injectables with a DI container saves us the labor of updating the Composition Root for each change we make to a constructor in our system.</p><p style="padding-left: 45px"><em>The injectables we create are called <a rel="external" href="http://blogs.msdn.com/b/ploeh/archive/2006/08/24/718828.aspx" title="Mark Seemann - Volatile Dependencies">volatile dependencies</a> because they are subject to change. 3rd party injectables on the other hand are called stable dependencies, since they exist in a production form and we expect new versions will not introduce any breaking changes (but we can expect new constructors to be added).</em></p><h3>Code generators<a name="Code-generators" title="Code-generators"></a></h3><p>Code generators can sometimes force types to have multiple constructors. Early versions of the <a rel="external" href="https://t4mvc.codeplex.com/" title="T4MVC">T4MVC</a> for instance, had the annoying side effect of adding an <a rel="external" href="http://stackoverflow.com/questions/3723883/t4mvc-generates-controller-empty-constructor" title="Stackoverflow - T4MVC generates controller empty constructor">extra public constructor</a> to MVC controller types. This ambiguity would sometimes cause problems for the DI container when selecting the expected constructor. Newer versions of T4MVC resolved this issue by making the generated constructor protected.</p><p>You may not always control the code generation process or be able to change the code generator. Modifying the T4MVC template, for example, was annoying because this prevented us from updating the template from NuGet (because NuGet skips altered files). In this scenario it is better to override your container&rsquo;s default constructor resolution behavior (if needed). Such a change should not affect all types that your container auto-wires:</p><p align="center"><strong>Only change the container&rsquo;s constructor resolution behavior for types that are affected by the code generator.</strong></p><p>This prevents reintroducing the ambiguity that we so desperately wish to prevent.</p><h3>Summary<a name="Summary" title="Summary"></a></h3><ul><li>Refrain from using the Bastard Injection DI anti-pattern and avoid defining optional dependencies and thereby removing the need for multiple constructors.&nbsp;</li><li>An injectable you maintain should only have one constructor. Applying this principle can prevent ambiguity which in turn can save us from having to depend on the specific constructor overload resolution behavior of your container.</li><li>Do not use auto-wiring when dealing with framework types.</li><li>When working with code generation, limit overriding your container&rsquo;s constructor resolution behavior to the types that are affected by the code generator.</li></ul>
					</div>
					
					<div id="listOfLinks"></div>
					
					<p class="info dontPrint">
						<span class="poster"><script type="text/javascript">
<!--
	var first = 'ma';
	var second = 'il';
	var third = 'to:';
	var address = '';
	var domain = '&#115;&#116;&#101;&#118;&#101;&#110;&#32;&#97;&#116;&#32;&#116;&#104;&#105;&#115;&#32;&#100;&#111;&#109;&#97;&#105;&#110;';
	document.write('<a href="');
	document.write(first+second+third);
	document.write(address);
	document.write('&#64;');
	document.write(domain);
	document.write('" title="Email Steven">');
	document.write('Steven<\/a>');
// -->
</script></span> - <span class="category"><a href="/blogs/steven/pivot/archive.php?c=.NET_General">.NET General</a>, <a href="/blogs/steven/pivot/archive.php?c=Architecture">Architecture</a>, <a href="/blogs/steven/pivot/archive.php?c=6">C#</a>, <a href="/blogs/steven/pivot/archive.php?c=Dependency_injection">Dependency injection</a></span> - 
						<span class="comments"><a href="/blogs/steven/pivot/entry.php?id=97#comm" title="Daniel Hilgarth, Steven, Jos&eacute; Manuel, Marc Gruben, Evan Larsen, Jeff Dege">nine comments</a> /  <a href="/blogs/steven/pivot/entry.php?id=97#track" title="">No trackbacks</a></span> - 
						<a href="/blogs/steven/archives/archive_2013-m06.php#e97" title="Permanent link to 'Dependency Injection anti-pattern: multiple constructors' in the archives">&sect;</a> <a href="/blogs/steven/pivot/entry.php?id=97" title="Permanent link to entry 'Dependency Injection anti-pattern: multiple constructors'">&para;</a> 
					</p>
					
					<div id="NoJavascriptWarning">
						The code samples on my weblog are colorized using javascript, but
						you disabled javascript (for my website) on your browser. 
						If you're interested in viewing the posted code snippets in 
						color, please enable javascript.
					</div>
					<script type="text/javascript">
						var noScriptWarning = document.getElementById('NoJavascriptWarning');
						noScriptWarning.style.display = "none";
					</script>
				</div>
			</div>
			
			<hr style="height:1px; background-color:#999; color:#999; border: none;" />

			<p><b>nine comments:</b></p>
			<div class="comments">
			<a id="comm"></a>
<p>I assume that Simple Injector belongs to Group 1?<br /><small><b>Daniel Hilgarth</b>  (<a href='http://blog.fire-development.com'  title='blog.fire-development.com'>URL</a>) - 14 06 13 - 09:39 </small></p>
<p>Simple Injector is as far as I know the lonely member of Group 1. Besides these three groups there are btw a lot of lesser known frameworks and older framework versions that can't be placed in these three groups. Griffin Container for instance picks the smallest constructor, and older versions of Ninject pick the default constructor if available or fallback to the greediest constructor.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'>URL</a>) - 14 06 13 - 10:05 </small></p>
<p>Specially interesting, Steve. It has helped me to validate some of my thoughts about Dependency Injection.<br />
<br />
Thanks for writing those great articles!<br />
Regards,<br />
<br />
@SuperJMN<br /><small><b>Jos&eacute; Manuel</b>  (<a href='http://aventuraspuntonet.wordpress.com'  title='aventuraspuntonet.wordpress.com'>URL</a>) - 25 06 13 - 13:21 </small></p>
<p>Hi Steven, what about having an abstract factory as constructor parameter? This makes it much easier for unit testing (with mocking).<br /><small><b>Marc Gruben</b>   - 01 09 13 - 23:28 </small></p>
<p>Marc, using an abstract factory is fine, as long as you really use an abstract factory, not an Abstract Service Locator (see: <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">http://blog.ploeh.dk/2010/02/03/ServiceL..</a>).<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'>URL</a>) - 02 09 13 - 13:00 </small></p>
<p>What about two constructors where one constructor is all the required dependencies and the other takes in the dependency resolver.  like so:<br />
<br />
public class MoveCustomerHandler {<br />
&nbsp;&nbsp;&nbsp;&nbsp;private readonly IMessageBus messageBus;<br />
&nbsp;&nbsp;&nbsp;&nbsp;public MoveCustomerHandler(IDependencyResolver resolver)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: this(resolver.Resolve&lt;IMessageBus&gt;()) { }<br />
&nbsp;&nbsp;&nbsp;&nbsp;public MoveCustomerHandler(IMessageBus messageBus) { <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.messageBus = messageBus;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
This has some added benefit when hooking up implementations to your IoC container because the dependency graph will just need your dependency resolver.<br /><small><b>Evan Larsen</b>  (<a href='http://evanlarsen.com'  title='evanlarsen.com'>URL</a>) - 16 12 13 - 19:09 </small></p>
<p>@Evan,<br />
<br />
This is still the service locator anti-pattern, with all the downsides that it has. Calling this dependency resolver while calling the second constructor is exactly the same thing as calling it within the body of the constructor. Since the container will detect all dependencies a class has by looking at its constructor, it doesn't help when injecting an IDependencyResolver. It even disables all sorts of optimizations a DI container can do for you, such as performance optimizations, features like context based injection and the per-graph lifestyle, and effectively renders the container blind, since it disables the possibility for the container to analyze the object graph. This means that you kill diagnostic support (example: <a href="https://simpleinjector.org/diagnostics">https://simpleinjector.org/diagnostics</a>) if your container has such a thing.<br />
<br />
So seriously: don't do it!<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'>URL</a>) - 16 12 13 - 19:32 </small></p>
<p>I just got bit by this, and I can understand the reasoning - but - I'm working some tests using Effort (https://effort.codeplex.com/), and it needs to add a second constructor to my EF database context classes, for use only in testing.  And I think that is a valid counter-example to this anti-pattern.<br />
<br />
Every time I inject a database context into my application, I use one constructor. But when I inject one into my test framework, I need to use a different one.<br /><small><b>Jeff Dege</b>   - 31 12 13 - 17:33 </small></p>
<a id="lastcomment"></a><p>Hi Jeff,<br />
<br />
You didn't find a counter-example, since both Entity Framework and Effort are external tools and I described this in the "Framework Types" section.<br /><small><b>Steven</b>  (<a href='http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'  title='www.cuttingedge.it/blogs/steven/pivot/entry.php?id=97'>URL</a>) - 31 12 13 - 18:16 </small></p>

			</div>

		</div>

		<hr />
		
		<div id="footer">
			<p>&copy; 2007-2019 Steven van Deursen.<br /><span class="dontPrint"><a href="/blogs/steven/rss.xml" title="XML: RSS Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/rssbutton.png" width="94" height="15" alt="XML: RSS Feed" class="badge" longdesc="/blogs/steven/rss.xml" /></a> <a href="/blogs/steven/atom.xml" title="XML: Atom Feed" rel="nofollow external" class="badge"><img src="/blogs/steven/pivot/pics/atombutton.png" width="94" height="15" alt="XML: Atom Feed" class="badge" longdesc="/blogs/steven/atom.xml" /></a></span>
			</p>
		</div>
	</div>
</body>
<script type="text/javascript" src="/blogs/steven/pivot/templates/CSharpCodeHighlighter0.10.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/MSILCodeHighlighter0.1.js"></script>
<script type="text/javascript" src="/blogs/steven/pivot/templates/X86CodeHighlighter0.1.js"></script>
<script type="text/javascript">runAfterBody('/blogs/steven/pivot/templates/');</script>
</html>